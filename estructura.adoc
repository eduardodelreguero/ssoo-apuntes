== Estructura de los sistemas operativos
include::attributes.adoc[]
:imagesdir: {imagesdir}/estructura

=== Organización de los sistemas operativos

El estudio de la organización interna de los sistemas operativos
requiere del análisis de tres aspectos diferentes:

1.  Los componentes del sistema
operativo y sus interconexiones (véase el apartado
<<_componentes_del_sistema>>).

2.  Los servicios que el sistema operativo proporciona a través del
funcionamiento coordinado de dichos componentes (véase la ).

3.  La interfaz de programación que el sistema operativo ofrece a
usuarios y programadores como forma de acceso a dichos servicios.

El estudio de los componentes del sistema operativo lo dejaremos para
más adelante, tras ver la forma usual en la que los programas acceden a
los servicios del sistema operativo y, por tanto, en la que se comunican
indirectamente con dichos componentes. Respecto a los servicios que el
sistema operativo proporciona, no entraremos en ello puesto que cada uno
ofrece servicios diferentes, aunque siempre es posible identificar unos
pocos tipos comunes a todos.

==== Interfaz de programación de aplicaciones

Un sistema operativo proporciona un entorno controlado para la ejecución
de programas. Dicho entorno debe proporcionar ciertos servicios que
pueden ser accedidos por los programas a través de una *interfaz de
programación de aplicaciones* o *API* (_Application Programming
Interface_). Algunas de las API disponibles para los desarrolladores de
aplicaciones son la API Win32 —en sistemas Microsoft Windows— y la API
POSIX para sistemas compatibles POSIXfootnote:[POSIX (_Portable
Operating System Interface for Unix_) es el nombre de una familia de
estándares que definen una interfaz de programación de aplicaciones para
sistemas operativos. Esto permite que un mismo programa pueda ser
ejecutado en distintas plataformas, siempre que sean compatibles con
POSIX. La práctica totalidad de los sistemas UNIX modernos son
compatibles POSIX ya que la especificación deriva de la interfaces
típicas en ese tipo de sistemas antes de la aparición del estándar
POSIX.] —como es el caso de los diferentes UNIX, Linux y macOS—.

Concretamente, _junto a cada intérprete o compilador de un lenguaje
de programación suele ir una *librería estándar* que ofrece clases y/o
funciones con las que los programas pueden acceder a los servicios del
sistema operativo y realizar las tareas más comunes_. Estas librerías
generalmente no forman parte del sistema operativo, sino de las
herramientas de desarrollo de cada lenguaje de programación, y
constituyen la _interfaz de programación de aplicaciones_ (API) del
lenguaje al que acompañan.

Las librerías estándar necesitan acceder a los
servicios del sistema operativo para, a su vez, dar servicio a los
programas que las usan. Es decir, cuando un programa invoca alguna
función o método de la librería estándar que lo acompaña, es muy
probable que ésta necesite invocar uno o más servicios del sistema
operativo para atender la petición convenientemente. Para ello las
librerías estándar utilizan la _librería del sistema_ —o librerías del
sistema, en el caso de que hayan varias— que acompaña al sistema
operativo.

[NOTE]
====
Por ejemplo, en el lenguaje de programación Python se debe utilizar la función `open()` de la librería estándar de Python para abrir o crear un archivo:

[source, python]
----
f = open("example.txt", "r")
----

Mientras que en el lenguaje de programación C la función equivalente de la librería estándar de dicho lenguaje es `fopen()`:

[source, c]
----
FILE* fp = fopen("example.txt", "r")
----

Ninguna de las dos funciones puede hacer su trabajo sin la ayuda del sistema operativo, porque sólo el sistema operativo tiene acceso a los discos duros y al resto de dispositivos del almacenamiento.
Así que ambas funciones están obligadas a solicitar la operación al sistema operativo, a través de la librería del sistema. Por ejemplo, en Microsoft Windows, tanto `open()` en Python como `fopen()` en C tiene que llamar internamente la función `CreateFile()` de la librería del sistema (véase la ).
====

_La *librería del
sistema* forma parte del sistema operativo y contiene un conjunto de
clases o funciones —generalmente más primitivas que las de la librería
estándar de los lenguajes de programación— que los programas deben
utilizar para acceder a los servicios del sistema operativo_. Es decir,
la librería del sistema constituye la _interfaz de programación de
aplicaciones_ del sistema operativo. Es muy común que esta interfaz esté
implementada para ser usada con programas en lenguaje C, lo que permite
que tanto los programas en C como en {cpp} la puedan utilizar
directamente. Sin embargo con otros lenguajes de programación esto no
suele ser posible, por lo que no queda más remedio que acceder a los
servicios del sistema operativo a través de la librería estándar del
lenguaje en cuestión.

[NOTE]
====
En Microsoft Windows, un programa en C puede usar tanto la función `fopen()` de su librería estándar como llamar directamente a la función `CreateFile()` de la librería del sistema. Con {cpp} ocurriría lo mismo que con C, pero otros lenguajes no tienen esa facilidad para llamar a la librería del sistema directamente. Por ejemplo, un programa en Python no puede llamar directamente a `CreateFile()` sino que debe usar la función `open()` de la librería estandar del lenguaje (véase la , destacado en rojo).

Usar directamente las funciones de la librería del sistema desde programas en C o {cpp} tiene la ventaja de que permite utilizar todas las características del sistema operativo. Por ejemplo, podríamos utilizar opciones adicionales de `CreateFile()`:

[source, c]
----
HANDLE WINAPI CreateFile(
  LPCTSTR lpFileName,           // Nombre del archivo
  DWORD dwDesiredAccess,        // Modo de acceso
  DWORD dwShareMode,            // Modo de compartición
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,   // Permisos
  DWORD dwCreationDisposition,  // Acción si no existe el archivo
  DWORD dwFlagsAndAttributes,   // Atributos del archivo
  HANDLE hTemplateFile          // Archivo plantilla
);
----

que no `fopen()` no posee:

[source, c]
----
FILE* fopen(
  const char *path,             // Nombre del archivo
  const char *mode              // Modo de acceso
);
----

Sin embargo, debemos tener en cuenta que se pierde portabilidad pues `CreateFile()` solo está disponible en Microsoft Window, mientras que `fopen()` viene con la librería estándar de cualquier compilador de C.
====

Algunos de los servicios ofrecidos por la librería del sistema pueden ser implementados en la propia librería, pero en la mayor parte de los casos ésta debe solicitar dichos servicios al núcleo del sistema operativo que es quién supervisa y tiene acceso a los recursos de la máquina.

[NOTE]
====
En los sistemas UNIX o «estilo UNIX» las cosas son un poco más complejas.
El lenguaje C fue diseñado originalmente para implementar sistemas UNIX y por eso la librería estándar de C tiene mucho parecido con la librería del sistema de los sistemas UNIX.
Con el tiempo, al ir añadiendo más funcionaliades, la librería del sistema de los sistemas UNIX de los distintos fabricantes fue divergiendo, haciendo muy complicado desarrollar programas que usaran sus características más avanzadas y que a la vez pudieran usarse en varios de ellos.
Por eso el IEEE desarrollo el estándar POSIX, que define una interfaz de programación de aplicaciones (API) común para todos los UNIX y sistemas estilo UNIX modernos —como es el caso de Linux—.

Por su origen, la API POSIX es un superconjunto de la API de la librería estándar de C y por eso en estos sistemas la librería estándar de C es parte de la librería del sistema, en lugar de ser dos librerías separadas.
Como hemos comentado, otros lenguajes sí necesitan su propia librería estándar, que a su vez utiliza los servicios de la librería del sistema.

Por ejemplo, en {cpp} en Linux el método `open()` de la clase `std::ofstream` de la librería estándar utiliza a su vez la función `open()` de la librería del sistema para abrir o crear un archivo (véase la ).
La función `open()` no es parte del C estándar ni del {cpp} estándar, pero si del estándar POSIX.
Por lo tanto:

* Para crear programas para cualquier sistema operativo para el que tengamos un compilador de nuestro lenguaje, tenemos que limitarnos a usar funciones de la librería estándar de dicho lenguaje. Por ejemplo, `fopen()` en C o `std::ofstream` en {cpp}.

* Para usar `open()` y otras funciones POSIX directamente —desde lenguajes como C o {cpp}— no es suficiente con tener un sistema con un compilador estándar de C, sino que necesitamos un sistema operativo que siga el estándar POSIX, que es mucho más amplio.

En la librería del sistema de los sistemas POSIX los desarrolladores del sistema a veces añaden funciones no incluidas en el estándar, con el objeto de soportar algún tipo de funcionalidad avanzada del sistema:

* Un programa que sólo utilice la API POSIX podrá ejecutarse en cualquier sistema operativo compatible POSIX.

* Mientras que uno que utilice, por ejemplo, alguna funcionalidad adicional no POSIX de Linux, sólo podrá compilarse y ejecutarse en Linux.
====

La librería del sistema, al igual que la estándar y otras librerías utilizadas por el programa, se cargan dentro de la región de memoria asignada al proceso donde se ejecuta el programa que las utiliza.
Por lo tanto, la invocación de sus métodos y funciones se realiza como si fueran cualquier otro método o función del programa.
Sin embargo, el código del núcleo del sistema operativo suele estar en una ubicación
diferente que, desde el punto de vista de los programas, no es conocida y generalmente está protegida frente a accesos indebidos (véase el apartado <<_protección_de_la_memoria>>).
Eso significa que para que la librería del sistema invoque los servicios que necesita hace falta un procedimiento diferente, denominado *llamada al sistema*.

_Las *llamadas al sistema* proporcionan una interfaz con la que los procesos pueden invocar los servicios que el sistema operativo ofrece_.
Estas llamadas habitualmente se hacen mediante instrucciones en lenguaje ensamblador (véase la ) pero generalmente los programas no las utilizan directamente.
En su lugar invocan las funciones de la librería del sistema, que a su vez son las encargadas de hacer las llamadas al sistema necesarias.

En las figuras y se ilustra el papel de todos los elementos comentados con el ejemplo de programas en C, {cpp} y Python que invocan los métodos `fopen()`, `std::ofstream::open()` y `open()` de la librería estándar de estos lenguajes, respectivamente.
En todo los casos, al final se realiza una llamada al sistema que hace que el sistema operativo tome el control, deteniendo la ejecución del proceso que la solicita.
Entonces se realiza la tarea solicitada mediante el funcionamiento coordinado de los diferentes componentes del sistema (véase el apartado <<_componentes_del_sistema>>).

===== Invocación de las llamadas al sistema

Generalmente una
llamada al sistema se invoca mediante una instrucción específica en
lenguaje ensamblador que genera una **excepción**footnote:[Una
_excepción_ es una interrupción generada por software, que puede ser
debida a un error —por ejemplo una división por cero o un acceso no
válido a memoria— o a una llamada al sistema de un proceso para que se
ejecute un servicio del sistema operativo.] —por ejemplo la instrucción
_syscall_ en la — que es capturada por el sistema operativo, deteniendo
la ejecución del proceso que la invocó. Cuando se realiza la llamada es
necesario que el proceso identifique la operación que quiere que se
realice. Esto se suele hacer poniendo un número identificativo de la
llamada en un registro concreto de la CPU. Por ejemplo, el número de la
llamada al sistema `open` del ejemplo de la es 2footnote:[En GNU/Linux
se puede conocer el número correspondiente a cada llamada al sistema
soportada por el núcleo consultado el listado del archivo
`/usr/include/asm/unistd.h`.].

Sin embargo, una llamada al sistema suele requerir más información que
simplemente la identidad de la llamada. Si por ejemplo se quisiera leer
un bloque de datos desde un almacenamiento secundario, al menos se
debería indicar el archivo o dispositivo desde el que se desea realizar
la lectura, así como la dirección y tamaño de la región de la memoria
donde se quiere que los datos sean copiados. En concreto hay tres
métodos para pasar parámetros a una llamada al sistema:

* _En el paso de parámetros *por registros* se cargan los parámetros de
la llamada al sistema en los registros de la CPU antes de realizar la
llamada_. Este método es el más eficiente, pero limita el número de
parámetros al número de registros disponibles en la CPU. Es utilizado,
por ejemplo, en Linux para IA-32footnote:[IA-32 (_Intel Architecture,
32-bit_), conocida en la actualidad de manera genérica como x86 o i386,
es la arquitectura del conjunto de instrucciones de los procesadores
Intel de 32 bits. Concretamente es una extensión de 32 bits,
implementada por primera vez en el Intel 80386, para la arquitectura x86
original de 16 bits.] cuando la llamada al sistema tiene menos de seis
parámetros (véase la ).

* _En el paso de parámetros *por tabla en memoria* se copian los
parámetros de la llamada al sistema en una tabla en memoria_, de manera
que la dirección de dicha tabla debe ser cargada en un registro de la
CPU antes de la llamada al sistema. Evidentemente no limita el número de
parámetros que pueden ser pasados a una llamada al sistema. Por ejemplo,
es utilizado en Linux IA-32, cuando la llamada al sistema tiene más de
cinco parámetros, y en Microsoft Windows.

* _En el paso de parámetros *por pila* se insertan los parámetros de la
llamada al sistema en la pila del proceso_. En este caso el sistema
operativo es el encargado de extraer los parámetros de la pila durante
la llamada al sistema. Al igual que en el caso anterior tampoco se
limita el número de parámetros que pueden ser pasados. Es utilizando,
por ejemplo, en FreeBSD.

En cualquier caso, sea cual sea el método utilizado, _el sistema
operativo debe comprobar de manera estricta los parámetros pasados en la
llamada al sistema antes de realizar cualquier operación_, puesto que
nunca debe confiar en que los procesos hagan su trabajo correctamente. A
fin de cuentas una de las funciones del sistema operativo es el control
de dichos procesos.

==== Componentes del sistema

Como ya hemos comentado en diversas ocasiones en este tema, el sistema
operativo ofrece una serie de servicios a través del funcionamiento
coordinado de los diferentes componentes que lo forman. A fin de
cuentas, crear un software tan complejo como un sistema operativo no es
sencillo, por ello resulta más práctico dividirlo en piezas más pequeñas
especializadas en aspectos concretos de la gestión del sistema.

===== Gestión de procesos

La gestión de los procesos es un elemento central de todo sistema
operativo ya que el _proceso_ es la unidad de trabajo en cualquier
sistema operativo moderno:

* _Un *proceso* puede ser considerado como un programa en ejecución_,
es decir, cuando las instrucciones del programa son ejecutadas por una
CPU. Un proceso es un entidad activa que necesita recursos —CPU,
memoria, archivos, E/S— que se le asignan cuando es creado o cuando lo
solicita durante la ejecución. Cuando el proceso termina el sistema
operativo reclama de estos recursos aquellos que sean reutilizables.

* Un _**programa** no es un proceso, es una entidad pasiva; como el
contenido de un archivo en disco con las instrucciones que algún día una
CPU ejecutará_. Un programa no puede hacer ningún tipo de trabajo a
menos que sus instrucciones sean ejecutadas por una CPU pero si eso
ocurre, ya no sería un programa sino un proceso.

* La CPU ejecuta las instrucciones de cada proceso una detrás de otra,
de manera que para conocer la siguiente instrucción a ejecutar cada
proceso tiene un contador de programa que se lo indica a la CPU. Por
tanto, aunque dos procesos estén asociados al mismo programa no pueden
ser considerados el mismo proceso, ya que la secuencia de ejecución de
instrucciones puede ser distinta al tener cada uno un contador de
programa independiente.

Por el momento estamos considerando que _proceso_ y _trabajo_ (véase el
apartado <<_mainframe>>) hacen referencia al mismo concepto. Sin
embargo más adelante veremos que el segundo es mucho más general que el
primero puesto que un proceso puede colaborar con otros procesos para
desarrollar un trabajo determinado (véase el apartado
<<_operaciones_sobre_los_procesos>>).

====== Responsabilidades de la gestión de procesos

El sistema operativo es responsable de la siguientes actividades
relacionadas con la gestión de procesos:

* Crear y terminar procesos.
* Suspender y reanudar los procesos.
* Proporcionar mecanismos para la sincronización de procesos.
* Proporcionar mecanismos para la comunicación entre procesos.
* Proporcionar mecanismos para el tratamiento de interbloqueos.

===== Gestión de la memoria principal

La memoria principal es un recurso fundamental para las operaciones de
cualquier sistema operativo moderno. Esto es así porque generalmente es
el único almacenamiento al que la CPU tiene acceso directo, por lo que
para que un programa pueda ser ejecutado debe ser copiado a la memoria
principal. Además sirve de zona de intercambio de datos entre la CPU y
los dispositivos de E/S. Por ejemplo, para que la CPU pueda procesar los
datos de un archivo en disco, éstos primero deben ser transferidos a la
memoria principal.

Para mejorar el aprovechamiento de la CPU y la respuesta al usuario es
necesario tener copiados varios programas en la memoria al mismo tiempo.
Puesto que dichos programas deben compartir la memoria existe
automáticamente la necesidad de que el sistema operativo disponga de un
componente de gestión de la memoria principal.

====== Responsabilidad de la gestión de la memoria

El componente de gestión de la memoria debe asumir las siguientes
responsabilidades:

* Controlar qué partes de la memoria están actualmente en uso y cuáles no.

* Decidir que procesos añadir o extraer de la memoria cuando hay o falta espacio en la misma.

* Asignar y liberar espacio de la memoria principal según sea necesario.

===== Gestión del sistema de archivos

Los ordenadores pueden almacenar información en diferentes tipos de
medios físicos —por ejemplo en discos magnéticos, en CD/DVD-ROM, en
memorias de estado sólido, etc.— cada uno de los cuales tiene
características propias. El acceso a cada tipo medio es controlado por
un dispositivo —por ejemplo el controlador de disco, la unidad de
CD-ROM, etc.— que también tiene características propias. Para
simplificar todo esto el sistema operativo proporciona una visión lógica
uniforme de todos los sistemas de almacenamiento. Es decir, abstrae las
propiedades físicas de los dispositivos de almacenamiento para definir
una unidad de almacenamiento lógico, el _archivo_. _Un *archivo* o
fichero es una colección de información relacionada definida por su
creador_ —por ejemplo programas, imágenes, datos—. Los archivos
normalmente se organizan en directorios para facilitar su uso.

====== Responsabilidades de la gestión del sistema de archivos

El sistema operativo es responsable de la siguientes actividades
relacionadas con la gestión del sistema de archivos:

* Crear y borrar archivos.

* Crear y borrar directorios para organizar los archivos.

* Soportar __primitivas__footnote:[El término primitivas hace referencia a funciones que realizan operaciones muy básicas. Estas operaciones básicas pueden ser combinadas para realizar operaciones más complejas.] para la manipulación de archivos y directorios.

* Mapear en memoria archivos del almacenamiento secundario.

* Copias de seguridad de los archivos en sistemas de almacenamiento estables y seguros.

===== Gestión del sistema de E/S

_El *sistema de E/S* oculta las peculiaridades del hardware al resto
del sistema_. El sistema de E/S consta de:

* Un componente de gestión de memoria con soporte para servicios de
__buffering__footnote:[El buffering o uso de memoria intermedia es una
estrategia para leer datos desde un dispositivo de E/S. La CPU instruye
al dispositivo para que escriba bloques de datos en la memoria de forma
que la operación se realiza mientras la CPU está ocupada procesando los
bloques leídos anteriormente desde el dispositivo. Al escribir en un
dispositivo de E/S el proceso es análogo.], __caching__footnote:[En el
caching el sistema mantiene en la memoria principal una copia de los
datos almacenados en los dispositivos de E/S del sistema como, por
ejemplo, en los discos. Esto mejora la eficiencia del sistema puesto que
el acceso a la memoria principal es más rápido que el acceso a los
dispositivos de E/S. La memoria principal es de tamaño limitado, por lo
que sólo se mantiene copia de los datos utilizados con mayor
frecuencia.] y __spooling__footnote:[El spooling se utiliza en
dispositivos que no admiten el acceso simultaneo de varias aplicaciones
a vez, como es el caso de impresoras y unidades de cinta. Cuando varias
aplicaciones intentan enviar un trabajo a una impresora el sistema
operativo lo intercepta para copiar los datos enviados a un archivo
distinto para cada aplicación. Cuando una aplicación termina de enviar
el trabajo el archivo correspondiente es encolado para su impresión. Así
los archivos son impresos de uno en uno.]. Estos servicios son
habitualmente utilizados por el resto del sistema de E/S.

* _Una interfaz genérica de acceso a los controladores de
dispositivo_. Esta interfaz genérica hace que el acceso de los procesos
a los dispositivos sea a través de una interfaz similar, sin importar
las particularidades de cada dispositivo. Por ejemplo, una
característica de los sistemas UNIX es que cada dispositivo de E/S se
representa como un archivo en el sistema de archivos. Esto permite que
los procesos utilicen para acceder a los dispositivos de E/S las mismas
primitivas que emplean para manipular los archivos.

* _Controladores de dispositivo_ que son quiénes conocen las
peculiaridades específicas del dispositivo para el que ha sido creado.

===== Gestión del almacenamiento secundario

Los programas que se desean ejecutar deben estar en la memoria
principal, o _almacenamiento primario_, pero ésta es demasiado pequeña
para alojar todos los datos y todos los programas del sistema. Además,
incluso aunque pudiera ser así, los datos almacenados en la memoria
principal se perderían en caso de que fallara la alimentación. Por eso
los ordenadores deben disponer de un almacenamiento secundario para
respaldar a la memoria principal. Hoy en día lo más común es utilizar
discos duros para esa tarea.

====== Responsabilidades de la gestión del almacenamiento secundario

El sistema operativo es responsable de la siguientes actividades
relacionadas con la gestión del almacenamiento secundario:

* Gestión del espacio libre.
* Asignación del espacio de almacenamiento.
* Planificación del acceso al disco.

===== Gestión de red

_El componente de red se responsabiliza de la comunicación entre los
procesadores en sistemas interconectados mediante una red de
ordenadores_ —por ejemplo en Internet o la red de área local de una
oficina—.

===== Protección y seguridad

_*Protección* es cualquier mecanismo para controlar el acceso de los
procesos y usuarios a los recursos definidos por el sistema_. Estos son
necesarios cuando un sistema informático tiene múltiples usuarios y
permite la ejecución concurrente de varios procesos, pues así sólo
pueden utilizar los recursos aquellos procesos que hayan obtenido la
autorización del sistema operativo. Además _la *protección*
también permite mejorar la fiabilidad_ al permitir detectar los
elementos del sistema que no operan correctamente. Un recurso
desprotegido no puede defenderse contra el uso —o mal uso— de un usuario
no autorizado o incompetente.

Ejemplos típicos de mecanismos de protección son el hardware de
direccionamiento de memoria, que se utiliza para que los procesos se
ejecuten en su propio espacio de direcciones, y el temporizador, que
garantiza que ningún proceso toma el control de la CPU de manera
indefinida. Además los registros de los dispositivos de E/S suelen estar
protegidos del acceso directo de los usuarios, lo que protege la
integridad de los dispositivos, mientras que en algunos sistemas se
pueden establecer permisos sobre los archivos para garantizar que sólo
los procesos con la debida autorización tienen acceso.

En todo caso, un sistema puede tener la protección adecuada pero estar
expuesto a fallos y permitir accesos inapropiados. Por eso es necesario
disponer de _mecanismos de *seguridad* que se encarguen de defender el
sistema frente a ataques internos y externos_. Eso incluye a virus y
gusanos, ataques de denegación de serviciofootnote:[En los _ataques de
denegación_ de servicio se intentan utilizar todos los recursos de
sistema para evitar que éste pueda dar servició a los usuarios
legítimos.], robo de identidad y uso no autorizado del sistema, entre
muchos otros tipos de ataque.

==== Interfaz de usuario

Aunque cada sistema operativo ofrece servicios diferentes, vamos a
detenernos en uno común e importante para todos los sistemas que han
sido diseñados para que los usuarios interactúen con ellos directamente,
la interfaz de usuario.

Las interfaces de usuario pueden ser de diferentes tipos:

* _Interfaz de línea de comandos o intérprete de comandos_, que
permite que los usuarios introduzcan directamente los comandos que el
sistema operativo debe ejecutar. En algunos sistemas este tipo de
interfaz se incluye dentro del núcleo, pero en la mayor parte —como
MSDOS y UNIX— se trata de un programa especial denominado _shell_ que se
ejecuta cuando un usuario inicia una sesión.

* _Interfaz de proceso por lotes_, en la que los comandos y directivas
para controlar dichos comandos se listan en archivos que posteriormente
pueden ser ejecutados. Este tipo de interfaz es la utilizada en sistemas
no interactivos, como los de procesamiento por lotes y los
multiprogramados. También suele estar disponible en los sistemas de
tiempo compartido, junto con algún otro tipo de interfaz de usuario,
como es el caso de la _shell_ de los sistemas UNIX.

* _Interfaz gráfica de usuario_ o _GUI_ (_Graphical User Interface_)
que permite a los usuarios utilizar un sistema de ventanas y menús
controlable mediante el ratón.

Puesto que la interfaz de usuario puede variar de un sistema a otro, y
de un usuario a otro dentro del mismo sistema, no se suele incluir como
un componente básico del sistema operativo, pero si como un servicio
útil para los usuarios.

A parte de la interfaz de usuario, cualquier sistema operativo moderno
incluye una colección de programas del sistema. El papel de estos
programas del sistema es proporcionar un entorno conveniente para la
ejecución y desarrollo de programas. Entre los programas del sistema se
suelen incluir aplicaciones para manipular archivos y directorios,
programas para obtener información sobre el estado del sistema —como la
fecha y hora o la memoria y el espacio en disco disponible—,
herramientas de desarrollo —como intérpretes, compiladores, enlazadores
y depuradores—, programas de comunicaciones —como clientes de correo
electrónico y navegadores web—, etc.

Además, muchos sistemas operativos disponen de programas que son útiles
para resolver los problemas más comunes de los usuarios. Entre estos
programas se suelen incluir: editores de archivos de texto y
procesadores de texto, hojas de cálculo, sistemas de base de datos,
juegos, etc. Ha esta colección de aplicaciones se la suele conocer con
el término de _utilidades del sistema_ o _programas de aplicación_.

=== Operación del sistema operativo

_Los sistemas operativos modernos pertenecen a un tipo de software que
se dice que está controlado mediante interrupciones_:

* Si no hay ningún proceso que ejecutar ni ningún dispositivo de E/S
pide la atención del sistema, el sistema operativo debe permanecer
inactivo esperado a que algo ocurra.

* Los sucesos que requieren la activación del sistema casi siempre se
indican mediante una interrupción:

    ** Cuando un proceso comente un error —como una división por cero o un acceso a memoria no válido— o un programa solicita un servicio al sistema operativo a través de una llamada al sistema lo que se genera es una *excepción* —que no es más que una interrupción generada por software— que despierta al sistema operativo para que haga lo que sea más conveniente.

    ** Cuando los dispositivos de E/S requieren la atención del sistema operativo —por ejemplo porque se ha completado una transferencia de datos— se genera una interrupción que despierta al sistema operativo.

Dado que el sistema operativo y los procesos de usuarios comparten los
recursos del sistema informático, _necesitamos estar seguros de que un
error que se produzca en un programa sólo afecte al proceso que lo
ejecuta_. Por ejemplo, en los sistemas de tiempo compartido —y en
cualquier otro tipo de sistema operativo donde los programas tengan que
compartir la memoria, como es el caso de los sistema microprogramados—
un programa erróneo puede modificar el código de otro programa, los
datos de otro programa o el propio sistema operativo. Por eso es
necesario establecer mecanismos de protección frente a los errores en
los programas que se ejecutan en el sistema.

==== Operación en modo dual

Para evitar este tipo de problemas es necesario poder distinguir entre
la ejecución de código del sistema operativo y del código de los
programas de usuario. El método que utilizan la mayor parte de los
sistemas operativos consiste en _utilizar algún tipo de soporte en el
hardware que permita diferencia entre varios modos de ejecución y
restringir la utilización de las instrucciones peligrosas
—*instrucciones privilegiadas*— para que sólo puedan ser utilizadas en
el modo en el que se ejecuta el código del sistema operativo_.

Como mínimo son necesarios dos modos de operación diferentes:

* _En el *modo usuario* se ejecuta el código de las tareas de los
usuarios_. Si se hace un intento de ejecutar una instrucción
privilegiada en este modo, el hardware la trata como ilegal y genera una
excepción que es interceptada por el sistema operativo, en lugar de
ejecutar la instrucción.

* _En el *modo privilegiado*_ —también denominado *modo supervisor*,
*modo del sistema* o *modo kernel*— _se ejecuta el código de
las tareas del sistema operativo_. El hardware es el encargado de
garantizar que las instrucciones privilegiadas sólo pueden ser
ejecutadas en este modo.

El modo actual de operación _puede venir indicado por un *bit de modo*
que se añade al hardware de la computadora_, de forma que si por
ejemplo el bit está a 0, el código en ejecución opera en modo
privilegiado mientras que si el bit está a 1, el código en ejecución
opera en modo usuario.

Comúnmente en el grupo de las instrucciones privilegiadas se suelen
incluir:

* _Las instrucción para conmutar al modo usuario_.
* _Las instrucciones de E/S_.
* _Las instrucciones necesarias para la gestión de las
interrupciones_.

A continuación podemos ver el ciclo de vida de la ejecución de
instrucciones en un sistema con modo dual de operación:

1. _Inicialmente, al arrancar la computadora, el hardware se inicia en
el modo privilegiado_ —es decir, con el bit de modo a 0—. En este modo
se carga el sistema operativo e inicia su ejecución.

2. _El sistema operativo debe cambiar al modo usuario —poniendo el bit
de modo a 1— antes de ceder el control a un proceso de usuario_. Esto
ocurre cuando es necesario que un proceso de usuario continúe o inicie
su ejecución (véase el <<_el_asignador>>).

3. _El hardware conmuta a modo privilegiado cuando ocurre una
interrupción o una excepción_ —poniendo el bit de modo a 0— antes de
pasar el control al código del sistema operativo que se encargará de
tratarlas.

Esto último es importante pues, como ya hemos comentado, los sistemas
operativos están controlados mediante interrupciones. Al activarse el
modo privilegiado cada vez que ocurre una interrupción podemos estar
seguros de que las tareas del sistema operativo se ejecutará en modo
privilegiado.

Cuando se dispone de la protección del modo dual el hardware se encarga
de detectar los errores de ejecución y de notificarlo al sistema
operativo mediante excepciones, siendo responsabilidad de este último
realizar un tratamiento adecuado de los mismos. Por lo general, si un
programa falla de alguna forma, como por ejemplo intentando utilizar una
instrucciones ilegal o de acceder a una zona de memoria inválida, el
sistema operativo lo hace terminar de manera anormal.

==== Protección de la memoria

La memoria principal debe acomodar tanto el sistema operativo como a los
diferentes procesos de los usuarios. Por eso la memoria normalmente se
divide en dos partes:

1. __La primera parte sirve para albergar el sistema operativo
residente__footnote:[El termino sistema operativo residente hace
referencias a los componentes del sistema operativo que deben estar
permanentemente en la memoria. Comúnmente dicho conjunto de elementos
componen el núcleo del sistema.]. El sistema operativo puede estar
localizado tanto en la parte baja como en la parte alta de la memoria.
El factor determinante en la elección es la localización del vector de
interrupciones. Puesto que en la mayor parte de las arquitecturas éste
reside en la parte baja de la memoria, normalmente el sistema operativo
también se aloja en la parte baja.

2. _La segunda parte alberga los procesos de usuario_.

Sin embargo en los sistemas operativos modernos los procesos no tienen
acceso libre a toda memoria física con el objeto de proteger a los
procesos en ejecución y al sistema operativo de posibles errores en
cualquiera de ellos:

* _El sistema operativo proporciona a cada proceso una «vista»
privada de la memoria similar a la que tendrían si cada uno de ellos se
estuviera ejecutando en solitario_ (véase la ).

* A esa «vista» que tiene cada proceso de la memoria es a lo que se
denomina *espacio de direcciones virtual* del proceso y _está formado
por el conjunto de direcciones que puede generar la CPU para un proceso
dado_.

* Durante los accesos a la memoria principal en tiempo de ejecución
estas *direcciones virtuales* son convertidas en direcciones físicas
antes de ser enviadas a la memoria principal. Por tanto _las
*direcciones físicas* son las direcciones reales que ve la memoria,_
mientras que _el *espacio de direcciones físico* es el conjunto de
direcciones físicas que corresponden a un espacio de direcciones virtual
dado_.

_La conversión de una dirección virtual en una física la realiza en
tiempo de ejecución un dispositivo hardware denominado MMU
(Memory-Management Unit)_. Las ventajas de este dispositivo desde el
punto de vista de la protección de la memoria son que:

* _Permite el aislamiento de los procesos_, creando para cada uno la
ilusión de que toda la memoria es para él y evitando que un proceso
pueda acceder a la memoria de otros procesos.

* _Permite marcar los modos de acceso autorizados en las diferentes
regiones de la memoria_ —como por ejemplo lectura, escritura y
ejecución— evitando que el código ejecutado en modo usuario tenga acceso
a zonas a las que no debería tenerlo. El acceso a la memoria en un modo
no autorizado se considera una instrucción privilegiada, por lo que ese
tipo de acceso desde el modo usuario siempre genera una excepción.

==== El temporizador

_El *temporizador* se utiliza para poder estar seguros de que el
sistema operativo es capaz de mantener el control de la CPU_, puesto
que lo que no puede ocurrir es que un proceso entre en un bucle infinito
de manera que nunca devuelva el control al sistema operativo.

El temporizador se configura durante el arranque del sistema para
interrumpir a la CPU a intervalos regulares. Así, cuando el temporizador
interrumpe, el control se transfiere automáticamente al sistema
operativo. Entonces este puede: conceder más tiempo al proceso en
ejecución, detenerlo y darle más tiempo de CPU en el futuro o tratar la
interrupción como un error y terminar de manera anormal el programa.
Indudablemente las instrucciones que pueden modificar el contenido del
temporizador son instrucciones privilegiadas.

=== Sistemas operativos por su estructura

Ya hemos discutido anteriormente acerca de los componentes más comunes
en un sistema operativo (véase el <<_componentes_del_sistema>>). En
esta sección comentaremos su organización e interconexión dentro del
núcleo.

==== Estructura sencilla

_Los sistemas con *estructura sencilla* no tienen una estructura bien
definida_. Es decir, los interfaces y niveles de funcionalidad no están
bien separados.

Por ejemplo, en MSDOS los programas de aplicación podían acceder
directamente a la BIOS o al hardware para hace acceder a cualquier
dispositivo (véase la ). Disponiendo de esa libertad un programa erróneo
cualquiera podía corromper el sistema completo. Como el Intel 8086 para
el que fue escrito MSDOS no proporcionaba un modo dual de operación, los
diseñadores del sistema no tuvieron más opción que dejar accesible el
hardware a los programas de usuario.

Otro ejemplo es el de UNIX original, donde se combinaba un montón de
funcionalidad en un mismo nivel, el núcleo (véase la ). Es decir, todo
lo que estaba por encima del hardware y por debajo de las llamadas al
sistema era el núcleo. Este proporciona la planificación de CPU, la
gestión de la memoria, el soporte de los sistemas de archivos y muchas
otras funcionalidades del sistema operativo. En general se trata de una
enorme cantidad de funcionalidad que es difícil de implementar y
mantener en un mismo nivel. _Esa concentración de funcionalidad en el
núcleo define a los sistemas de estructura sencilla como sistemas de
núcleo *monolítico*_.

Tanto MSDOS como UNIX eran originalmente sistemas pequeños y simples,
limitados por la funcionalidades del hardware de su época, que fueron
creciendo más allá de las previsiones originales. Lo cierto es que con
mejor soporte del hardware se puede dividir el sistema operativo en
piezas más pequeñas y apropiadas que las del MSDOS y UNIX original.

==== Estructura en capas

_Un método para dividir el sistema operativo en piezas más pequeñas,
con el fin de hacerlo más modular, es partirlo en capas_. Las capas se
seleccionan de manera que cada una use sólo funciones y servicios de las
capas inferiores y de servicios sólo a las capas superiores. Cada capa
no tiene que saber como se implementan las funciones que utiliza de las
capas inferiores, sólo debe conocer qué es lo que hacen y como utilizar.
Por lo tanto cada capa tiene la responsabilidad de ocultar la existencia
de estructuras de datos, operaciones y hardware a las capas de nivel
superior. Este tipo de sistemas son los que se denominan con
*estructura en capas*.

Los sistemas con estructura en capas siguen concentrado la mayor parte
de la funcionalidad en el núcleo, por lo que _también son sistemas
**monolíticos**_ aunque el núcleo es más modular. Ejemplos de este tipo de
sistemas operativos son el IBM OS/2 y Microsoft Windows (véase la ).

Sin embargo esta forma de dividir los componentes del sistema operativo
no está libre de inconvenientes:

* _La mayor dificultad con los sistemas con estructura en capas es
definirlas_. Esto debe ser planificado cuidadosamente debido a la
restricción, comentada anteriormente, de que un capa sólo puede utilizar
los servicios de las capas inferiores. Por ejemplo, el planificador de
CPU suele tener información de los procesos que están en la memoria y
parte de esa información puede ser intercambiada con el disco para
aumentar la memoria principal disponible. Este planteamiento nos lleva a
pensar que la gestión del almacenamiento secundario debe ir en una capa
inferior a la del planificador de la CPU. Sin embargo el planificador
debe replanificar la CPU cuando el proceso que actualmente la ocupa
solicita alguna operación de E/S, por lo que la gestión del
almacenamiento secundario debe estar encima del planificador de la CPU
para que le pueda decir que replanifique. _Al final la solución de
compromiso es tender hacia sistemas con pocas capas donde cada una tiene
mucha funcionalidad_.

* _Esta estrategia es sin duda mucho menos eficiente que la de los
sistemas de estructura sencilla_. En cada capa los parámetros son
modificados y los datos necesarios deben de ser transferidos, por lo que
cada una añade cierto nivel de sobrecarga al funcionamiento del sistema.

==== Microkernel

_Los sistemas *microkernel* eliminan todos los componentes no
esenciales del núcleo y los implementa como programas de nivel de
usuario_. Aunque hay poco consenso, en general un núcleo microkernel
proporciona funciones mínimas de gestión de procesos y memoria, junto a
algún mecanismo de comunicación. En estos sistemas la función principal
del núcleo es precisamente proporcionar dicho mecanismo de comunicación
entre el programa cliente y los diversos servicios del sistema.
Generalmente esta comunicación se implementa mediante paso de mensajes
(véase el <<_procesos_cooperativos>>).

Entre los beneficios de estos sistemas operativos se incluyen:

* _Facilidad a la hora de añadir nuevas funcionalidades_. Los nuevos
servicios son añadidos como aplicaciones de nivel de usuario, por lo que
no es necesario hacer modificaciones en el núcleo.

* _Facilidad a la hora de portar el sistema a otras plataformas_.

* _Más seguridad y fiabilidad_. Puesto que los servicios se ejecutan a
nivel de usuario en procesos separados, un servicio que falla no puede
afectar a otros ni puede ser utilizado para ganar acceso a otros
servicios o al núcleo.

_El mayor inconveniente es su pobre rendimiento causado por la
sobrecarga que añade el mecanismo de comunicación_. Por ejemplo
Microsoft Windows NT nació con una estructura de microkernel en capas
donde una parte importante de los servicios eran proporcionados por unos
procesos de usuario llamados subsistemas. Además el sistema operativo
podía mostrar diferentes personalidades o _entornos operativos_ —OS/2,
POSIX y DOS— a través del uso de subsistemas ambientales, que también se
ejecutaban como procesos de usuario. Las aplicaciones de Microsoft
Windows NT se comunicaban con estos subsistemas utilizando una forma de
IPC (véase el <<_microkernel>>) denominada LPC (_Local
Procedure Call_), una forma local y optimizada de RPCfootnote:[La RPC
(_Remote Procedure Call_) es una mecanismo de llamada a procedimiento
diseñado para ser utilizado entre sistemas conectados por redes de
ordenadores, permitiendo que un proceso cliente llame a un procedimiento
en un proceso servidor, aunque ambos estén en equipos diferentes, y
ocultado los detalles de la comunicación que permiten que la llamada
tenga lugar.]. Con esta estructura la pérdida de rendimiento respecto a
Microsoft Windows 95 era tan importante que los diseñadores se vieron
obligados a mover más servicios al espacio del núcleo. En la actualidad
Microsoft Windows XP (véase la ) —que es un heredero directo de
Microsoft Windows NT— tiene una arquitectura más monolítica que
microkernelfootnote:[A las 280 llamadas al sistema de Microsoft Windows
XP —algo menos de 200 en Microsoft Windows NT 3.51— se deben sumar las
más de 650 del subsistema gráfico, alojado en el núcleo desde Microsoft
Windows NT 4.0.] ya que aunque muchos servicios siguen siendo
proporcionados por procesos de usuario, esto sólo ocurre con aquellos
donde el rendimiento no es un factor crítico.

Sin embargo varios sistemas operativos siguen utilizando núcleos
microkernel, como Tru64 UNIX y GNU/Hurd (véase la ). Ambos proporcionan
una interfaz UNIX implementada sobre un microkernel Mach. Otro ejemplo
es QNX, un sistema operativo de tiempo real con una gran aceptación que
basa en la estructura de microkernel su estabilidad como sistema para
tareas críticas. Además siguen existiendo algunos proyectos de
investigación dirigidos a resolver los problemas de rendimiento
asociados a los núcleos microkernel.

==== Estructura modular

Los sistemas de *estructura modular* tienen divido el núcleo en módulos,
cada uno de los cuales implementa funciones y servicios concretos, a
imagen y semejanza de las técnicas de programación orientada a objetos.
Quizás por eso sea la mejor metodología actual para diseñar sistemas
operativos. Además _se parecen a los sistemas con estructura en capas
en que cada módulo del núcleo tiene definidos interfaces protegidas,
pero a diferencia de estos todos los módulos pueden llamar a cualquier
otro módulo_.

Estos núcleos suelen disponer un pequeño conjunto de componentes
fundamentales que se cargan durante el arranque, aunque también pueden
enlazar dinámicamente servicios adicionales tanto durante la
inicialización del sistema como o en tiempo de ejecución. En este
aspecto se asemejan a los núcleos microkernel, ya que el módulo
principal sólo tiene funciones básicas, aunque es mucho más eficiente al
no necesitar un mecanismo de paso de mensajes, puesto que los
componentes se cargan directamente en la memoria destinada al núcleo.
Por lo tanto también _deben ser considerados como sistemas
**monolíticos**_.

Este tipo de estructura es la utilizada en los UNIX modernos, como
Oracle/Sun Microsystems Solaris, Linux (véase la ) y macOS.
