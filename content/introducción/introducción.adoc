= Introducción
ifndef::sectiondir[:sectiondir: .]
:imagesdir: {sectiondir}/images
include::../../config/attributes.adoc[]

Comenzaremos viendo cuáles son las funciones comunes a todos los sistemas operativos y qué tipos de sistemas operativos hay.
También recorreremos brevemente la evolución de los sistemas operativos a lo largo de la historia.
Es más sencillo entender lo que hacen los sistemas operativos actuales si comprendemos lo que hacían los sistemas más sencillos que se utilizaban en el pasado.

== ¿Qué es un sistema operativo?

En general no existe una definición universal de lo qué es un *((sistema operativo))*, aunque si muchas propuestas de diferentes autores:

* Hay quién considera que simplemente es una cuestión del mercado: «lo que nos venden cuando llegamos a una tienda y pedimos un un sistema operativo».
+
En realidad esta definición no es muy precisa puesto que las características incluidas pueden variar enormemente de un sistema a otro.
Por ejemplo, algunos sistemas operativos apenas alcanzan el megabyte de espacio, careciendo incluso de las aplicaciones más básicas, mientras que otros ocupan gigabytes de espacio, incluyen una interfaz gráfica basada en ventanas y las aplicaciones más comunes que cualquier usuario puede necesitar.
+
[NOTE]
====
Aunque pueda parecer lo contrario, la cuestión de qué componentes son parte o no de un sistema operativo no es trivial. Por ejemplo, Microsoft y el Departamento de Justicia de los Estados Unidos se enfrentaron en 1998 por la inclusión del navegador Internet Explorer como parte del sistema operativo Microsoft Windows.

Microsoft afirmaba que ambos productos eran realmente uno solo y que su unión fue el resultado de un proceso de innovación.
Mientras tanto la otra parte alegaba que el navegador era un producto distinto y separado, que no formaba parte del sistema operativo y que todo el asunto restringía la libre competencia en el mercado de los navegadores.

Seguramente en 1998 los argumentos del Departamento de Justicia de los Estados Unidos tenían mucho sentido ¿pero qué ocurriría si se planteara este mismo asunto en la actualidad?.
¿Concibes que tu móvil o tu ordenador no trajeran de serie un navegador?

Para más información, véase https://es.wikipedia.org/wiki/Caso_Estados_Unidos_contra_Microsoft[«Caso Estados Unidos contra Microsoft -- Wikipedia»].
====

* Una definición mucho más común es que el sistema operativo es «aquel programa que se ejecuta continuamente en el ordenador» —lo que denominamos comúnmente como _**((kernel))**_ o *((núcleo))* del sistema— siendo todo lo demás programas del sistema y aplicaciones.
+
Sin embargo, en algunos casos ésta definición excluye como parte del sistema operativo algunos servicios que intuitivamente solemos considerar dentro del mismo.
Por ejemplo, si aplicamos esta definición a los sistemas operativos de estructura microkernel, no podríamos decir que servicios básicos como la comunicación en red, los sistemas de archivos y la gestión de la memoria son parte del sistema operativo.
+
[NOTE]
====
Como veremos en el <<_microkernel>>, en los sistemas operativos _microkernel_ la funcionalidad implementada en el núcleo del sistema es la mínima necesaria.
Por lo tanto, según la definición anterior, muchos de los componentes y servicios básicos que damos por supuestos a un sistema operativo no formarían parte del mismo en ese tipo de sistemas.
====

== Funciones del sistema operativo

Por lo que hemos visto hasta ahora, parece evidente que no es sencillo definir lo que «es» un sistema operativo.
Sin embargo, es posible que tengamos más suerte definiéndolo a través de lo que «hace».
Es decir, describiendo sus funciones dentro de un sistema informático cualquiera.

[[componentes_sistema_informático]]
.Vista abstracta de los componentes de un sistema informático.
image::componentes_sistema_informático.svg[]

Un *((sistema informático))* puede ser dividido, _grosso modo_, en cuatro componentes: el hardware, los usuarios, los programas de aplicación y el sistema operativo (véase la <<componentes_sistema_informático>>):

* *Programas de aplicación*. El objetivo fundamental de cualquier sistema informático es ejecutar programas para resolver los problemas informáticos de los usuarios.
Con ese objetivo se construye su hardware y se desarrollan los programas de aplicación —procesadores de textos, hojas de cálculo, compiladores, navegadores de Internet, etc.— que usan los usuarios para resolver sus problemas.

* **Hardware**. El hardware —la CPU, la memoria, los dispositivos de entrada salida, etc.— proporcionan los recursos computaciones del sistema informático.
Los programas de aplicación necesitan usar estos recursos computaciones para resolver los problemas informáticos de los usuarios.

* *Sistema operativo*. En un sistema informático las aplicaciones necesitan realizar operaciones comunes, como acceder a los dispositivos de E/S o reservar porciones de la memoria.
En lugar de que cada aplicación intente hacerlo por su cuenta, es mucho más sencillo que estas operaciones comunes estén centralizadas en el sistema operativo. 

Por lo tanto, el sistema operativo controla, coordina el acceso y asigna los recursos computaciones del hardware a los distintos programas de aplicación.

En realidad esta es solo una de las dos perspectivas desde las que se pueden analizar las funciones del sistema operativo.
Es la denominada como: *perspectiva del sistema informático*, mientras que la otra es la *perspectiva del usuario*.

=== Perspectiva del sistema informático

Un sistema informático tiene múltiples recursos hardware, como son: tiempo de CPU, espacio de memoria, espacio de almacenamiento de archivos, dispositivos de E/S, etc.
También tiene recursos software ofrecidos por algunos programas que se ejecutan en el sistema, como son: servicios de red, servicios de impresión, seguridad, etc.—.
Estos recursos los necesitan los programas de aplicación para resolver los problemas informáticos de los usuarios.

Dentro del sistema informático, el sistema operativo es el programa más íntimamente relacionado con el hardware y su función es gestionar los recursos hardware y software disponibles, asignarlos a los diferentes programas, resolver los conflictos en las peticiones y hacer que el sistema opere eficientemente para resolver los problemas de los usuarios.

Además, el sistema operativo es el programa encargado del control de la ejecución de los programas de los usuarios, por lo que tiene la tarea de prevenir errores y el uso inadecuado del ordenador.

====
En resumen, desde la perspectiva del sistema informático, las funciones del *((sistema operativo))* son:

* Gestionar los recursos computaciones del sistema informático.

* Controlar la ejecución de los programas de usuario y el acceso a los dispositivos de E/S.

Un *sistema operativo*:

* No hace trabajo directamente útil para los usuarios.

* Pero proporciona un entorno adecuado para que los programas de aplicación lo hagan.

Los sistemas operativos existen porque es más sencillo crear sistemas informáticos útiles para los usuarios con ellos que sin ellos.
====

=== Perspectiva del usuario

Si intentamos definir las funciones del sistema operativo desde nuestra experiencia como usuarios, seguramente haríamos referencia a la interfaz que nos proporciona para utilizar el sistema informático.
Sin embargo, debemos tener en cuenta que la interfaz varía con el tipo de sistema, por lo que definir las funciones del sistema operativo desde la perspectiva del usuario es mucho más difícil.

Por ejemplo, los usuarios que se sientan frente a un sistema de escritorio disponen de: monitor, teclado, ratón y una unidad central.
Estos sistemas se diseñan buscando la máxima productividad en equipos donde un usuario monopoliza todos los recursos; por lo que el sistema operativo se diseña considerando fundamentalmente la facilidad de uso, poniendo algo de atención en el rendimiento y nada en el aprovechamiento de los recursos.

Esto difiere mucho de otro tipo de sistema informático dónde múltiples usuarios se sientan frente a terminales conectadas a un gran ordenador central.
Así todos los usuarios comparten los recursos del sistema informático y pueden intercambiar información entre sí.
En este tipo de sistemas el sistema operativo maximiza el aprovechamiento de los recursos con el objeto de garantizar que toda la CPU, memoria y E/S son empleadas de forma eficiente y que ningún usuario utiliza más de lo que le corresponde.
Obviamente, en este tipo de sistemas la facilidad de uso está en un segundo plano.

Otros sistemas operativos se diseñan para sistemas informáticos que tienen poca o ninguna interacción con los usuarios.
Es, por ejemplo, el caso de los sistema empotrados de los electrodomésticos.

Todos estos tipos de sistemas tienen interfaces muy diferentes, lo que dificulta obtener una definición única de sistema operativo desde la perspectiva del usuario.

En los tres casos los objetivos con los que se diseña el sistema operativo son opuestos, por lo que seguramente sea diferente «lo que tiene que hacer» cada sistema operativo para alcanzarlos.
Sin embargo, en los tres casos el sistema operativo es el responsable de la gestión de los recursos computacionales y del control de los programas, funciones que definimos anteriormente desde la perspectiva del sistema informático y que no cambian de un tipo de sistema a otro.

== Tipos de sistemas operativos

=== Mainframe

Los *ordenadores centrales* o _**((mainframes))**_ fueron los primeros computadores utilizados en muchas aplicaciones comerciales y científicas.
Se caracterizan no tanto por la potencia de su CPU como por su: gran capacidad de memoria, gran capacidad de almacenamiento secundario, gran cantidad de dispositivos de E/S y rapidez de estos y alta fiabilidad.

Los _mainframes_ pueden funcionar durante años sin problemas ni interrupciones y las reparaciones se realizan sin detener su funcionamiento.

[NOTE]
====
La mayor diferencia entre los superordenadores y los _mainframes_ está en que los primeros se centran en resolver problemas limitados por la velocidad de cálculo —lo cual requiere miles de CPU de alto rendimiento— mientras que los segundos se centran en la fiabilidad y en problemas limitados por la E/S —por lo que los _mainframes_ suelen tener «solo» entre una y varias docenas de CPU—.

Para más información sobre los _mainframes_, véase http://es.wikipedia.org/wiki/Ordenador_central[«Ordenador central -- Wikipedia»].
====

Los _mainframes_ aparecieron a finales de la década de los 50 del siglo pasado y han seguido evolucionando hasta la actualidad, por lo que dentro de este tipo de sistemas nos encontramos con varios categorías.

==== Sistemas de procesamiento por lotes
(((sistema, procesamiento por lotes)))
(((sistema, batch)))

Los primeros _mainframe_ eran enormes máquinas operadas desde una consola y conectados a lectores de tarjetas perforadas, dispositivos de cinta e impresoras.

[NOTE]
====
Para imágenes y más información sobre las tarjetas perforadas, véase https://en.wikipedia.org/wiki/Computer_programming_in_the_punched_card_era[«Computer programming in the punched card era -- Wikipedia»].
====

El trabajo era preparado por cada programador —normalmente en tarjetas perforadas— y entregado al operador del sistema, que era quién tenían acceso al sistema y tenía la responsabilidad de ejecutar los programas y devolver los resultados al programador correspondiente.

No había sistema operativo y el operador debía cargar y ejecutar cada programa de uno en uno.

[[consola_ibm_705]]
.Operadora en la consola de un mainframe IBM 705 -- Fuente: link:++https://www.ibm.com/ibm/history/ibm100/images/icp/Y444110I58591Z46/us__en_us__ibm100__700_series__705__620x350.jpg++[IBM]
image::consola_ibm_705.jpg[]

Estos sistemas se convirtieron en *sistemas de procesamiento por lotes* o *sistemas en _batch_* cuando se comenzó a utilizar un pequeño programa —llamado *monitor del sistema*— cuya función era cargar y ejecutar sin interrupción un conjunto —o lote— de programas.

Para preparar los lotes, por lo general, el operador cargaba previamente en cinta magnética el conjunto de programas a partir de las tarjetas perforadas proporcionadas por los programadores.
Para ello se utilizaba un lector de tarjetas autónomo, independiente del _mainframe_.

// TODO: Cambiar el dibujo a "Monitor del sistema (sistema operativo)"
[[sistemas_procesamiento_lotes]]
.Organización de la memoria en los sistemas de procesamiento por lotes.
image::sistemas_procesamiento_lotes.svg[]

====
El *((monitor)) del sistema* es un predecesor de los sistemas operativos y tenía las siguientes características:

* Permanecía cargado durante todo el tiempo en la memoria del sistema (véase la <<sistemas_procesamiento_lotes>>).

* Su única tarea era cargar y transferir automáticamente la ejecución de un programa al siguiente cuando el anterior terminaba.

* El mayor inconveniente de éste tipo de sistemas era que la CPU permanecía mucho tiempo desocupada porque era —y sigue siendo— varios ordenes de magnitud más rápida que los dispositivos de E/S.
====

Cualquier programa necesita realizar operaciones de E/S para obtener los datos requeridos para sus cálculos —guardados en tarjetas perforadas y unidades de cinta o, si hablamos de hoy en día, en discos duros y memorias USB—.
También necesita hacer operaciones de E/S para guardar o imprimir los resultados de esos cálculos.

Si solo se puede ejecutar un programa la vez, cuando el programa solicita una operación de E/S, la CPU queda a la espera de que esta termine para continuar con la ejecución del programa, por lo que se pierde tiempo de CPU en no hacer nada.
Este desaprovechamiento de la CPU es peor cuanto más rápida es la CPU respecto a los dispositivos de E/S.

==== Sistemas multiprogramados
(((sistema, multiprogramado)))

La solución al inconveniente de los sistemas de procesamiento por lotes con la E/S fue que los programas no accedieran directamente al dispositivo de E/S, sino que, en su lugar, solicitaran la operación al *monitor del sistema* para que este la solicitara al hardware.
Así el sistema operativo —como podemos comenzar a llamarlo— tiene la oportunidad de sustituir el programa en la CPU por otro, mientras la operación de E/S se completa.

Además, con la aparición de la tecnología de los discos magnéticos en la década de los 60 del siglo pasado, los trabajos de los programadores comenzaron a ser almacenados en discos desde eran escogidos por el sistema operativo para su ejecución.

A estos sistemas se los llamó *multiprogramados*.

[[sistemas_multiprogramados]]
.Organización de la memoria en los sistemas multiprogramados.
image::sistemas_multiprogramados.svg[]
// TODO: Hacer un dibujo más elaborado con cola de entrada

====
En los *sistemas multiprogramados* la ejecución de los trabajos funcionaba de la siguiente manera:

. En el disco magnético se almacenaba una cola donde se iban colocando todos los trabajos que tenían que ser ejecutados.

. El sistema operativo cargaba varios trabajos en memoria del conjunto de trabajos en la cola en el disco magnético (véase la <<sistemas_multiprogramados>>).

. El sistema operativo cede la CPU a uno de los trabajos en memoria.

. Cuando el trabajo en la CPU requería usar la E/S se lo pedía al sistema operativo.
En lugar de mantener a la CPU ocupada inútilmente, el sistema operativo programaba la operación de E/S pero escogía otro trabajo de entre los que estaban en memoria y lo ejecutaba en la CPU.
+
Cuando la operación de E/S del anterior trabajo terminaba, el programa que ocupaba la CPU no era interrumpido, sino que debía esperar a una nueva oportunidad de ser escogido para ejecutarse en la CPU.

. Cuando un programa en la CPU terminaba, sus recursos se liberaban, dejando memoria libre.
Por lo tanto, el sistema operativo escogía un nuevo trabajo de la cola de trabajos en el disco magnético y lo cargaba en la memoria.

Todo este proceso se repetía mientras hubiera trabajos que ejecutar en la cola de trabajos en el disco.
====

Para operar de la forma descrita es necesario que el sistema operativo realice tres tareas esenciales:

* La *planificación de trabajos*, cuya responsabilidad es seleccionar el siguiente trabajo que será cargado en la memoria principal para mantenerla llena.

* La *planificación de la CPU*, cuya responsabilidad es elegir el siguiente trabajo que será ejecutado en la CPU, de entre los disponibles en la memoria principal.

* La *gestión de la memoria*, cuya responsabilidad es repartir la memoria principal entre los trabajos alojados en la misma.

Un ejemplo de este tipo de sistemas operativos es el IBM OS/360, que fue lanzado en 1966 para utilizarlo en los _mainframes_ IBM System/360 (véase el <<_historia_segunda_generación>>).

==== Sistemas de tiempo compartido
(((sistema, tiempo compartido)))

Los sistemas multiprogramados ofrecían un uso más eficiente de la CPU pero no eran capaces de proporcionar interacción directa con los usuarios.
Los programadores seguían teniendo que entregar los trabajos al operador y esperar a que éste les devolviera los resultados.

Los *sistemas de tiempo compartido* se desarrollaron tras observar que al dar acceso a un grupo de usuarios se podía conseguir un uso más eficiente del sistema, en comparación a cuando solo podía ser utilizado por un usuario a la vez.
Esto es debido a que, generalmente, un usuario introduce información de forma continua para luego detenerse durante largos periodos de tiempo, mientras que en un grupo de usuarios las pausas de uno de ellos se puede llenar con la actividad de los otros.

====
Los *sistemas de tiempo compartido* se caracterizaban por:

* Tener *terminales*, es decir, hardware especializado en hacer de interfaz directa entre los usuarios y el sistema.
A través de estas terminales los usuarios podían dar órdenes al sistema e interactuar con sus trabajos.
Podían haber múltiples usuarios al mismo tiempo pero cada uno solo podía tener un trabajo en ejecución a la vez.

* Usar la *multiprogramación* para tener varios trabajos en la memoria principal al mismo tiempo e intercambiar el trabajo en la CPU cuando este solicitaba una operación de E/S, como ya se venía haciendo en los *sistemas multiprogramados* para hacer un uso más eficiente de la CPU.

* Repartir el tiempo de CPU entre usuarios.
El sistema operativo asignaba un tiempo de CPU a cada usuario —denominado *ventana de tiempo* o *((cuanto))* de CPU—.
Cuando este tiempo se agotaba, el sistema intercambiaba el trabajo en la CPU por el de otro usuario en el sistema.
La ventana de tiempo era extremadamente pequeña, dando a cada usuario la impresión de que su trabajo nunca se detenía, como si dispusiera de la CPU en exclusiva.

Los sistemas que, como los de tiempo compartido, pueden ser utilizados por varios usuarios simultáneamente se denominan sistemas *((multiusuario))* (((sistema, multiusuario))).
====

[NOTE]
====
En los primeros sistemas se usaban *((terminal))es* electro-mecánicos con un teclado y una impresora, como el https://en.wikipedia.org/wiki/Teletype_Model_33[Teletype Model 3] (1963).
Posteriormente llegaron los terminales electrónicos, que usaban un monitor en lugar de una impresora, como el https://es.wikipedia.org/wiki/IBM_3270[IBM 3270].
En cualquier caso solo disponían del hardware necesario para realizar la tarea de conectar a los usuarios con el ordenador central.

Estos terminales no deben confundirse con las terminales por software que traen algunos sistemas operativos modernos.
Las terminales por software o _terminales virtuales_ se programan para emular las especificaciones de alguna versión de esas terminales físicas antiguas que hemos comentado.
====

Los sistemas de tiempo compartido significaron un salto importante en complejidad por diversas razones:

* Como varios trabajos están en la memoria principal al mismo tiempo, el sistema operativo requiere mecanismos de *gestión de la memoria* y *protección*.

* Para tener un tiempo de respuesta razonable, los trabajos deben estar cargados en la memoria principal.
Para que quepan más trabajos de los usuarios en la memoria, el sistema operativo debe utilizar técnicas de *memoria virtual* para ejecutar trabajos que no están completamente cargados en la memoria principal.

* Como la CPU debe ser compartida entre todos los trabajos, el sistema operativo necesita mecanismos de *planificación de la CPU*.

* Como varios trabajos pueden tener la necesidad de cooperar y que su ejecución siga cierto orden, el sistema operativo debe proporcionar mecanismos de *sincronización* y *comunicación*.

* Como el sistema debe disponer de un **sistema de archivos** para repartir el espacio en disco y facilitar a los usuarios el acceso y gestión de sus datos, el sistema operativo necesita un componente de *gestión de discos*.

Las primeras versiones de UNIX —lanzado por primera vez en 1970— el sistema operativo VMS —desarrollado en 1978— para los VAX de Digital Equipment Corportation y el IBM OS/400 —introducido en 1988— utilizado en los minicomputadoras AS/400, son algunos ejemplos de sistemas operativos de tiempo compartido (véase el <<_historia_tercera_generación>>).

[NOTE]
====
Estrictamente hablando, el término *sistemas de tiempo compartido* hace referencia a estos _mainframes_ desarrollados a partir de principios de la década de 1970.
Así que no es común utilizarlo con _mainframe_ modernos.

Los _mainframe_ modernos permiten a un mismo usuario ejecutar varios trabajos al mismo tiempo, repartiendo el tiempo de CPU entre todos los trabajo en el sistema y no solo entre los usuarios.
Y lo mismo ocurre en la mayor parte de los sistemas operativos de propósito general actuales —utilizados en ordenadores de escritorio, servidores, portátiles y dispositivos móviles— que con el tiempo han copiado muchas características de los *sistemas de tiempo compartido*.
Por eso el termino actuales *sistema multitarea*, que es mucho más general.

La *((multitarea))* (((sistema, multitarea))) es un método para tener varios procesos en memoria y ejecutarlos «al mismo tiempo».
Generalmente requiere de técnicas de multiprogramación, como las empleadas por los antiguos *sistemas multiprogramados*, y de reparto del tiempo de CPU, como ocurre en los antiguos *sistemas de tiempo compartido*.
Por eso se puede decir que esos dos tipos de sistemas _mainframe_ eran *sistemas multitarea*.
Al igual que lo son los _mainframe_ modernos y muchos sistemas operativos actuales de escritorio y de dispositivos móviles.
====

=== Sistemas de escritorio
(((sistema, escritorio)))

En la década de los 70 del siglo pasado también aparecieron las primeras CPU en microprocesadores y con estas llegaron las *microcomputadoras* o *microordenadores*.
Las primeras *((microcomputadora)s* no incluían teclado ni monitor y se programaban usando interruptores y ledes ubicados en el frontal de la unidad.
Pero entorno a 1977 apareció la segunda generación de *microcomputadoras*, que si incluía estos periféricos de E/S, por lo que eran más fáciles de usar que sus predecesores.
Entonces comenzaron a recibir el nombre de _ordenadores domésticos_ y de su mano llegaron los primeros *sistemas operativos de escritorio*.

[[ordenadores_domésticos_1977]]
.Los tres ordenadores que la revista Byte denominó como la "Trinidad de 1977" de la computación doméstica: el https://es.wikipedia.org/wiki/Commodore_PET[Commodore PET 2001], el https://es.wikipedia.org/wiki/Apple_II[Apple II] y el https://es.wikipedia.org/wiki/TRS-80[TRS-80 Model I] -- Fuente: https://commons.wikimedia.org/wiki/File:Trinity77.jpg[Wikipedia]
image::ordenadores_domésticos_1977.jpg[]

Los _mainframes_ y las minicomputadoras de la época siguieron siendo los ordenadores corporativos por excelencia, ya que eran mucho más grandes y potentes, y también costosos.

[NOTE]
====
El término en desuso *((minicomputadora))* o *((miniordenador)* hace referencia a máquinas multiusuario de rango medio, entre los _mainframes_ y los ordenadores domésticos.
====

Los primeros *sistemas operativos de escritorio* eran muy básicos.
Por ejemplo, en un sistema diseñado para ser utilizado por un único usuario no tiene sentido implementar un sistema de archivos con permisos.
Así que los primeros sistemas operativos de escritorio carecían de esta característica que, sin embargo, ya existía en los sistemas de tiempo compartido de la época.
De la misma manera, carecían de otros mecanismos de protección y no eran ni multiusuario ni multitarea.

Pese a estas diferencias, los *sistemas operativos de escritorio* se han beneficiado del desarrollo de los sistemas operativos para _mainframes_.
Los sistemas de escritorio actuales son *multiusuario* y *multitarea*; incluyen sistemas de archivos con permisos, autenticación y mecanismos de protección de la memoria —como medidas para proteger los datos de los usuarios— y han incorporado muchas otras características de los sistemas operativos para _mainframe_.

====
Pese a que con el tiempo los sistemas de escritorio han ido adquiriendo características desarrolladas en los _mainframe_, no debemos olvidar que ambos tipos de sistemas se siguen diseñando con objetivos diferentes.
Mientras que en los _mainframe_ se persigue maximizar la fiabilidad y utilización eficiente de los recursos, en los sistemas de escritorio se maximiza la facilidad de uso y el tiempo de respuesta al usuario, poniendo algo de atención al rendimiento.
====

[NOTE]
====
El *tiempo de respuesta* al usuario se puede considerar como el intervalo de tiempo entre un comando de un usuario —por ejemplo un clic— y la respuesta del sistema a dicho comando.
En ocasiones este tiempo se minimiza a costa de un uso menos eficiente de los recursos del sistema, por lo que no es un objetivo deseable para diseñar un _mainframe_.
Para más información, véase el <<_criterios_de_planificación>>.
====

====
Los *sistemas operativos de escritorio* modernos ya nos son «solo de escritorio» ni se ejecutan únicamente en ordenadores domésticos.
Se utilizan en un altísimo porcentaje en servidores, superordenadores y hasta en dispositivos móviles.
Por eso, en la actualidad, el término *sistema operativo de propósito general* (((sistema operativo, propósito general))) es mucho más adecuado.
====

Son muchos los ejemplos de sistemas operativos en esta categoría. Van desde CP/M —lanzado en 1977— hasta los actuales GNU/Linux, Microsoft Windows y Apple macOS, pasando por MS-DOS, IBM OS/2 y todas las versiones anteriores de Microsoft Windows (véase el <<_historia_cuarta_generación>>).

=== Sistemas de mano
(((sistema, mano)))

Con el nombre genérico de **sistemas de mano** hacemos referencia a los _tablets_, lectores de libros electrónicos y teléfonos móviles.
Los desarrolladores de aplicaciones y sistemas de mano deben enfrentarse a diversos desafíos, originados por el tamaño limitado de los dispositivos y la alimentación mediante el uso de baterías.
Debido a esas limitaciones muchos sistemas de mano tienen poca cantidad de memoria, procesadores lentos —en comparación con sus equivalentes de escritorio— y pantallas más pequeñas.

En el diseño del sistema operativo suele primar la facilidad de uso y buscar un buen equilibrio entre rendimiento y tiempo de vida de la batería.

=== Sistemas multiprocesador
(((sistema, multiprocesador)))

Un *sistema multiprocesador* es aquel ordenador hay procesadores interconectados que comparten el bus del sistema, el reloj y, en ocasiones la memoria, y los periféricos.

Hace años esto solo se daban en sistemas con varias CPU, lo que era relativamente común en servidores y sistemas de alto rendimiento para trabajos técnicos o científicos.
Sin embargo, en la actualidad cualquier dispositivo digital u ordenador doméstico puede tener una CPU con múltiples núcleo, lo que los convierte en sistemas multiprocesador.

Las principales de ventajas de estos sistemas son:

* *Aumentan la cantidad de trabajo realizado*. A mayor número de procesadores, mayor cantidad
de trabajo puede realizar el sistema.
Sin embargo debemos de tener en cuenta que un sistema con stem:[N] CPU no es un sistema stem:[N] veces más
rápido.
Cuando varios procesadores cooperan para realizar una tarea, existe cierta pérdida de
rendimiento debida a los mecanismos de sincronización requeridos para controlar el acceso a los recursos compartidos por los procesadores.

* *Economía de escala*. Un sistema multiprocesador puede costar menos que múltiples sistemas monoprocesadores conectados para hacer un trabajo equivalente, porque comparten periféricos, almacenamiento, alimentación, etc.

* *Alta disponibilidad*. Con el hardware adecuado el sistema puede ser tolerante al fallo de uno de los procesadores.
En caso de fallo el sistema no se detendría pero si trabajaría más despacio.

En la actualidad existen dos tipos de sistemas multiprocesador:

// TODO: Figura SMP

* En los *sistemas de multiprocesamiento simétrico*(((sistema, multiprocesamiento simétrico)))(((multiprocesamiento, simétrico))) o *SMP* (_Symmetric Multiprocessing_) todos los procesadores son iguales.
Todos comparte los mismos recursos, pueden acceder a los
mismos dispositivos (véase la <<smp>>) y cada uno ejecuta una copia del núcleo del sistema operativo.
El sistema operativo debe saber haber sido diseñado para saber repartir el trabajo entre los procesadores y compartir adecuadamente entre tareas y procesadores el resto de recursos del sistema. 
Casi todos los sistemas multiprocesador modernos son de este tipo.

* En los *sistemas de multiprocesamiento asimétrico*(((sistema, multiprocesamiento asimétrico)))(((multiprocesamiento asimétrico))) o *AMP* (_Asymmetric Multiprocessing_) hay un procesador principal y varios secundarios a quienes la principal planifica y entrega las tareas que deben ejecutar.
En ocasiones los procesadores secundarios se distinguen del principal por haber sido diseñados para realizar algún tipo concreto de tareas de forma muy eficiente o por estar conectadas a hardware especial.
Ejemplos de esto son las https://es.wikipedia.org/wiki/Unidad_de_procesamiento_gr%C3%A1fico[GPU], que no son sino procesadores diseñados específicamente para el procesamiento de gráficos, o las CPU de E/S conectadas 
discos duros para gestionarlos de forma más eficiente.

[NOTE]
====
Un ejemplo bastante ilustrativo es el de https://es.wikipedia.org/wiki/Cell_(microprocesador)[Cell] la CPU de PlayStation 3.
Tenía un núcleo principal de propósito general y 8 núcleos optimizados para ejecutar de forma muy eficiente operaciones vectoriales.
Con la ayuda del sistema operativo, los programas debían envían tareas matemáticamente intensivas a los procesadores secundarios, si querían extraer el máximo provecho de la arquitectura.

Desarrollar para un sistema así es más complejo.
Por lo que, aunque sobre el papel esta arquitectura ofrecía gran rendimiento, aprovecharlo era un verdadero reto para los desarrolladores. 
====

=== Sistemas distribuidos
(((sistema, distribuido)))

En la actualidad es común el uso de redes para interconectar ordenadores individuales —por ejemplo Internet o la red de área local de una oficina— cada uno equipado con su procesador, su memoria, sus dispositivos de almacenamiento, su fuente de alimentación, etc.
En las redes de ordenadores los procesadores de dichos ordenadores se comunican con otros procesadores a través de líneas de comunicación, como: redes Ethernet, líneas telefónicas o wifi.
Estos sistemas son comúnmente denominados *sistemas distribuidos*.

Sin entrar en detalles, los sistemas distribuidos pueden ser clasificados en *sistemas cliente-servidor* y *sistemas de redes entre iguales*.

==== Sistemas cliente-servidor

En los *sistemas ((cliente-servidor))* (((sistema, cliente-servidor))) existen ordenadores que actúan como *servidores* encargados de satisfacer las peticiones generadas por otros ordenadores que actúan como *clientes*.

Este tipo de sistemas han sustituido, en un gran número de casos, a los terminales conectados a _mainframes_, debido a que los sistemas de escritorio son cada vez más potentes y baratos.
Concretamente:

* Los terminales han sido sustituidos por sistemas de escritorio que, al disponer de más recursos, son capaces de realizar muchas de las funcionalidades que anteriormente eran manejadas directamente por los _mainframes_.

* Al mismo tiempo estos _mainframes_ se han reemplazado por servidores, no muy diferentes a los sistemas de escritorios, pero preparados para atender las peticiones de sus clientes.

Ejemplos de este este tipo de sistemas son los servidores de base de datos, que responden a las consultas SQL de los clientes, o los servidores de archivos, que proporcionan una interfaz de sistema de archivos con la que los clientes pueden crear, leer, escribir y borrar archivos en el servidor; de forma similar a como si estuvieran almacenados localmente en el propio cliente.

==== Sistemas de redes entre iguales

En los *sistemas de redes entre iguales* (((sistema, redes entre iguales))) (((sistema, P2P))) o *((P2P))* (_peer-to-peer_) clientes y servidores no se distinguen los unos de los otros.
Todos los nodos del sistema son iguales y cada uno puede actuar como cliente o servidor, dependiendo de cuándo piden o proporcionan un servicio.

La ventaja fundamental de este tipo de sistemas es que en los sistemas cliente-servidor el servidor puede ser el cuello de botella del rendimiento, pero en los sistemas de redes entre iguales la carga se distribuye entre todos los nodos de la red.
Ejemplos de este tipo de sistemas son las redes https://es.wikipedia.org/wiki/BitTorrent[BitTorrent] y https://es.wikipedia.org/wiki/Bitcoin[Bitcoin].

[NOTE]
====
Un servidor puede ser el cuello de botella no solo por su potencia sino también por el ancho de banda de su conexión a la red.
La potencia del servidor es lo de menos cuando se intenta distribuir en Internet archivos de gran tamaño —por ejemplo imágenes de CD o DVD— pues el problema es que varias descargas simultaneas pueden consumir todo el ancho de banda del servidor durante largos periodos de tiempo.
====

==== Sistemas operativos para sistemas distribuidos

Desde el punto de vista de los sistemas operativos para sistemas distribuidos es posible hacer la siguiente distinción:

* Los *sistemas operativos de red* (((sistema operativo, red))) ofrecen a las aplicaciones que corren sobre ellos servicios de acceso a redes de ordenadores.
Por ejemplo, implementan algún mecanismo que permita a diferentes procesos en diferentes ordenadores enviar y recibir mensajes.
Además suelen incorporar la opción de proporcionar algunos servicios de red, como la compartición de archivos y dispositivos con otros equipos de la misma red.
+
====
Los ordenadores con sistemas operativos de red son autónomos.
Simplemente es que gracias al sistema operativo de red conocen la existencia de la red y saben usarla para comunicarse con otros ordenadores de la misma.

Este tipo de sistemas operativos son los más utilizados en los tipos de sistemas distribuidos comentados anteriormente.
En la actualidad, la inmensa mayoría de sistemas de escritorio y dispositivos de mano utilizan sistemas operativos de red.
====

* Los *sistemas operativos distribuidos* (((sistema operativo, distribuido))) crean en el usuario la ilusión de que está en un único ordenador, aunque en realidad el sistema operativo controla todos los ordenadores de la red, dando al usuario acceso transparente a los recursos en todos los equipos de la misma.
+
Con este tipo de sistemas operativos el usuario no sabe en qué ordenador se ejecutan sus procesos, dónde se almacenan sus archivos, ni qué equipo tiene conectado los distintos periféricos a los que tiene acceso.

[NOTE]
====
Un ejemplo de sistema operativo distribuido es https://en.wikipedia.org/wiki/Amoeba_(operating_system)[Amoeba], un sistema operativo distribuido de investigación escrito por Andrew S. Tanenbaum en Vrije Universiteit.
Para más información, véase el http://www.cs.vu.nl/pub/amoeba/[sitio web de Amoeba].
====

=== Sistemas en cluster
(((sistema, cluster)))

Como los sistemas distribuidos, los *sistemas en _cluster_* interconectar ordenadores individuales.
Sin embargo generalmente se acepta que los *sistemas en _cluster_* comparten el almacenamiento y estén conectados por medio de una red local, condiciones que no tienen por qué darse en los sistemas distribuidos.

Los *sistemas en _cluster_* se utilizan para:

* **Obtener servicios con alta disponibilidad**.
Para ello un nodo del _cluster_ puede estar ejecutando un servicio mientras otro nodo lo monitoriza.
En caso de fallo en el nodo que da el servicio, el que lo monitoriza lo sustituye.
+ 
Si es necesario proporcionar varios servicios, el mecanismo anterior se puede extender repartiendo los servicios entre dos o más nodos y haciendo que se monitoricen entre ellos.

* **Computación de alto rendimiento** o **HPC**.
En este caso todos los nodos se utilizan para dar un mismo servicio.
Un nodo especial, denominado balanceador de carga, tiene la responsabilidad de repartir el trabajo entre los nodos.
+
Este tipo de *sistemas en _cluster_* se utiliza para realizar trabajos de cálculo muy pesados, como simulaciones —por ejemplo simulación meteorológica, nuclear o de gestión hospitalaria— o romper sistemas de cifrado.

También es muy utilizado en servidores de Internet —como servidores web, correo electrónico o de mensajería instantánea— o servidores de base de datos que deban dar
servicio a una gran cantidad de clientes simultáneamente.
En estos casos el balanceador de carga realiza su trabajo repartiendo las conexiones de los usuarios entre los servidores del _cluster_.

=== Sistemas de tiempo real
(((sistema, tiempo real)))

Los **sistemas de ((tiempo real))** se utilizan cuando existen requerimientos estrictos de tiempo en la ejecución de ciertas tareas o en el procesamiento de flujos de datos.

En general se usan frecuentemente en dispositivos de control donde, dentro de unos márgenes estrictos de tiempo, se deben tomar datos de uno o varios sensores, para analizarlos posteriormente y realizar, en consecuencia, alguna acción con algún mecanismo de control.
Por ejemplo, se suelen utilizar en sistemas de control industrial, domótica, armamento, automoción —en la inyección electrónica de combustible, sistemas de frenado y de control de tracción— o en dispositivos médicos.

Los sistema de tiempo real están muy relacionados con los *sistemas empotrados*.
Los *sistemas empotrados*(((sistema, empotrado))):

* Se diseñan para realizar tareas muy específicas. No son sistemas de propósito general sino de propósito específico.

* Sus sistemas operativos tienen características muy limitadas y no tienen que tener necesariamente una interfaz de usuario.

* Estos sistemas están tanto en el motor de los automóviles y los robots que los fabrican, como en reproductores de DVD, microondas o dispositivos de red.

====
Los *sistemas de tiempo real* pueden ser clasificados en *sistemas de tiempo real estricto* y *sistemas de tiempo real flexible*:

* Los *sistemas de tiempo real estricto* (((sistema, tiempo real, estricto)))(((tiempo real, estricto))) o *((hard real-time))* garantizan que las tareas serán realizadas dentro de unos márgenes estrictos de tiempo.
+
Para ello, todas las situaciones imprevistas que puedan ocasionar retardos en el funcionamiento del sistema operativo deben estar perfectamente limitadas en tiempo.
Por lo tanto, suelen carecer de memoria virtual y de otras abstracciones que aíslen al desarrollador del funcionamiento real del hardware ya que introducen impredecibilidad.
+
Los sistemas de tiempo real estricto no son compatibles con los sistemas de tiempo compartido.

* Los *sistemas de tiempo real flexible* (((sistema, tiempo real, flexible))) (((tiempo real, flexible))) o *((soft real-time))* son útiles cuando en un sistema operativo convencional hay tareas que tienen mayor importancia que el resto, por lo que deben ser realizadas con mayor prioridad.
+
El tiempo real flexible no sirve cuando se tienen tareas con limitaciones precisas de tiempo, porque no hay manera de garantizar que dichas restricciones se van a cumplir.
Sin embargo si es útil para tareas relacionadas con la multimedia, la realidad virtual, los videojuegos, etc. y es compatible con la memoria virtual y otras características presentes en los sistemas de escritorio.
Por eso la mayor parte de los sistemas de escritorio actuales soportan tareas de tiempo real flexible.
====

== Historia de los sistemas operativos

La historia de los sistemas operativos se puede dividir en 5 grandes etapas o generaciones, obviamente conectadas con las generaciones de los ordenadores donde funcionaban.

[[_historia_primera_generación]]
=== 1ª Generación (1945-55)

En la primera generación de ordenadores no se utilizaban sistemas operativos.

====
Sus principales características son:

* Computadoras construidas con electrónica de https://es.wikipedia.org/wiki/V%C3%A1lvula_termoi%C3%B3nica[válvulas de vacío].

* Sin sistema operativo.

* Sin lenguajes de programación.
Se programaban directamente en lenguaje máquina.
====

Algunos ejemplos de ordenadores destacables fueron:

https://es.wikipedia.org/wiki/ENIAC[ENIAC] (1945):: Se le considera el primer ordenador electrónico digital de propósito general, aunque existe cierta polémica sobre este punto.
Lo cierto es que se construyeron otros ordenadores antes que este pero o no eran de propósito general —como las famosas computadoras https://es.wikipedia.org/wiki/Colossus[Colossus] (1944), que fueron diseñadas para ayudar en https://es.wikipedia.org/wiki/Criptoan%C3%A1lisis[criptoanálisis]— o no eran electrónicos sino electro-mecánicos —como la computadora https://es.wikipedia.org/wiki/Z3[Z3] (1941), que usaba https://es.wikipedia.org/wiki/Rel%C3%A9[relés]—.
+
No era un producto comercial sino un proyecto experimental de defensa que principalmente se diseño y utilizó para calcular tablas de tiro de artillería destinadas al Laboratorio de Investigación Balística del Ejército de los Estados Unidos.
+
https://es.wikipedia.org/wiki/Z4[Z4] (1945) fue el primer ordenador digital comercial, pero era electro-mecánico.

https://es.wikipedia.org/wiki/IBM_701[IBM 701] (1953):: Fue el primer _mainframe_ de la serie IBM 700, que a la larga se convertiría en un éxito de ventas.
Utilizaba tubos de vacío y tarjetas perforadas.

[NOTE]
====
El IBM 7090 —versión transistorizada del 709, que utilizaba válvulas de vacío, como todos los de la serie 700— y el posterior 7094, fueron usados por la NASA para los cálculos de control de las misiones de los programas espaciales Mercury y Gemini y durante la primera etapa del programa Apolo.
====

[[_historia_generación]]
=== 2ª Generación (1955-64)

En la segunda generación de ordenadores los transistores reemplazan a las válvulas de vacío.

====
En lo que respecta a los sistemas operativos:

* Aparecen los monitores del sistema, que se pueden considerar un predecesor de los sistemas operativos.

* Sistema de procesamiento por lotes.

* Se comienzan a utilizar lenguajes de programación, como: ensamblador FORTRAN y COBOL.
====

https://es.wikipedia.org/wiki/GM-NAA_I/O[GM-NAA I/O] (_General Motors and North American Aviation Input/Output system_) fue el primer sistema operativo.
Fue desarrollado por General Motors Research Laboratory en 1956 para el _mainframe_ https://en.wikipedia.org/wiki/IBM_704[IBM 704] con el fin de automatizar la carga y ejecución de un nuevo trabajo una vez había terminado el anterior.
Para su desarrollo se basaron en un monitor del sistema creado en 1955 por programadores de General Motors para el IBM 701.

[[instalación_ibm_702]]
.Instalación de un mainframe IBM 702 -- Fuente: https://commons.wikimedia.org/wiki/File:BRL61-IBM_702.jpg[Wikipedia]
image::instalación_ibm_702.jpg[]

[[_historia_tercera_generación]]
=== 3ª Generación (1965-1968)

En la tercera generación se comenzaron a utilizar los circuitos integrados, que fue una invención de finales de la década de 1950.

====
En lo que respecta a los sistemas operativos:

* Aparecen los sistemas operativos multiprogramados.

* Aparecen más lenguajes de programación.
====

El ejemplo más destacado de esta época es el https://en.wikipedia.org/wiki/OS/360_and_successors[IBM OS/260]
Fue un sistema operativo desarrollado por IBM para su _mainframe_ https://en.wikipedia.org/wiki/IBM_System/360[IBM System/360] (S/360) (véase la <<instalación_ibm_system_360>>).
Su versión DOS/360 (_Disk Operating System/360_) fue el primer sistema operativo en hacer los discos magnéticos un requisito para poder operar.

[[instalación_ibm_system_360]]
.Instalación de un mainframe IBM System/360 -- Fuente: http://www-03.ibm.com/ibm/history/ibm100/us/en/icons/system360/impacts/[IBM]
image::instalación_ibm_system_360.jpg[]

Se anunció en 1964 pero fue lanzado en 1966, con un año de retraso respecto a la fecha prevista originalmente.
Los motivos fundamentales fueron ciertos problemas de organización interna de la compañía y la falta de experiencia en proyectos de esa envergadura.
Las previsiones iniciales eran de 1 millón de líneas de código y miles de componentes de software.

[NOTE]
====
Algunos autores fechan los inicios de la ingeniería del software en la publicación del libro «The Mythical Man-Month: Essays on Software Engineering», escrito por Frederick Brooks y publicado en 1975.
Frederick Brooks se basó en la experiencia adquirida mientras administraba el desarrollo del IBM OS/360, donde era jefe de proyecto.
====

[[_historia_cuarta_generación]]
=== 4ª Generación (1965-1980)

La cuarta generación abarca desde mediados de los años 60 hasta finales de la década de los 70.
Respecto a los ordenadores, es el resultado del desarrollo de los microprocesadores. 

====
En lo que respecta a los sistemas operativos:

* Aparecen los sistemas operativos de tiempo compartido.

* Aparecen los terminales, los programas interactivos y las máquinas virtuales.
====

A continuación veremos los ejemplos más representativos de esta época.

==== MULTICS

https://es.wikipedia.org/wiki/Multics[MUTICS] fue anunciado en 1964, fruto de la colaboración entre el MIT, General Electrics y Bell Labs, como el primer sistema operativo de propósito general.

[[multics_mainframe]]
.Mainframe GE-6180 con sistema MULTICS, entorno a 1976 en el MIT -- Fuente: http://www.multicians.org/multics-stories.html[Multicians]
image::multics_mainframe.jpg[]

Fue el primer sistema operativo en proporcionar un sistema de archivos jerárquico, intérprete de comandos implementado como programa de usuario, listas de control de acceso individuales para cada archivo y enlazado dinámico, entre otras características novedosas.

Además experimentó con eliminar la separación entre el espacio de direcciones de los procesos y los archivos.
Es decir, como si todos los archivos estuvieran mapeados en memoria, permitiendo a los procesos acceder al contenido de los archivos directamente (véase el <<_archivos_mapeados_en_memoria>>).

==== VM/CMS

https://es.wikipedia.org/wiki/VM_(sistema_operativo)[VM/CMS] es un sistema de IBM utilizado en los _mainframe_ https://en.wikipedia.org/wiki/IBM_System/360[IBM System/360], System/370, System/390 y zSeries.
VM es un https://es.wikipedia.org/wiki/Hipervisor[hipervisor] que se encarga de virtualizar el hardware para crear múltiples máquinas virtuales, dando la sensación de que cada una es un _mainframe_ independiente.

Como sistema operativo de las maquinas virtuales, una opción común es CMS, un sistema interactivo y monousuario muy ligero, diseñado para operar fundamentalmente en una máquina virtual de VM.
Gracias a VM/CMS, cada usuario tiene la sensación de trabajar en un sistema completamente independiente y seguro.

El desarrollo de VM/CMS comenzó en 1965 y la primera versión estuvo disponible a primeros de 1966.
Las versiones actuales se denominan IBM z/VM.

==== UNIX

El sistema https://es.wikipedia.org/wiki/Unix[UNIX] fue desarrollado originalmente por Bell Labs en 1970 para los sistemas https://es.wikipedia.org/wiki/PDP-11[PDP-11/20] (véase la <<dec_pdp11>>).
La autoría del mismo se le atribuye a un grupo de programadores, liderados por Ken Thompson, que decidieron rehacer el trabajo de MULTICS pero a menor escala; después de que Bell Labs abandonara el proyecto MULTICS en 1969.
Inicialmente se llamó UNICS y fue desarrollado para los sistemas PDP-7.

[[dec_pdp11]]
.Dennis Ritchie (de pie) y Ken Thompson (sentado) frente a un PDP-11 y sus dos terminales https://en.wikipedia.org/wiki/Teletype_Model_33[Teletype 33] -- Fuente: https://www.bell-labs.com/usr/dmr/www/picture.html[Dennis Ritchie]
image::dec_pdp11_ken_den.jpg[]

La primer versión de UNIX fue implementada en ensamblador, como era común en la época.
Posteriormente, Dennis Ritchie y Brian Kernighan diseñaron un nuevo lenguaje de programación llamado «C», especialmente pensado para que UNIX fuera escrito con él.
Eso facilitó que UNIX pudiera ser portado a ordenadores diferentes.
Además, gracias al lenguaje C, el código era más conciso y compacto, lo que se tradujo en que se pudieron desarrollar nuevas funcionalidades más rápidamente.

AT&T, la compañía matriz de Bell Labs, no podía competir en la industria de los ordenadores, por lo que puso el código fuente de UNIX a disposición de universidades, compañías privadas y del gobierno de los Estados Unidos.
Eso aumento su difusión y dio resultados inesperados.
Por ejemplo, una de las variantes más importantes de UNIX fue https://es.wikipedia.org/wiki/Berkeley_Software_Distribution[BSD], desarrollada por la Universidad de California en Berkeley.

[NOTE]
====
La versión 4.2BSD (_Berkeley Software Distribution_) de esta variante de UNIX fue la primera que incluyó la interfaz de _sockets_ para facilitar la comunicación entre procesos a través de Internet y otras redes.
Esta interfaz se ha convertido en estándar en prácticamente cualquier sistemas operativo.
+
También implementó y ayudó a difundir el estándar de comunicaciones TCP/IP, base de la actual Internet.
Muchos sistemas operativos actuales, tanto libres como privativos, utilizan código de BSD en su implementaciones de los protocolos TCP/IP y de diversas utilidades de red.
====

En la actualidad se considera que hay dos grandes familias de UNIX y las distintas variantes pertenecen a una u otra en función del UNIX del que derivaron originalmente:

* La familia derivada de *AT&T UNIX System V*, en la que se incluyen sistemas operativos no libres, tales como: https://es.wikipedia.org/wiki/SCO_OpenServer[SCO OpenServer], https://es.wikipedia.org/wiki/Solaris_(sistema_operativo)[Oracle/Sun Microsystems Solaris Operating Environment] y https://es.wikipedia.org/wiki/UnixWare[SCO UnixWare].

* La familia derivada de *BSD*, en la que se incluyen sistemas libres como: https://es.wikipedia.org/wiki/FreeBSD[FreeBSD], https://es.wikipedia.org/wiki/NetBSD[NetBSD], https://es.wikipedia.org/wiki/OpenBSD[OpenBSD], https://en.wikipedia.org/wiki/Darwin_(operating_system)[Darwin] y https://es.wikipedia.org/wiki/DragonFly_BSD[DragonFly BSD], entre muchos otros.

[NOTE]
====
https://es.wikipedia.org/wiki/FreeBSD[FreeBSD] es el sistema base de algunos sistemas no libres.
Por ejemplo, https://en.wikipedia.org/wiki/Darwin_(operating_system)[Darwin] es el sistema operativo en el que se basan los sistemas operativos de Apple: macOS, IOS, watchOS, tvOS e iPadOS.
A su vez Darwin utiliza múltiples elementos de FreeBSD (véase el <<_mach>>).

Otro ejemplo destacable es https://en.wikipedia.org/wiki/PlayStation_4_system_software[Orbis OS] —el sistema operativo de PlayStation 4— que también está basado en FreeBSD.
====

==== VMS

https://en.wikipedia.org/wiki/OpenVMS[VMS] es un sistema operativo de 32 bits diseñado originalmente por Digital Equipment Corporation (DEC) —ahora propiedad de HP— en 1978 para usarlo en minicomputadoras https://es.wikipedia.org/wiki/VAX[VAX].
Posteriormente fue portado a sistemas DEC Alpha e Intel Itanium.

[[dec_vax11]]
.Instalación de VAX 11/780 en 1980 -- Fuente: http://www.chilton-computing.org.uk/[Science and Technology Facilities Council]
image::dec_vax11.jpg[]

Las sigas VMS vienen de _Virtual Memory System_, ya que una de sus principales características era explotar el concepto de *memoria virtual*.
Este concepto también es muy utilizando en los sistemas operativos modernos.
Permite que los procesos se ejecuten aislados, unos de otros, en la memoria principal y sin tener que ser cargados completamente, lo que permite que cada uno consuma memos memoria.

VMS era un sistema multiusuario y multiprocesador que podía distribuir el trabajo entre varias máquinas, lo que le permitía ser tolerante a fallos.

[NOTE]
====
VMS es en cierta medida un ancestro de Microsoft Windows NT (véase el <<_windows_nt>>).
Para desarrollar Windows NT, Microsoft contrató a un grupo de desarrolladores de Digital Equipment Corporation.
Muchos aspectos del diseño de Windows NT reflejan la experiencia de DEC en VMS.
====

==== IBM OS/400

El https://es.wikipedia.org/wiki/OS/400[IBM OS/400] es un sistema utilizado en la familia de minicomputadoras https://es.wikipedia.org/wiki/AS/400[IBM AS/400] —llamada iSeries desde 2006—.
Fueron introducidos en el mercado en 1988, pero aun es posible verlos en algunas organizaciones.
En 2008 el sistema operativo IBM OS/400 pasó a llamarse IBM i y siguen publicándose nuevas versiones en la actualidad.

=== 5º Generación (desde 1980):

Esta última generación abarca desde la década de 1980 hasta la actualidad.

====
Respecto a los sistemas operativos:

* Incluye a los sistemas operativos de escritorio y ordenadores personales (PC).

* Aparecen múltiples conceptos nuevos: monousuario, multitarea, distribuidos, paralelos, tiempo real, etc.
====

[NOTE]
====
Se puede observar una muestra de la interfaz gráfica de usuario de algunos estos sistemas en el artículo https://www.webdesignerdepot.com/2009/03/operating-system-interface-design-between-1981-2009/[«Operating System Interface Design Between 1981-2009»].
====

==== CP/M

https://en.wikipedia.org/wiki/CP/M[CP/M] (1974) fue el sistema operativo estándar en la primera generación de microcomputadoras. Fue creado por Digital Research, Inc. —fundada por Gary Kildall— para ser el sistema operativo de los microordenadores basados en https://es.wikipedia.org/wiki/Intel_8080[Intel 8080/85] y https://es.wikipedia.org/wiki/Zilog_Z80[Zilog Z80].

Con la elección de MS-DOS por parte de IBM para su https://es.wikipedia.org/wiki/IBM_PC[IBM PC], CP/M fue perdiendo mercado paulatinamente hasta desaparecer.
Sin embargo, la influencia de CP/M en MS-DOS es indudable, en tanto en cuanto 86-DOS, el predecesor de MS-DOS, estaba basado en las ideas de CP/M.

==== MS-DOS

https://es.wikipedia.org/wiki/MS-DOS[MS-DOS] fue el sistema operativo estándar en la segunda generación de microcomputadoras.
No era ni multitarea ni multiusuario.
Fue el primer sistema operativo del https://es.wikipedia.org/wiki/IBM_PC[IBM PC] —lanzado en 1981— y durante mucho tiempo fue ampliamente utilizado en toda la plataforma «PC compatible».

MS-DOS fue creado por Seattle Computer Products (SCP) con el nombre de https://es.wikipedia.org/wiki/QDOS[86-DOS] en 1979.
Se basaron en ideas de CP/M, pues pretendían ofrecer una versión de CP/M para procesadores https://es.wikipedia.org/wiki/Intel_8086_y_8088[Intel 8086].
Inicialmente era conocido como QDOS (_Quick and Dirty Operating System_) pero SCP le cambió el nombre en 1980, cuando comenzaron al licenciarlo.
Posteriormente Microsoft adquirió el sistema y lo vendió a IBM en 1981 con el nombre de MS-DOS.

Tanto IBM como Microsoft lanzaron versiones de DOS, aunque originalmente IBM solamente validaba y empaquetaba el software de Microsoft.
Microsoft lanzaba sus versiones bajo el nombre de MS-DOS, mientras IBM las lanzaba bajo el nombre de https://es.wikipedia.org/wiki/IBM_PC_DOS[IBM PC-DOS].

==== OS/2

https://es.wikipedia.org/wiki/OS/2[OS/2] fue un sistema operativo creado por Microsoft e IBM para aprovechar las nuevas características de la segunda generación de ordenadores personales de IBM, equipados con procesador https://es.wikipedia.org/wiki/Intel_80286[Intel 80286].
Pero al final terminó siendo desarrollado en exclusiva por IBM.

OS/2 fue pensado como un sucesor con *operación en modo dual* de MS-DOS y de Microsoft Windows 2.0.
Fue anunciado en abril y lanzado en diciembre de 1987 como un sistema operativo en modo texto.
En la versión 1.1, lanzaba en noviembre de 1988, se le añadió interfaz gráfica.

// Fuente: http://pages.prodigy.net/michaln/history/os211/index.html
[[os_2_1]]
.Panel de control de Microsoft-IBM OS/2 1.1 -- Fuente: Michal Necasek
image::os_2_1.png[]

[NOTE]
====
En los sistemas con *operación en modo dual* se distingue entre dos modos de ejecución, de tal forma que solo en el modo en el que se ejecuta el código del sistema operativo se pueden realizar operaciones peligrosas.
En el otro modo y con menos privilegios, se ejecutan las aplicaciones de usuario.
Para más información, véase el <<_operación_en_modo_dual>>
====

La colaboración entre IBM y Microsoft terminó en 1990, entre el lanzamiento de Windows 3.0 y la de OS/2 1.3.
El aumento de popularidad de Windows llevo a Microsoft a dejar de centrarse en el desarrollo de OS/2, lo que hizo que IBM se preocupara por los continuos retrasos en el desarrollo de OS/2 2.0.
Inicialmente ambas compañías acordaron que IBM tomaría el mantenimiento de OS/2 1.0 y el desarrollo de OS/2 2.0, mientras Microsoft continuaría desarrollando OS/2 3.0, que entonces era conocido como «NT OS/2».
Sin embargo Microsoft finalmente decidió renombrar NT OS/2 como Windows NT, dejando el futuro desarrollo de OS/2 en manos de IBM.

OS/2 Warp 3 fue un sistema completo de 32 bits lanzado en 1994.
Le seguiría OS/2 Warp 4, en 1996.
Poco después, IBM anunció que OS/2 desaparecería.

==== Windows 3.x

La familia https://es.wikipedia.org/wiki/Windows_3.1x[Windows 3.x] de Microsoft Windows fue desarrollada desde 1990 hasta 1994.
Windows 3.0 fue la primera versión de éxito de Windows, permitiendo a Microsoft competir con el https://es.wikipedia.org/wiki/Macintosh[Macintosh] de Apple Computer y el https://es.wikipedia.org/wiki/Commodore_Amiga[Commodore Amiga].

[[windows_30]]
.Administrador de programas de Microsoft Windows 3.0 -- Fuente: https://guidebookgallery.org/screenshots/win30[Guidebook]
image::windows_30.png[]

En 1983, Microsoft anunció el desarrollo de Windows, una interfaz gráfica de usuario para su sistema MS-DOS, que se usaba en los IBM PC y compatibles desde 1981.
Windows requería una instalación previa de MS-DOS y era iniciado como un programa más, que podía ser terminado en cualquier momento, devolviendo al usuario a la línea de comandos de MS-DOS.

MS-DOS le proporcionaba a Windows controladores de dispositivo para ciertas tareas, como el acceso al CD-ROM o a la interfaz de red.
Sin embargo Windows ejecutaba aplicaciones especificas de Windows, almacenadas en un formato ejecutable mucho más complejo que el de los programas de MS-DOS.
Además, debido a que MS-DOS no aislaba a las aplicaciones del hardware y no se protegía así mismo de los errores en dichas aplicaciones, Windows disponía de controladores de dispositivo propios, así como sus propios sistemas de gestión de procesos y de la memoria.
En realidad Windows no se ejecutaba sobre MS-DOS, sino que hacía uso de él.
Por ello puede ser considerado como un sistema operativo.

==== Windows 95, 98, Me

La familia Windows 3.x fue sustituida por una serie de sistemas operativos gráficos híbridos de 16/32 bits.

[[windows_95]]
.Escritorio de Microsoft Windows 95 -- Fuente: http://www.guidebookgallery.org/screenshots/win95[Guidebook]
image::windows_95.png[]

Windows 95 fue lanzado en 1995.
Fue el primer Windows unido a una versión de MS-DOS específica, aunque este hecho se intentaba mantener oculto.
Entre las características de Windows 95 destacan: mejoras significativas en la interfaz de usuario (véase la <<windows_95>>) nombres de archivo de hasta 256 caracteres con conservación de mayúsculas y minúsculas —en MS-DOS el límite era de 8 caracteres para el nombre más 3 de extensión— y multitarea expropiativa para las aplicaciones de 32 bits.

[NOTE]
====
Como veremos en el <<_planificación_expropiativa>>, la planificación expropiativa es una técnica que permite al sistema operativo expulsar de la CPU a los procesos en ciertas circunstancias; como, por ejemplo, que lleven demasiado tiempo utilizando la CPU de forma ininterrumpida.

En la familia Windows 3.x la planificación era cooperativa, es decir, los procesos abandonaban la CPU voluntariamente.
Esto ocasionaba problemas con programas que no devolvía la CPU al sistema con la suficiente frecuencia, ya que así el resto de procesos no tenía ocasión de ejecutarse para hacer su trabajo o responder al usuario.
====

Windows 98 fue lanzado el 25 de junio de 1998.
Le siguió Windows Me, el 14 de septiembre de 2000.
Windows Me fue la última versión de la familia de sistemas operativos híbridos de 16/32 bits que sucedió a la familia Windows 3.x.

[[_windows_nt]]
==== Windows NT, 2000, XP, Vista, 7, 8 y 10

Windows NT fue un sistema operativo de 32 bits.
El primero de la familia de sistemas operativos Microsoft Windows actuales.

Su desarrollo empezó en 1988 con el nombre de OS/2 3.0.
Cuando Windows 3.0 fue lanzado en mayo de 1990, tuvo tanto éxito que Microsoft decidió cambiar la API del aún en desarrollo NT OS/2 —que era como Microsoft lo llamaba entonces— pasando de ser una versión extendida de la API de OS/2 a una versión extendida de la API de Windows 3.0.
Esta decisión causó tensión entre Microsoft e IBM y provocó que finalmente la colaboración terminara.

[NOTE]
====
Una interfaz de programación de aplicaciones o API (del inglés _Application Programming Interface_) es el conjunto de funciones, procedimientos o métodos que ofrece el sistema operativo para ser utilizado por las aplicaciones.
====

Como hemos comentado anteriormente, Microsoft contrató a un grupo de desarrolladores de Digital Equipment Corporation para crear Windows NT.
Por lo que muchos de sus elementos reflejan la experiencia anterior de DEC en VMS.

Windows NT soportaba varias API de distintos sistemas operativos —por ejemplo Win32, POSIX y OS/2 2.1— que eran implementadas como subsistemas encima de un API nativo no documentado públicamente.
Esta estructura en subsistemas, fue lo que permitió la adopción tardía de la API de Windows 3.0 como API principal, tal y como hemos comentado.

La primera versión —Windows NT 3.1— lanzada el 13 de julio de 1993, era un sistema operativo microkernel (véase el <<_mach>> un poco más adelante) multiplataforma que corría sobre procesadores https://es.wikipedia.org/wiki/IA-32[Intel IA-32], https://es.wikipedia.org/wiki/DEC_Alpha[DEC Alpha], https://es.wikipedia.org/wiki/MIPS_(procesador)[MIPS R4000] y https://es.wikipedia.org/wiki/PowerPC[PowerPC].

[NOTE]
====
https://es.wikipedia.org/wiki/IA-32[Intel IA-32] es la denominación oficial del juego de instrucciones Intel x86 de 32 bits.
El primer procesador en implementarlo fue el https://es.wikipedia.org/wiki/Intel_80386[Intel 80386].
====

Windows NT 4.0 —lanzado en 1996— fue la última versión en soportar plataformas distintas a Intel IA-32.
Aunque el desarrollo de Windows 2000 para procesador Alpha continuó un poco más, hasta 1999, cuando Compaq dejó de soportar Windows NT en esa arquitectura.
Además Windows NT 4.0 integró en el núcleo más funciones —por ejemplo, parte del subsistema gráfico— para obtener un rendimiento más próximo al de Windows 95 en ese apartado.

Windows 2000 —o Windows NT 5.0— fue lanzado en el 17 de febrero de 2000 y fue el primer sistema operativo de la familia NT al que se le eliminaron las siglas del nombre.
Fue por motivos de marketing, para favorecer la unificación de las dos familias de sistemas operativos Microsoft Windows de entonces —Windows 9x y Windows NT— alrededor de la tecnología NT.

Windows XP —o Windows NT 5.1— completó en 2001 el proceso de unificación de las dos familias de sistemas operativos Windows.
Con su aparición forzó la extinción de la familia Windows 9x, al sustituirla con una versión de Windows XP denominada Windows XP Home Edition, específica para la informática doméstica.

==== GNU/Linux

https://es.wikipedia.org/wiki/GNU/Linux[GNU/Linux] es un sistema operativo libre y, tal vez, el más famoso proyecto de https://es.wikipedia.org/wiki/Software_libre[software libre].

El proyecto GNU se inició en 1983, con el fin de desarrollar un sistema operativo estilo UNIX enteramente libre.
El proyecto incluía la creación de herramientas de desarrollo de software y aplicaciones de usuario.

Mucho tiempo después, el estudiante universitario finés Linus Torvalds comenzó a desarrollar el núcleo Linux como hobby, mientras estudiaba en la Universidad de Helsinki.
Torvalds originalmente usaba https://es.wikipedia.org/wiki/MINIX[Minix], un sistema operativo simplificado escrito por Andrew Tanenbaum para enseñar diseño de sistemas operativos.
Sin embargo, el hecho de que Tanenbaum no diera soporte a las mejoras del sistema operativo que era propuestas por otros desarrolladores, llevó a Torvalds a escribir un sustituto de Minix.

En 1991, cuando se liberó la primera versión del núcleo Linux, el proyecto GNU había desarrollado todos los componentes necesarios del sistema operativo excepto el núcleo.
Torvalds y otros desarrolladores rápidamente adaptaron Linux para que funcionara con los componentes de GNU, creando un sistema operativo completamente funcional que se denomina GNU/Linux.

El núcleo Linux fue licenciado bajo la GNU General Public License (GPL), como el resto del proyecto GNU.
Pero Linux no es parte de dicho proyecto.
El proyecto GNU tiene su propio núcleo, denominado https://es.wikipedia.org/wiki/GNU_Hurd[GNU/Hurd], que aun sigue en desarrollo.

[[_mach]]
==== Mach

https://es.wikipedia.org/wiki/Mach_(n%C3%BAcleo)[Mach] ss un núcleo de sistema operativo desarrollado en la Universidad Carnegie-Mellon (CMU).
El proyecto en la CMU se desarrolló desde 1985 hasta 1994.

Mach explora el concepto que denominamos _*microkernel*_.
En los sistemas operativos _*microkernel*_ solo se implementa en el núcleo del sistema un conjunto mínimo de servicios básicos.
El resto de los servicios proporcionados por el sistema operativo se implementan como procesos con menos privilegios.

Por sus ventajas en cuanto a seguridad y fiabilidad, en algún momento se pensó que los _microkernel_ dominarían el universo de los sistema operativos.
Sin embargo, el mayor esfuerzo hasta la fecha para conseguirlo es https://es.wikipedia.org/wiki/GNU_Hurd[GNU/Hurd], que lleva más de dos década de retraso.
Por fortuna, otros sistemas operativos _microkernel_ han tenido algo más éxito, como es el caso de https://es.wikipedia.org/wiki/QNX[QNX].
Mientras que Google parece que lo va a intentar con https://es.wikipedia.org/wiki/Google_Fuchsiahttps://es.wikipedia.org/wiki/Google_Fuchsia[Google Fuchsia], el posible sustituto de Android.

// TODO: Meter más de Apple en la historia de los sistemas operativos

A mediados de los 90, Apple Computers seleccionó https://es.wikipedia.org/wiki/NEXTSTEP[OpenStep] como base para el sucesor de su clásico https://es.wikipedia.org/wiki/Mac_OS_Classic[Mac OS].
OpenStep es realmente una versión actualizada de NeXTSTEP que era un sistema basado en un núcleo Mach 2.5 con porciones del sistema BSD de la Universidad de Berkeley.
Por tanto, la mezcla de Mach con BSD de OpenStep es la base del sistema operativo https://es.wikipedia.org/wiki/MacOS[macOS] actual de Apple.

[[openstep_42]]
.Entorno gráfico de OpenStep 4.2 -- Fuente: https://guidebookgallery.org/screenshots/openstep42[Guidebook]
image::openstep_42.png[]

[NOTE]
====
Para ser exactos, la base del sistema operativo macOS es un sistema operativo libre denominado https://es.wikipedia.org/wiki/Darwin_(sistema_operativo)[Darwin] y desarrollado por Apple .
Se trata de un sistema https://es.wikipedia.org/wiki/FreeBSD[FreeBSD] adaptado para correr sobre el núcleo Mach.
====

.Linea de tiempo de la historia de los sistemas operativos.
image::historia_sistemas_operativos.svg[]
