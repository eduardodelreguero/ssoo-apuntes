= Operación del sistema operativo
ifndef::sectiondir[:sectiondir: .]
:imagesdir: {sectiondir}/images
include::../../config/attributes.adoc[]

_Los sistemas operativos modernos pertenecen a un tipo de software que se dice que está controlado mediante interrupciones_:

* Si no hay ningún proceso que ejecutar ni ningún dispositivo de E/S pide la atención del sistema, el sistema operativo debe permanecer inactivo esperado a que algo ocurra.

* Los sucesos que requieren la activación del sistema casi siempre se indican mediante una interrupción:

    ** Cuando un proceso comente un error —como una división por cero o un acceso a memoria no válido— o un programa solicita un servicio al sistema operativo a través de una llamada al sistema lo que se genera es una *excepción* —que no es más que una interrupción generada por software— que despierta al sistema operativo para que haga lo que sea más conveniente.

    ** Cuando los dispositivos de E/S requieren la atención del sistema operativo —por ejemplo porque se ha completado una transferencia de datos— se genera una interrupción que despierta al sistema operativo.

Dado que el sistema operativo y los procesos de usuarios comparten los recursos del sistema informático, _necesitamos estar seguros de que un error que se produzca en un programa sólo afecte al proceso que lo ejecuta_.
Por ejemplo, en los sistemas de tiempo compartido —y en cualquier otro tipo de sistema operativo donde los programas tengan que compartir la memoria, como es el caso de los sistema microprogramados— un programa erróneo puede modificar el código de otro programa, los datos de otro programa o el propio sistema operativo.
Por eso es necesario establecer mecanismos de protección frente a los errores en los programas que se ejecutan en el sistema.

== Operación en modo dual

Para evitar este tipo de problemas es necesario poder distinguir entre la ejecución de código del sistema operativo y del código de los programas de usuario.
El método que utilizan la mayor parte de los sistemas operativos consiste en _utilizar algún tipo de soporte en el hardware que permita diferencia entre varios modos de ejecución y restringir la utilización de las instrucciones peligrosas —*instrucciones privilegiadas*— para que sólo puedan ser utilizadas en el modo en el que se ejecuta el código del sistema operativo_.

Como mínimo son necesarios dos modos de operación diferentes:

* _En el *modo usuario* se ejecuta el código de las tareas de los usuarios_.
Si se hace un intento de ejecutar una instrucción privilegiada en este modo, el hardware la trata como ilegal y genera una excepción que es interceptada por el sistema operativo, en lugar de ejecutar la instrucción.

* _En el *modo privilegiado*_ —también denominado *modo supervisor*, *modo del sistema* o *modo kernel*— _se ejecuta el código de las tareas del sistema operativo_.
El hardware es el encargado de garantizar que las instrucciones privilegiadas sólo pueden ser ejecutadas en este modo.

El modo actual de operación _puede venir indicado por un *bit de modo* que se añade al hardware de la computadora_, de forma que si por ejemplo el bit está a 0, el código en ejecución opera en modo privilegiado mientras que si el bit está a 1, el código en ejecución opera en modo usuario.

Comúnmente en el grupo de las instrucciones privilegiadas se suelen incluir:

* _Las instrucción para conmutar al modo usuario_.
* _Las instrucciones de E/S_.
* _Las instrucciones necesarias para la gestión de las interrupciones_.

A continuación podemos ver el ciclo de vida de la ejecución de instrucciones en un sistema con modo dual de operación:

1.
_Inicialmente, al arrancar la computadora, el hardware se inicia en el modo privilegiado_ —es decir, con el bit de modo a 0—.
En este modo se carga el sistema operativo e inicia su ejecución.

2.
_El sistema operativo debe cambiar al modo usuario —poniendo el bit de modo a 1— antes de ceder el control a un proceso de usuario_.
Esto ocurre cuando es necesario que un proceso de usuario continúe o inicie su ejecución (véase el <<_el_asignador>>).

3.
_El hardware conmuta a modo privilegiado cuando ocurre una interrupción o una excepción_ —poniendo el bit de modo a 0— antes de pasar el control al código del sistema operativo que se encargará de tratarlas.

Esto último es importante pues, como ya hemos comentado, los sistemas operativos están controlados mediante interrupciones.
Al activarse el modo privilegiado cada vez que ocurre una interrupción podemos estar seguros de que las tareas del sistema operativo se ejecutará en modo privilegiado.

Cuando se dispone de la protección del modo dual el hardware se encarga de detectar los errores de ejecución y de notificarlo al sistema operativo mediante excepciones, siendo responsabilidad de este último realizar un tratamiento adecuado de los mismos.
Por lo general, si un programa falla de alguna forma, como por ejemplo intentando utilizar una instrucciones ilegal o de acceder a una zona de memoria inválida, el sistema operativo lo hace terminar de manera anormal.

== Protección de la memoria

La memoria principal debe acomodar tanto el sistema operativo como a los diferentes procesos de los usuarios.
Por eso la memoria normalmente se divide en dos partes:

1.
__La primera parte sirve para albergar el sistema operativo residente__footnote:[El termino sistema operativo residente hace referencias a los componentes del sistema operativo que deben estar permanentemente en la memoria.
Comúnmente dicho conjunto de elementos componen el núcleo del sistema.].
El sistema operativo puede estar localizado tanto en la parte baja como en la parte alta de la memoria.
El factor determinante en la elección es la localización del vector de interrupciones.
Puesto que en la mayor parte de las arquitecturas éste reside en la parte baja de la memoria, normalmente el sistema operativo también se aloja en la parte baja.

2.
_La segunda parte alberga los procesos de usuario_.

Sin embargo en los sistemas operativos modernos los procesos no tienen acceso libre a toda memoria física con el objeto de proteger a los procesos en ejecución y al sistema operativo de posibles errores en cualquiera de ellos:

* _El sistema operativo proporciona a cada proceso una «vista» privada de la memoria similar a la que tendrían si cada uno de ellos se estuviera ejecutando en solitario_ (véase la ).

* A esa «vista» que tiene cada proceso de la memoria es a lo que se denomina *espacio de direcciones virtual* del proceso y _está formado por el conjunto de direcciones que puede generar la CPU para un proceso dado_.

* Durante los accesos a la memoria principal en tiempo de ejecución estas *direcciones virtuales* son convertidas en direcciones físicas antes de ser enviadas a la memoria principal.
Por tanto _las *direcciones físicas* son las direcciones reales que ve la memoria,_ mientras que _el *espacio de direcciones físico* es el conjunto de direcciones físicas que corresponden a un espacio de direcciones virtual dado_.

_La conversión de una dirección virtual en una física la realiza en tiempo de ejecución un dispositivo hardware denominado MMU (Memory-Management Unit)_.
Las ventajas de este dispositivo desde el punto de vista de la protección de la memoria son que:

* _Permite el aislamiento de los procesos_, creando para cada uno la ilusión de que toda la memoria es para él y evitando que un proceso pueda acceder a la memoria de otros procesos.

* _Permite marcar los modos de acceso autorizados en las diferentes regiones de la memoria_ —como por ejemplo lectura, escritura y ejecución— evitando que el código ejecutado en modo usuario tenga acceso a zonas a las que no debería tenerlo.
El acceso a la memoria en un modo no autorizado se considera una instrucción privilegiada, por lo que ese tipo de acceso desde el modo usuario siempre genera una excepción.

== El temporizador

_El *temporizador* se utiliza para poder estar seguros de que el sistema operativo es capaz de mantener el control de la CPU_, puesto que lo que no puede ocurrir es que un proceso entre en un bucle infinito de manera que nunca devuelva el control al sistema operativo.

El temporizador se configura durante el arranque del sistema para interrumpir a la CPU a intervalos regulares.
Así, cuando el temporizador interrumpe, el control se transfiere automáticamente al sistema operativo.
Entonces este puede: conceder más tiempo al proceso en ejecución, detenerlo y darle más tiempo de CPU en el futuro o tratar la interrupción como un error y terminar de manera anormal el programa.
Indudablemente las instrucciones que pueden modificar el contenido del temporizador son instrucciones privilegiadas.
