= Interfaz de programación de aplicaciones
ifndef::sectiondir[:sectiondir: .]
:imagesdir: {sectiondir}/images
include::../../config/attributes.adoc[]

Un sistema operativo proporciona un entorno controlado para la ejecución de programas.
Dicho entorno debe proporcionar ciertos servicios que pueden ser accedidos por los programas a través de una *interfaz de programación de aplicaciones* o *API* (_Application Programming Interface_).
Algunas de las API disponibles para los desarrolladores de aplicaciones son la API Win32 —en sistemas Microsoft Windows— y la API POSIX para sistemas compatibles POSIXfootnote:[POSIX (_Portable Operating System Interface for Unix_) es el nombre de una familia de estándares que definen una interfaz de programación de aplicaciones para sistemas operativos.
Esto permite que un mismo programa pueda ser ejecutado en distintas plataformas, siempre que sean compatibles con POSIX.
La práctica totalidad de los sistemas UNIX modernos son compatibles POSIX ya que la especificación deriva de la interfaces típicas en ese tipo de sistemas antes de la aparición del estándar POSIX.] —como es el caso de los diferentes UNIX, Linux y macOS—.

Concretamente, _junto a cada intérprete o compilador de un lenguaje de programación suele ir una *librería estándar* que ofrece clases y/o funciones con las que los programas pueden acceder a los servicios del sistema operativo y realizar las tareas más comunes_.
Estas librerías generalmente no forman parte del sistema operativo, sino de las herramientas de desarrollo de cada lenguaje de programación, y constituyen la _interfaz de programación de aplicaciones_ (API) del lenguaje al que acompañan.

Las librerías estándar necesitan acceder a los servicios del sistema operativo para, a su vez, dar servicio a los programas que las usan.
Es decir, cuando un programa invoca alguna función o método de la librería estándar que lo acompaña, es muy probable que ésta necesite invocar uno o más servicios del sistema operativo para atender la petición convenientemente.
Para ello las librerías estándar utilizan la _librería del sistema_ —o librerías del sistema, en el caso de que hayan varias— que acompaña al sistema operativo.

[NOTE]
====
Por ejemplo, en el lenguaje de programación Python se debe utilizar la función `open()` de la librería estándar de Python para abrir o crear un archivo:

[source, python]
----
f = file("example.txt", "rb")
----

Mientras que en el lenguaje de programación C la función equivalente de la librería estándar de dicho lenguaje es `fopen()`:

[source, c]
----
FILE* fp = fopen("example.txt", "rb")
----

Ninguna de las dos funciones puede hacer su trabajo sin la ayuda del sistema operativo, porque sólo el sistema operativo tiene acceso a los discos duros y al resto de dispositivos del almacenamiento.
Así que ambas funciones están obligadas a solicitar la operación al sistema operativo, a través de la librería del sistema.
Por ejemplo, en Microsoft Windows, tanto `file()` en Python como `fopen()` en C tiene que llamar internamente la función `CreateFile()` de la librería del sistema (véase la ).
====

_La *librería del sistema* forma parte del sistema operativo y contiene un conjunto de clases o funciones —generalmente más primitivas que las de la librería estándar de los lenguajes de programación— que los programas deben utilizar para acceder a los servicios del sistema operativo_.
Es decir, la librería del sistema constituye la _interfaz de programación de aplicaciones_ del sistema operativo.
Es muy común que esta interfaz esté implementada para ser usada con programas en lenguaje C, lo que permite que tanto los programas en C como en {cpp} la puedan utilizar directamente.
Sin embargo con otros lenguajes de programación esto no suele ser posible, por lo que no queda más remedio que acceder a los servicios del sistema operativo a través de la librería estándar del lenguaje en cuestión.

[NOTE]
====
En Microsoft Windows, un programa en C puede usar tanto la función `fopen()` de su librería estándar como llamar directamente a la función `CreateFile()` de la librería del sistema.
Con {cpp} ocurriría lo mismo que con C, pero otros lenguajes no tienen esa facilidad para llamar a la librería del sistema directamente.
Por ejemplo, un programa en Python no puede llamar directamente a `CreateFile()` sino que debe usar la función `open()` de la librería estandar del lenguaje (véase la , destacado en rojo).

Usar directamente las funciones de la librería del sistema desde programas en C o {cpp} tiene la ventaja de que permite utilizar todas las características del sistema operativo.
Por ejemplo, podríamos utilizar opciones adicionales de `CreateFile()`:

[source, c]
----
HANDLE WINAPI CreateFile(
  LPCTSTR lpFileName,           // Nombre del archivo
  DWORD dwDesiredAccess,        // Modo de acceso
  DWORD dwShareMode,            // Modo de compartición
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,   // Permisos
  DWORD dwCreationDisposition,  // Acción si no existe el archivo
  DWORD dwFlagsAndAttributes,   // Atributos del archivo
  HANDLE hTemplateFile          // Archivo plantilla
);
----

que no `fopen()` no posee:

[source, c]
----
FILE* fopen(
  const char *path,             // Nombre del archivo
  const char *mode              // Modo de acceso
);
----

Sin embargo, debemos tener en cuenta que se pierde portabilidad pues `CreateFile()` solo está disponible en Microsoft Window, mientras que `fopen()` viene con la librería estándar de cualquier compilador de C.
====

Algunos de los servicios ofrecidos por la librería del sistema pueden ser implementados en la propia librería, pero en la mayor parte de los casos ésta debe solicitar dichos servicios al núcleo del sistema operativo que es quién supervisa y tiene acceso a los recursos de la máquina.

[NOTE]
====
En los sistemas UNIX o «estilo UNIX» las cosas son un poco más complejas.
El lenguaje C fue diseñado originalmente para implementar sistemas UNIX y por eso la librería estándar de C tiene mucho parecido con la librería del sistema de los sistemas UNIX.
Con el tiempo, al ir añadiendo más funcionaliades, la librería del sistema de los sistemas UNIX de los distintos fabricantes fue divergiendo, haciendo muy complicado desarrollar programas que usaran sus características más avanzadas y que a la vez pudieran usarse en varios de ellos.
Por eso el IEEE desarrollo el estándar POSIX, que define una interfaz de programación de aplicaciones (API) común para todos los UNIX y sistemas estilo UNIX modernos —como es el caso de Linux—.

Por su origen, la API POSIX es un superconjunto de la API de la librería estándar de C y por eso en estos sistemas la librería estándar de C es parte de la librería del sistema, en lugar de ser dos librerías separadas.
Como hemos comentado, otros lenguajes sí necesitan su propia librería estándar, que a su vez utiliza los servicios de la librería del sistema.

Por ejemplo, en {cpp} en Linux el método `open()` de la clase `std::ofstream` de la librería estándar utiliza a su vez la función `open()` de la librería del sistema para abrir o crear un archivo (véase la ).
La función `open()` no es parte del C estándar ni del {cpp} estándar, pero si del estándar POSIX.
Por lo tanto:

* Para crear programas para cualquier sistema operativo para el que tengamos un compilador de nuestro lenguaje, tenemos que limitarnos a usar funciones de la librería estándar de dicho lenguaje.
Por ejemplo, `fopen()` en C o `std::ofstream` en {cpp}.

* Para usar `open()` y otras funciones POSIX directamente —desde lenguajes como C o {cpp}— no es suficiente con tener un sistema con un compilador estándar de C, sino que necesitamos un sistema operativo que siga el estándar POSIX, que es mucho más amplio.

En la librería del sistema de los sistemas POSIX los desarrolladores del sistema a veces añaden funciones no incluidas en el estándar, con el objeto de soportar algún tipo de funcionalidad avanzada del sistema:

* Un programa que sólo utilice la API POSIX podrá ejecutarse en cualquier sistema operativo compatible POSIX.

* Mientras que uno que utilice, por ejemplo, alguna funcionalidad adicional no POSIX de Linux, sólo podrá compilarse y ejecutarse en Linux.
====

La librería del sistema, al igual que la estándar y otras librerías utilizadas por el programa, se cargan dentro de la región de memoria asignada al proceso donde se ejecuta el programa que las utiliza.
Por lo tanto, la invocación de sus métodos y funciones se realiza como si fueran cualquier otro método o función del programa.
Sin embargo, el código del núcleo del sistema operativo suele estar en una ubicación diferente que, desde el punto de vista de los programas, no es conocida y generalmente está protegida frente a accesos indebidos (véase el <<_protección_de_la_memoria>>).
Eso significa que para que la librería del sistema invoque los servicios que necesita hace falta un procedimiento diferente, denominado *llamada al sistema*.

_Las *llamadas al sistema* proporcionan una interfaz con la que los procesos pueden invocar los servicios que el sistema operativo ofrece_.
Estas llamadas habitualmente se hacen mediante instrucciones en lenguaje ensamblador (véase la ) pero generalmente los programas no las utilizan directamente.
En su lugar invocan las funciones de la librería del sistema, que a su vez son las encargadas de hacer las llamadas al sistema necesarias.

En las figuras y se ilustra el papel de todos los elementos comentados con el ejemplo de programas en C, {cpp} y Python que invocan los métodos `fopen()`, `std::ofstream::open()` y `file()` de la librería estándar de estos lenguajes, respectivamente.
En todo los casos, al final se realiza una llamada al sistema que hace que el sistema operativo tome el control, deteniendo la ejecución del proceso que la solicita.
Entonces se realiza la tarea solicitada mediante el funcionamiento coordinado de los diferentes componentes del sistema (véase el <<_componentes_del_sistema>>).

== Invocación de las llamadas al sistema

Generalmente una llamada al sistema se invoca mediante una instrucción específica en lenguaje ensamblador que genera una **excepción**footnote:[Una _excepción_ es una interrupción generada por software, que puede ser debida a un error —por ejemplo una división por cero o un acceso no válido a memoria— o a una llamada al sistema de un proceso para que se ejecute un servicio del sistema operativo.] —por ejemplo la instrucción _syscall_ en la — que es capturada por el sistema operativo, deteniendo la ejecución del proceso que la invocó.
Cuando se realiza la llamada es necesario que el proceso identifique la operación que quiere que se realice.
Esto se suele hacer poniendo un número identificativo de la llamada en un registro concreto de la CPU.
Por ejemplo, el número de la llamada al sistema `open` del ejemplo de la es 2footnote:[En GNU/Linux se puede conocer el número correspondiente a cada llamada al sistema soportada por el núcleo consultado el listado del archivo `/usr/include/asm/unistd.h`.].

Sin embargo, una llamada al sistema suele requerir más información que simplemente la identidad de la llamada.
Si por ejemplo se quisiera leer un bloque de datos desde un almacenamiento secundario, al menos se debería indicar el archivo o dispositivo desde el que se desea realizar la lectura, así como la dirección y tamaño de la región de la memoria donde se quiere que los datos sean copiados.
En concreto hay tres métodos para pasar parámetros a una llamada al sistema:

* _En el paso de parámetros *por registros* se cargan los parámetros de la llamada al sistema en los registros de la CPU antes de realizar la llamada_.
Este método es el más eficiente, pero limita el número de parámetros al número de registros disponibles en la CPU.
Es utilizado, por ejemplo, en Linux para IA-32footnote:[IA-32 (_Intel Architecture, 32-bit_), conocida en la actualidad de manera genérica como x86 o i386, es la arquitectura del conjunto de instrucciones de los procesadores Intel de 32 bits.
Concretamente es una extensión de 32 bits, implementada por primera vez en el Intel 80386, para la arquitectura x86 original de 16 bits.] cuando la llamada al sistema tiene menos de seis parámetros (véase la ).

* _En el paso de parámetros *por tabla en memoria* se copian los parámetros de la llamada al sistema en una tabla en memoria_, de manera que la dirección de dicha tabla debe ser cargada en un registro de la CPU antes de la llamada al sistema.
Evidentemente no limita el número de parámetros que pueden ser pasados a una llamada al sistema.
Por ejemplo, es utilizado en Linux IA-32, cuando la llamada al sistema tiene más de cinco parámetros, y en Microsoft Windows.

* _En el paso de parámetros *por pila* se insertan los parámetros de la llamada al sistema en la pila del proceso_.
En este caso el sistema operativo es el encargado de extraer los parámetros de la pila durante la llamada al sistema.
Al igual que en el caso anterior tampoco se limita el número de parámetros que pueden ser pasados.
Es utilizando, por ejemplo, en FreeBSD.

En cualquier caso, sea cual sea el método utilizado, _el sistema operativo debe comprobar de manera estricta los parámetros pasados en la llamada al sistema antes de realizar cualquier operación_, puesto que nunca debe confiar en que los procesos hagan su trabajo correctamente.
A fin de cuentas una de las funciones del sistema operativo es el control de dichos procesos.
