= Sistemas operativos por su estructura
ifndef::sectiondir[:sectiondir: .]
:imagesdir: {sectiondir}/images
include::../../config/attributes.adoc[]

Ya hemos discutido anteriormente acerca de los componentes más comunes en un sistema operativo (véase el <<_componentes_del_sistema>>).
En esta sección comentaremos su organización e interconexión dentro del núcleo.

== Estructura sencilla

_Los sistemas con *estructura sencilla* no tienen una estructura bien definida_.
Es decir, los interfaces y niveles de funcionalidad no están bien separados.

Por ejemplo, en MSDOS los programas de aplicación podían acceder directamente a la BIOS o al hardware para hace acceder a cualquier dispositivo (véase la ).
Disponiendo de esa libertad un programa erróneo cualquiera podía corromper el sistema completo.
Como el Intel 8086 para el que fue escrito MSDOS no proporcionaba un modo dual de operación, los diseñadores del sistema no tuvieron más opción que dejar accesible el hardware a los programas de usuario.

Otro ejemplo es el de UNIX original, donde se combinaba un montón de funcionalidad en un mismo nivel, el núcleo (véase la ).
Es decir, todo lo que estaba por encima del hardware y por debajo de las llamadas al sistema era el núcleo.
Este proporciona la planificación de CPU, la gestión de la memoria, el soporte de los sistemas de archivos y muchas otras funcionalidades del sistema operativo.
En general se trata de una enorme cantidad de funcionalidad que es difícil de implementar y mantener en un mismo nivel.
_Esa concentración de funcionalidad en el núcleo define a los sistemas de estructura sencilla como sistemas de núcleo *monolítico*_.

Tanto MSDOS como UNIX eran originalmente sistemas pequeños y simples, limitados por la funcionalidades del hardware de su época, que fueron creciendo más allá de las previsiones originales.
Lo cierto es que con mejor soporte del hardware se puede dividir el sistema operativo en piezas más pequeñas y apropiadas que las del MSDOS y UNIX original.

== Estructura en capas

_Un método para dividir el sistema operativo en piezas más pequeñas, con el fin de hacerlo más modular, es partirlo en capas_.
Las capas se seleccionan de manera que cada una use sólo funciones y servicios de las capas inferiores y de servicios sólo a las capas superiores.
Cada capa no tiene que saber como se implementan las funciones que utiliza de las capas inferiores, sólo debe conocer qué es lo que hacen y como utilizar.
Por lo tanto cada capa tiene la responsabilidad de ocultar la existencia de estructuras de datos, operaciones y hardware a las capas de nivel superior.
Este tipo de sistemas son los que se denominan con *estructura en capas*.

Los sistemas con estructura en capas siguen concentrado la mayor parte de la funcionalidad en el núcleo, por lo que _también son sistemas **monolíticos**_ aunque el núcleo es más modular.
Ejemplos de este tipo de sistemas operativos son el IBM OS/2 y Microsoft Windows (véase la ).

Sin embargo esta forma de dividir los componentes del sistema operativo no está libre de inconvenientes:

* _La mayor dificultad con los sistemas con estructura en capas es definirlas_.
Esto debe ser planificado cuidadosamente debido a la restricción, comentada anteriormente, de que un capa sólo puede utilizar los servicios de las capas inferiores.
Por ejemplo, el planificador de CPU suele tener información de los procesos que están en la memoria y parte de esa información puede ser intercambiada con el disco para aumentar la memoria principal disponible.
Este planteamiento nos lleva a pensar que la gestión del almacenamiento secundario debe ir en una capa inferior a la del planificador de la CPU.
Sin embargo el planificador debe replanificar la CPU cuando el proceso que actualmente la ocupa solicita alguna operación de E/S, por lo que la gestión del almacenamiento secundario debe estar encima del planificador de la CPU para que le pueda decir que replanifique.
_Al final la solución de compromiso es tender hacia sistemas con pocas capas donde cada una tiene mucha funcionalidad_.

* _Esta estrategia es sin duda mucho menos eficiente que la de los sistemas de estructura sencilla_.
En cada capa los parámetros son modificados y los datos necesarios deben de ser transferidos, por lo que cada una añade cierto nivel de sobrecarga al funcionamiento del sistema.

== Microkernel

_Los sistemas *microkernel* eliminan todos los componentes no esenciales del núcleo y los implementa como programas de nivel de usuario_.
Aunque hay poco consenso, en general un núcleo microkernel proporciona funciones mínimas de gestión de procesos y memoria, junto a algún mecanismo de comunicación.
En estos sistemas la función principal del núcleo es precisamente proporcionar dicho mecanismo de comunicación entre el programa cliente y los diversos servicios del sistema.
Generalmente esta comunicación se implementa mediante paso de mensajes (véase el <<_procesos_cooperativos>>).

Entre los beneficios de estos sistemas operativos se incluyen:

* _Facilidad a la hora de añadir nuevas funcionalidades_.
Los nuevos servicios son añadidos como aplicaciones de nivel de usuario, por lo que no es necesario hacer modificaciones en el núcleo.

* _Facilidad a la hora de portar el sistema a otras plataformas_.

* _Más seguridad y fiabilidad_.
Puesto que los servicios se ejecutan a nivel de usuario en procesos separados, un servicio que falla no puede afectar a otros ni puede ser utilizado para ganar acceso a otros servicios o al núcleo.

_El mayor inconveniente es su pobre rendimiento causado por la sobrecarga que añade el mecanismo de comunicación_.
Por ejemplo Microsoft Windows NT nació con una estructura de microkernel en capas donde una parte importante de los servicios eran proporcionados por unos procesos de usuario llamados subsistemas.
Además el sistema operativo podía mostrar diferentes personalidades o _entornos operativos_ —OS/2, POSIX y DOS— a través del uso de subsistemas ambientales, que también se ejecutaban como procesos de usuario.
Las aplicaciones de Microsoft Windows NT se comunicaban con estos subsistemas utilizando una forma de IPC (véase el <<_microkernel>>) denominada LPC (_Local Procedure Call_), una forma local y optimizada de RPCfootnote:[La RPC (_Remote Procedure Call_) es una mecanismo de llamada a procedimiento diseñado para ser utilizado entre sistemas conectados por redes de ordenadores, permitiendo que un proceso cliente llame a un procedimiento en un proceso servidor, aunque ambos estén en equipos diferentes, y ocultado los detalles de la comunicación que permiten que la llamada tenga lugar.].
Con esta estructura la pérdida de rendimiento respecto a Microsoft Windows 95 era tan importante que los diseñadores se vieron obligados a mover más servicios al espacio del núcleo.
En la actualidad Microsoft Windows XP (véase la ) —que es un heredero directo de Microsoft Windows NT— tiene una arquitectura más monolítica que microkernelfootnote:[A las 280 llamadas al sistema de Microsoft Windows XP —algo menos de 200 en Microsoft Windows NT 3.51— se deben sumar las más de 650 del subsistema gráfico, alojado en el núcleo desde Microsoft Windows NT 4.0.] ya que aunque muchos servicios siguen siendo proporcionados por procesos de usuario, esto sólo ocurre con aquellos donde el rendimiento no es un factor crítico.

Sin embargo varios sistemas operativos siguen utilizando núcleos microkernel, como Tru64 UNIX y GNU/Hurd (véase la ).
Ambos proporcionan una interfaz UNIX implementada sobre un microkernel Mach.
Otro ejemplo es QNX, un sistema operativo de tiempo real con una gran aceptación que basa en la estructura de microkernel su estabilidad como sistema para tareas críticas.
Además siguen existiendo algunos proyectos de investigación dirigidos a resolver los problemas de rendimiento asociados a los núcleos microkernel.

== Estructura modular

Los sistemas de *estructura modular* tienen divido el núcleo en módulos, cada uno de los cuales implementa funciones y servicios concretos, a imagen y semejanza de las técnicas de programación orientada a objetos.
Quizás por eso sea la mejor metodología actual para diseñar sistemas operativos.
Además _se parecen a los sistemas con estructura en capas en que cada módulo del núcleo tiene definidos interfaces protegidas, pero a diferencia de estos todos los módulos pueden llamar a cualquier otro módulo_.

Estos núcleos suelen disponer un pequeño conjunto de componentes fundamentales que se cargan durante el arranque, aunque también pueden enlazar dinámicamente servicios adicionales tanto durante la inicialización del sistema como o en tiempo de ejecución.
En este aspecto se asemejan a los núcleos microkernel, ya que el módulo principal sólo tiene funciones básicas, aunque es mucho más eficiente al no necesitar un mecanismo de paso de mensajes, puesto que los componentes se cargan directamente en la memoria destinada al núcleo.
Por lo tanto también _deben ser considerados como sistemas **monolíticos**_.

Este tipo de estructura es la utilizada en los UNIX modernos, como Oracle/Sun Microsystems Solaris, Linux (véase la ) y macOS.
