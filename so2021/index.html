<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="JesÃºs Torres">
<title>Sistemas Operativos</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
    .imageblock {
        text-align: center;
    }
    .imageblock > .content {
        margin-bottom: 1rem;
    }
    .imageblock > .title {
        text-align: inherit;
    }
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Sistemas Operativos</h1>
<div class="details">
<span id="author" class="author">JesÃºs Torres</span><br>
<span id="email" class="email"><a href="mailto:jmtorres@ull.es">jmtorres@ull.es</a></span><br>
<span id="revdate">Curso 2020-2021</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Tabla de Contenido</div>
<ul class="sectlevel1">
<li><a href="#_ejemplos_de_cÃ³digo">Ejemplos de cÃ³digo</a></li>
<li><a href="#_introducciÃ³n">Parte I: IntroducciÃ³n</a>
<ul class="sectlevel1">
<li><a href="#_quÃ©_es_un_sistema_operativo">1. Â¿QuÃ© es un sistema operativo?</a>
<ul class="sectlevel2">
<li><a href="#_definiciÃ³n_de_sistema_operativo">1.1. DefiniciÃ³n de sistema operativo</a></li>
<li><a href="#_funciones_del_sistema_operativo">1.2. Funciones del sistema operativo</a></li>
</ul>
</li>
<li><a href="#_tipos_de_sistemas_operativos">2. Tipos de sistemas operativos</a>
<ul class="sectlevel2">
<li><a href="#_mainframe">2.1. Mainframe</a></li>
<li><a href="#_sistemas_de_escritorio">2.2. Sistemas de escritorio</a></li>
<li><a href="#_sistemas_de_mano">2.3. Sistemas de mano</a></li>
<li><a href="#_sistemas_multiprocesador">2.4. Sistemas multiprocesador</a></li>
<li><a href="#_sistemas_distribuidos">2.5. Sistemas distribuidos</a></li>
<li><a href="#_sistemas_en_cluster">2.6. Sistemas en cluster</a></li>
<li><a href="#_sistemas_de_tiempo_real">2.7. Sistemas de tiempo real</a></li>
</ul>
</li>
<li><a href="#_historia_de_los_sistemas_operativos">3. Historia de los sistemas operativos</a>
<ul class="sectlevel2">
<li><a href="#_historia_primera_generaciÃ³n">3.1. 1Âª GeneraciÃ³n (1945-55)</a></li>
<li><a href="#_historia_segunda_generaciÃ³n">3.2. 2Âª GeneraciÃ³n (1955-64)</a></li>
<li><a href="#_historia_tercera_generaciÃ³n">3.3. 3Âª GeneraciÃ³n (1965-1968)</a></li>
<li><a href="#_historia_cuarta_generaciÃ³n">3.4. 4Âª GeneraciÃ³n (1965-1980)</a></li>
<li><a href="#_5Âº_generaciÃ³n_desde_1980">3.5. 5Âº GeneraciÃ³n (desde 1980):</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_organizaciÃ³n_de_los_sistemas_operativos">Parte II: OrganizaciÃ³n de los sistemas operativos</a>
<ul class="sectlevel1">
<li><a href="#_componentes_del_sistema">4. Componentes del sistema</a>
<ul class="sectlevel2">
<li><a href="#_gestiÃ³n_de_procesos">4.1. GestiÃ³n de procesos</a></li>
<li><a href="#_gestiÃ³n_de_la_memoria_principal">4.2. GestiÃ³n de la memoria principal</a></li>
<li><a href="#_gestiÃ³n_del_sistema_de_es">4.3. GestiÃ³n del sistema de E/S</a></li>
<li><a href="#_gestiÃ³n_del_almacenamiento_secundario">4.4. GestiÃ³n del almacenamiento secundario</a></li>
<li><a href="#_gestiÃ³n_del_sistema_de_archivos">4.5. GestiÃ³n del sistema de archivos</a></li>
<li><a href="#_gestiÃ³n_de_red">4.6. GestiÃ³n de red</a></li>
<li><a href="#_protecciÃ³n_y_seguridad">4.7. ProtecciÃ³n y seguridad</a></li>
</ul>
</li>
<li><a href="#_servicios_del_sistema">5. Servicios del sistema</a>
<ul class="sectlevel2">
<li><a href="#_servicios_que_garantizan_el_funcionamiento_eficiente_del_sistema">5.1. Servicios que garantizan el funcionamiento eficiente del sistema</a></li>
<li><a href="#_servicios_Ãºtiles_para_el_usuario">5.2. Servicios Ãºtiles para el usuario</a></li>
<li><a href="#_interfaz_de_usuario">5.3. Interfaz de usuario</a></li>
</ul>
</li>
<li><a href="#_interfaz_de_programaciÃ³n_de_aplicaciones">6. Interfaz de programaciÃ³n de aplicaciones</a>
<ul class="sectlevel2">
<li><a href="#_interfaces_de_programaciÃ³n_de_aplicaciones">6.1. Interfaces de programaciÃ³n de aplicaciones</a></li>
<li><a href="#_llamadas_al_sistema">6.2. Llamadas al sistema</a></li>
<li><a href="#_librerÃ­a_del_sistema">6.3. LibrerÃ­a del sistema</a></li>
<li><a href="#_librerÃ­a_estÃ¡ndar">6.4. LibrerÃ­a estÃ¡ndar</a></li>
<li><a href="#_con_todas_las_piezas_juntas">6.5. Con todas las piezas juntas</a></li>
</ul>
</li>
<li><a href="#_operaciÃ³n_del_sistema_operativo">7. OperaciÃ³n del sistema operativo</a>
<ul class="sectlevel2">
<li><a href="#_software_controlado_mediante_interrupciones">7.1. Software controlado mediante interrupciones</a></li>
<li><a href="#_operaciÃ³n_en_modo_dual">7.2. OperaciÃ³n en modo dual</a></li>
<li><a href="#_protecciÃ³n_de_la_memoria">7.3. ProtecciÃ³n de la memoria</a></li>
<li><a href="#_el_temporizador">7.4. El temporizador</a></li>
<li><a href="#_maquinas_virtuales">7.5. Maquinas virtuales</a></li>
<li><a href="#_arranque_del_sistema">7.6. Arranque del sistema</a></li>
</ul>
</li>
<li><a href="#_sistemas_operativos_por_su_estructura">8. Sistemas operativos por su estructura</a>
<ul class="sectlevel2">
<li><a href="#_estructura_sencilla">8.1. Estructura sencilla</a></li>
<li><a href="#_estructura_en_capas">8.2. Estructura en capas</a></li>
<li><a href="#_microkernel">8.3. Microkernel</a></li>
<li><a href="#_estructura_modular">8.4. Estructura modular</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_gestiÃ³n_de_procesos_2">Parte III: GestiÃ³n de procesos</a>
<ul class="sectlevel1">
<li><a href="#_procesos">9. Procesos</a>
<ul class="sectlevel2">
<li><a href="#_el_proceso">9.1. El proceso</a></li>
<li><a href="#_estados_de_los_procesos">9.2. Estados de los procesos</a></li>
<li><a href="#_bloque_de_control_de_proceso">9.3. Bloque de control de proceso</a></li>
<li><a href="#_colas_de_planificaciÃ³n">9.4. Colas de planificaciÃ³n</a></li>
<li><a href="#_planificaciÃ³n_de_procesos">9.5. PlanificaciÃ³n de procesos</a></li>
<li><a href="#_cambio_de_contexto">9.6. Cambio de contexto</a></li>
<li><a href="#_operaciones_sobre_los_procesos">9.7. Operaciones sobre los procesos</a></li>
<li><a href="#_procesos_cooperativos">9.8. Procesos cooperativos</a></li>
</ul>
</li>
<li><a href="#_comunicaciÃ³n_mediante_de_paso_de_mensajes">10. ComunicaciÃ³n mediante de paso de mensajes</a>
<ul class="sectlevel2">
<li><a href="#_tamaÃ±o_del_mensaje">10.1. TamaÃ±o del mensaje</a></li>
<li><a href="#_referenciaciÃ³n">10.2. ReferenciaciÃ³n</a></li>
<li><a href="#_buffering_2">10.3. Buffering</a></li>
<li><a href="#_operaciones_sÃ­ncronas_y_asÃ­ncronas">10.4. Operaciones sÃ­ncronas y asÃ­ncronas</a></li>
<li><a href="#_ejemplos_de_sistemas_de_paso_de_mensajes">10.5. Ejemplos de sistemas de paso de mensajes</a></li>
</ul>
</li>
<li><a href="#_memoria_compartida">11. Memoria compartida</a>
<ul class="sectlevel2">
<li><a href="#_memoria_compartida_anÃ³nima">11.1. Memoria compartida anÃ³nima</a></li>
<li><a href="#_memoria_compartida_con_nombre">11.2. Memoria compartida con nombre</a></li>
</ul>
</li>
<li><a href="#_hilos">12. Hilos</a>
<ul class="sectlevel2">
<li><a href="#_introducciÃ³n_2">12.1. IntroducciÃ³n</a></li>
<li><a href="#_modelos_multihilo">12.2. Modelos multihilo</a></li>
<li><a href="#_otras_consideraciones_sobre_los_hilos">12.3. Otras consideraciones sobre los hilos</a></li>
</ul>
</li>
<li><a href="#_sincronizaciÃ³n">13. SincronizaciÃ³n</a>
<ul class="sectlevel2">
<li><a href="#_el_problema_de_las_secciones_crÃ­ticas">13.1. El problema de las secciones crÃ­ticas</a></li>
<li><a href="#_semÃ¡foros_mutex_y_spinlocks">13.2. SemÃ¡foros, <em>mutex</em> y <em>spinlocks</em></a></li>
</ul>
</li>
<li><a href="#_planificaciÃ³n_de_la_cpu">14. PlanificaciÃ³n de la CPU</a>
<ul class="sectlevel2">
<li><a href="#_planificaciÃ³n_expropiativa">14.1. PlanificaciÃ³n expropiativa</a></li>
<li><a href="#_el_asignador">14.2. El asignador</a></li>
<li><a href="#_criterios_de_planificaciÃ³n">14.3. Criterios de planificaciÃ³n</a></li>
<li><a href="#_ciclo_de_rÃ¡fagas_de_cpu_y_de_es">14.4. Ciclo de rÃ¡fagas de CPU y de E/S</a></li>
<li><a href="#_planificaciÃ³n">14.5. PlanificaciÃ³n</a></li>
<li><a href="#_planificaciÃ³n_de_tiempo_real">14.6. PlanificaciÃ³n de tiempo real</a></li>
<li><a href="#_planificaciÃ³n_en_sistemas_multiprocesador">14.7. PlanificaciÃ³n en sistemas multiprocesador</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_gestiÃ³n_de_la_memoria">Parte IV: GestiÃ³n de la memoria</a>
<ul class="sectlevel1">
<li><a href="#_memoria_principal">15. Memoria principal</a>
<ul class="sectlevel2">
<li><a href="#_reubicaciÃ³n_de_las_direcciones">15.1. ReubicaciÃ³n de las direcciones</a></li>
<li><a href="#_enlazado_dinÃ¡mico_y_librerÃ­as_compartidas">15.2. Enlazado dinÃ¡mico y librerÃ­as compartidas</a></li>
<li><a href="#_asignaciÃ³n_de_memoria_contigua">15.3. AsignaciÃ³n de memoria contigua</a></li>
</ul>
</li>
<li><a href="#_paginaciÃ³n">16. PaginaciÃ³n</a>
<ul class="sectlevel2">
<li><a href="#_mÃ©todo_bÃ¡sico">16.1. MÃ©todo bÃ¡sico</a></li>
<li><a href="#_soporte_hardware_de_la_tabla_de_pÃ¡ginas">16.2. Soporte hardware de la tabla de pÃ¡ginas</a></li>
<li><a href="#_protecciÃ³n">16.3. ProtecciÃ³n</a></li>
<li><a href="#_pÃ¡ginas_compartidas">16.4. PÃ¡ginas compartidas</a></li>
</ul>
</li>
<li><a href="#_paginaciÃ³n_bajo_demanda">17. PaginaciÃ³n bajo demanda</a>
<ul class="sectlevel2">
<li><a href="#_memoria_virtual">17.1. Memoria virtual</a></li>
<li><a href="#_mÃ©todo_bÃ¡sico_2">17.2. MÃ©todo bÃ¡sico</a></li>
<li><a href="#_requerimientos_de_la_paginaciÃ³n_bajo_demanda">17.3. Requerimientos de la paginaciÃ³n bajo demanda</a></li>
<li><a href="#_rendimiento_de_la_paginaciÃ³n_bajo_demanda">17.4. Rendimiento de la paginaciÃ³n bajo demanda</a></li>
<li><a href="#_copy_on_write">17.5. Copy-on-write</a></li>
<li><a href="#_archivos_mapeados_en_memoria">17.6. Archivos mapeados en memoria</a></li>
<li><a href="#_reemplazo_de_pÃ¡gina">17.7. Reemplazo de pÃ¡gina</a></li>
<li><a href="#_asignaciÃ³n_de_marcos_de_pÃ¡gina">17.8. AsignaciÃ³n de marcos de pÃ¡gina</a></li>
<li><a href="#_hiperpaginaciÃ³n">17.9. HiperpaginaciÃ³n</a></li>
<li><a href="#_otras_consideraciones">17.10. Otras consideraciones</a></li>
</ul>
</li>
<li><a href="#_interfaz_de_gestiÃ³n_de_la_memoria">18. Interfaz de gestiÃ³n de la memoria</a>
<ul class="sectlevel2">
<li><a href="#_uso_del_espacio_de_direcciones_virtual_del_proceso">18.1. Uso del espacio de direcciones virtual del proceso</a></li>
<li><a href="#_gestiÃ³n_de_la_memoria_del_montÃ³n">18.2. GestiÃ³n de la memoria del montÃ³n</a></li>
<li><a href="#_fragmentaciÃ³n">18.3. FragmentaciÃ³n</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_gestiÃ³n_del_almacenamiento">Parte V: GestiÃ³n del almacenamiento</a>
<ul class="sectlevel1">
<li><a href="#_dispositivos_de_almacenamiento">19. Dispositivos de almacenamiento</a>
<ul class="sectlevel2">
<li><a href="#_discos_magnÃ©ticos">19.1. Discos magnÃ©ticos</a></li>
<li><a href="#_discos_Ã³pticos">19.2. Discos Ã³pticos</a></li>
<li><a href="#_memorias_de_estado_sÃ³lido">19.3. Memorias de estado sÃ³lido</a></li>
</ul>
</li>
<li><a href="#_archivos_y_sistemas_de_archivos">20. Archivos y sistemas de archivos</a></li>
<li><a href="#_volÃºmenes_de_datos">21. VolÃºmenes de datos</a>
<ul class="sectlevel2">
<li><a href="#_raid">21.1. RAID</a></li>
<li><a href="#_particiones">21.2. Particiones</a></li>
<li><a href="#_volÃºmenes_dinÃ¡micos">21.3. VolÃºmenes dinÃ¡micos</a></li>
</ul>
</li>
<li><a href="#_sistemas_de_archivos">22. Sistemas de archivos</a>
<ul class="sectlevel2">
<li><a href="#_estructura_de_un_sistema_de_archivos">22.1. Estructura de un sistema de archivos</a></li>
<li><a href="#_estructuras_de_metadatos">22.2. Estructuras de metadatos</a></li>
<li><a href="#_montaje_de_sistemas_de_archivos">22.3. Montaje de sistemas de archivos</a></li>
<li><a href="#_archivos">22.4. Archivos</a></li>
<li><a href="#_estructura_de_directorios">22.5. Estructura de directorios</a></li>
</ul>
</li>
<li><a href="#_comparticiÃ³n_de_archivos">23. ComparticiÃ³n de archivos</a>
<ul class="sectlevel2">
<li><a href="#_mÃºltiples_usuarios_y_protecciÃ³n">23.1. MÃºltiples usuarios y protecciÃ³n</a></li>
<li><a href="#_semÃ¡ntica_de_coherencia">23.2. SemÃ¡ntica de coherencia</a></li>
<li><a href="#_bloqueos_de_archivo">23.3. Bloqueos de archivo</a></li>
</ul>
</li>
<li><a href="#_coherencia">24. Coherencia</a>
<ul class="sectlevel2">
<li><a href="#_comprobaciÃ³n_de_coherencia">24.1. ComprobaciÃ³n de coherencia</a></li>
<li><a href="#_soft_updates">24.2. Soft Updates</a></li>
<li><a href="#_sistemas_de_archivos_basados_en_registro">24.3. Sistemas de archivos basados en registro</a></li>
<li><a href="#_sistemas_de_archivos_basados_en_copia_durante_la_escritura">24.4. Sistemas de archivos basados en copia durante la escritura</a></li>
</ul>
</li>
<li><a href="#_implementaciÃ³n_de_sistemas_de_archivos">25. ImplementaciÃ³n de sistemas de archivos</a>
<ul class="sectlevel2">
<li><a href="#_implementaciÃ³n_de_directorios">25.1. ImplementaciÃ³n de directorios</a></li>
<li><a href="#_mÃ©todos_de_asignaciÃ³n">25.2. MÃ©todos de asignaciÃ³n</a></li>
<li><a href="#_gestiÃ³n_del_espacio_libre">25.3. GestiÃ³n del espacio libre</a></li>
<li><a href="#_sistemas_de_archivos_virtuales">25.4. Sistemas de archivos virtuales</a></li>
</ul>
</li>
<li><a href="#_planificaciÃ³n_de_disco">26. PlanificaciÃ³n de disco</a>
<ul class="sectlevel2">
<li><a href="#_rendimiento_del_acceso_a_disco">26.1. Rendimiento del acceso a disco</a></li>
<li><a href="#_cola_de_es_al_disco">26.2. Cola de E/S al disco</a></li>
<li><a href="#_planificaciÃ³n_fcfs">26.3. PlanificaciÃ³n FCFS</a></li>
<li><a href="#_planificaciÃ³n_sstf">26.4. PlanificaciÃ³n SSTF</a></li>
<li><a href="#_planificaciÃ³n_scan_y_c_scan">26.5. PlanificaciÃ³n SCAN y C-SCAN</a></li>
<li><a href="#_planificaciÃ³n_look_y_c_look">26.6. PlanificaciÃ³n LOOK y C-LOOK</a></li>
<li><a href="#_planificaciÃ³n_n_step_scan_n_step_look_y_fscan">26.7. PlanificaciÃ³n N-Step-SCAN, N-Step-LOOK y FSCAN</a></li>
<li><a href="#_planificaciÃ³n_cfq">26.8. PlanificaciÃ³n CFQ</a></li>
</ul>
</li>
<li><a href="#_bibliografÃ­a">BibliografÃ­a</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_ejemplos_de_cÃ³digo">Ejemplos de cÃ³digo</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En algunos capÃ­tulos se enlazan ejemplos de cÃ³digo para ilustrar en mayor detalle los conceptos tratados.
Todos los ejemplos estÃ¡n disponibles en el repositorio <span class="icon"><i class="fa fa-github"></i></span> <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/tree/master">ull-esit-sistemas-operativos/ssoo-ejemplos</a>, de donde se pueden descargar.</p>
</div>
<div class="paragraph">
<p>Para compilar los ejemplos, es necesario disponer de herramientas de desarrollo para C y C++.
Por ejemplo, en la distribuciÃ³n Debian de GNU/Linux y derivadas âcomo Ubuntu o Linux Mintâ basta con tener instalados los paquetes <strong>build-essential</strong> y <strong>cmake</strong>.
Mientras que en Microsoft Windows hacen falta las <a href="https://go.microsoft.com/fwlink/?linkid=840931"><strong>Visual Studio Build Tools</strong></a>.</p>
</div>
<div class="paragraph">
<p>Para compilar es necesario hacer lo siguiente desde la lÃ­nea de comandos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Ir al directorio raÃ­z del repositorio descargado y descomprimido.</p>
</li>
<li>
<p>Ejecutar <code>cmake -B build</code> para configurar el proyecto.</p>
</li>
<li>
<p>Ejecutar <code>cmake --build build</code> para compilar los ejemplos.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>En Microsoft Windows estos comandos deben ejecutarse desde la consola de <strong>Developer Command Prompt</strong>.</p>
</div>
<div class="paragraph">
<p>En cada sistema solo se compilarÃ¡n los ejemplos compatibles, que se guardarÃ¡n en el directorio <code>build/bin/</code>, desde dÃ³nde se pueden ejecutar para probarlos.</p>
</div>
<div class="paragraph">
<p>El cÃ³digo fuente de los ejemplos estÃ¡ en el directorio <code>src/</code>, dentro del subdirectorio numerado con el capÃ­tulo correspondiente.</p>
</div>
</div>
</div>
<h1 id="_introducciÃ³n" class="sect0">Parte I: IntroducciÃ³n</h1>
<div class="sect1">
<h2 id="_quÃ©_es_un_sistema_operativo">1. Â¿QuÃ© es un sistema operativo?</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>7 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Â¿QuÃ© es un sistema operativo? Â¿cuÃ¡les son sus responsabilidades en el contexto de un sistema informÃ¡tico? Â¿cÃ³mo cumple con ellas?
Ãstas son algunas de las cuestiones que responderemos en este capÃ­tulo.
Aunque, cÃ³mo veremos, no son preguntas sencillas de responder.</p>
</div>
<div class="sect2">
<h3 id="_definiciÃ³n_de_sistema_operativo">1.1. DefiniciÃ³n de sistema operativo</h3>
<div class="paragraph">
<p>En general no existe una definiciÃ³n universal de lo quÃ© es un <strong>sistema operativo</strong>, aunque si muchas propuestas de diferentes autores:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hay quiÃ©n considera que simplemente es una cuestiÃ³n del mercado: Â«lo que nos venden cuando llegamos a una tienda y pedimos un sistema operativoÂ».</p>
<div class="paragraph">
<p>En realidad esta definiciÃ³n no es muy precisa, puesto que las caracterÃ­sticas incluidas pueden variar enormemente de un sistema a otro.
Por ejemplo, algunos sistemas operativos apenas alcanzan el megabyte de espacio, careciendo incluso de las aplicaciones mÃ¡s bÃ¡sicas, mientras que otros ocupan gigabytes de espacio, incluyen una interfaz grÃ¡fica basada en ventanas y las aplicaciones mÃ¡s comunes que cualquier usuario puede necesitar.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Aunque pueda parecer lo contrario, la cuestiÃ³n de quÃ© componentes son parte o no de un sistema operativo no es trivial. Por ejemplo, Microsoft y el Departamento de Justicia de los Estados Unidos se enfrentaron en 1998 por la inclusiÃ³n del navegador Internet Explorer como parte del sistema operativo Microsoft Windows.</p>
</div>
<div class="paragraph">
<p>Microsoft afirmaba que ambos productos eran realmente uno solo y que su uniÃ³n fue el resultado de un proceso de innovaciÃ³n.
Mientras tanto, la otra parte alegaba que el navegador era un producto distinto y separado, que no formaba parte del sistema operativo y que todo el asunto restringÃ­a la libre competencia en el mercado de los navegadores.</p>
</div>
<div class="paragraph">
<p>Seguramente en 1998 los argumentos del Departamento de Justicia de los Estados Unidos tenÃ­an mucho sentido, Â¿pero quÃ© ocurrirÃ­a si se planteara este mismo asunto en la actualidad?.
Â¿Concibes que tu mÃ³vil o tu ordenador no trajeran de serie un navegador?</p>
</div>
<div class="paragraph">
<p>Para mÃ¡s informaciÃ³n, vÃ©ase <a href="https://es.wikipedia.org/wiki/Caso_Estados_Unidos_contra_Microsoft">Â«Caso Estados Unidos contra Microsoft&#8201;&#8212;&#8201;WikipediaÂ»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Una definiciÃ³n mucho mÃ¡s comÃºn es que el sistema operativo es Â«aquel programa que se ejecuta continuamente en el ordenadorÂ» âlo que denominamos comÃºnmente como <em><strong>kernel</strong></em> o <strong>nÃºcleo</strong> del sistemaâ siendo todo lo demÃ¡s programas del sistema y aplicaciones.</p>
<div class="paragraph">
<p>Sin embargo, en algunos casos Ã©sta definiciÃ³n excluye como parte del sistema operativo algunos servicios que intuitivamente solemos considerar dentro del mismo.
Por ejemplo, si aplicamos esta definiciÃ³n a los sistemas operativos de estructura microkernel, no podrÃ­amos decir que servicios bÃ¡sicos como la comunicaciÃ³n en red, los sistemas de archivos y la gestiÃ³n de la memoria son parte del sistema operativo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Como veremos en el <a href="#_microkernel">Apartado 8.3</a>, en los sistemas operativos <em>microkernel</em> la funcionalidad implementada en el nÃºcleo del sistema es la mÃ­nima necesaria.
Por lo tanto, segÃºn la definiciÃ³n anterior, muchos de los componentes y servicios bÃ¡sicos que damos por supuestos a un sistema operativo no formarÃ­an parte del mismo en ese tipo de sistemas.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_funciones_del_sistema_operativo">1.2. Funciones del sistema operativo</h3>
<div class="paragraph">
<p>Por lo que hemos visto hasta ahora, parece evidente que no es sencillo definir lo que Â«esÂ» un sistema operativo.
Sin embargo, es posible que tengamos mÃ¡s suerte definiÃ©ndolo a travÃ©s de lo que Â«haceÂ».
Es decir, describiendo sus funciones dentro de un sistema informÃ¡tico cualquiera.</p>
</div>
<div id="componentes_sistema_informÃ¡tico" class="imageblock">
<div class="content">
<img src="C01-definiciÃ³n/images/componentes_sistema_informÃ¡tico.svg" alt="componentes sistema informÃ¡tico">
</div>
<div class="title">Figura 1. Vista abstracta de los componentes de un sistema informÃ¡tico.</div>
</div>
<div class="paragraph">
<p>Un <strong>sistema informÃ¡tico</strong> puede ser dividido, <em>grosso modo</em>, en cuatro componentes: el hardware, los usuarios, los programas de aplicaciÃ³n y el sistema operativo (vÃ©ase la <a href="#componentes_sistema_informÃ¡tico">Figura 1</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Programas de aplicaciÃ³n</strong>. El objetivo fundamental de cualquier sistema informÃ¡tico es ejecutar programas para resolver los problemas informÃ¡ticos de los usuarios.
Con ese objetivo se construye su hardware y se desarrollan los programas de aplicaciÃ³n âprocesadores de textos, hojas de cÃ¡lculo, compiladores, navegadores de Internet, etc.â que usan los usuarios para resolver sus problemas.</p>
</li>
<li>
<p><strong>Hardware</strong>. El hardware âla CPU, la memoria, los dispositivos de entrada salida, etc.â proporcionan los recursos computacionales del sistema informÃ¡tico.
Los programas de aplicaciÃ³n necesitan usar estos recursos computacionales para resolver los problemas informÃ¡ticos de los usuarios.</p>
</li>
<li>
<p><strong>Sistema operativo</strong>. En un sistema informÃ¡tico las aplicaciones necesitan realizar operaciones comunes, como acceder a los dispositivos de E/S o reservar porciones de la memoria.
En lugar de que cada aplicaciÃ³n intente hacerlo por su cuenta, es mucho mÃ¡s sencillo que estas operaciones comunes estÃ©n centralizadas en el sistema operativo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por lo tanto, el sistema operativo controla, coordina el acceso y asigna los recursos computacionales del hardware a los distintos programas de aplicaciÃ³n.</p>
</div>
<div class="paragraph">
<p>En realidad Ã©sta es solo una de las dos perspectivas desde las que se pueden analizar las funciones del sistema operativo.
Es la denominada como: <strong>perspectiva del sistema informÃ¡tico</strong>, mientras que la otra es la <strong>perspectiva del usuario</strong>.</p>
</div>
<div class="sect3">
<h4 id="_perspectiva_del_sistema_informÃ¡tico">1.2.1. Perspectiva del sistema informÃ¡tico</h4>
<div class="paragraph">
<p>Un sistema informÃ¡tico tiene mÃºltiples recursos hardware, como son: tiempo de CPU, espacio de memoria, espacio de almacenamiento de archivos, dispositivos de E/S, etc.
TambiÃ©n tiene recursos software ofrecidos por algunos programas que se ejecutan en el sistema, como son: servicios de red, servicios de impresiÃ³n, seguridad, etc.â.
Estos recursos los necesitan los programas de aplicaciÃ³n para resolver los problemas informÃ¡ticos de los usuarios.</p>
</div>
<div class="paragraph">
<p>Dentro del sistema informÃ¡tico, el sistema operativo es el programa mÃ¡s Ã­ntimamente relacionado con el hardware y su funciÃ³n es gestionar los recursos hardware y software disponibles, asignarlos a los diferentes programas, resolver los conflictos en las peticiones y hacer que el sistema opere eficientemente para resolver los problemas de los usuarios.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, el sistema operativo es el programa encargado del control de la ejecuciÃ³n de los programas de los usuarios, por lo que tiene la tarea de prevenir errores y el uso inadecuado del ordenador.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En resumen, desde la perspectiva del sistema informÃ¡tico, las funciones del <strong>sistema operativo</strong> son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gestionar los recursos computacionales del sistema informÃ¡tico.</p>
</li>
<li>
<p>Controlar la ejecuciÃ³n de los programas de usuario y el acceso a los dispositivos de E/S.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Un <strong>sistema operativo</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No hace trabajo directamente Ãºtil para los usuarios.</p>
</li>
<li>
<p>Pero proporciona un entorno adecuado para que los programas de aplicaciÃ³n lo hagan.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los sistemas operativos existen porque es mÃ¡s sencillo crear sistemas informÃ¡ticos Ãºtiles para los usuarios con ellos que sin ellos.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_perspectiva_del_usuario">1.2.2. Perspectiva del usuario</h4>
<div class="paragraph">
<p>Si intentamos definir las funciones del sistema operativo desde nuestra experiencia como usuarios, seguramente harÃ­amos referencia a la interfaz que nos proporciona para utilizar el sistema informÃ¡tico.
Sin embargo, debemos tener en cuenta que la interfaz varÃ­a con el tipo de sistema, por lo que definir las funciones del sistema operativo desde la perspectiva del usuario es mucho mÃ¡s difÃ­cil.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, los usuarios que se sientan frente a un sistema de escritorio disponen de: monitor, teclado, ratÃ³n y una unidad central.
Estos sistemas se diseÃ±an buscando la mÃ¡xima productividad en equipos donde un usuario monopoliza todos los recursos; por lo que el sistema operativo se diseÃ±a considerando fundamentalmente la facilidad de uso, poniendo algo de atenciÃ³n en el rendimiento y nada en el aprovechamiento de los recursos.</p>
</div>
<div class="paragraph">
<p>Esto difiere mucho de otro tipo de sistema informÃ¡tico dÃ³nde mÃºltiples usuarios se sientan frente a terminales conectadas a un gran ordenador central.
AsÃ­ todos los usuarios comparten los recursos del sistema informÃ¡tico y pueden intercambiar informaciÃ³n entre sÃ­.
En este tipo de sistemas el sistema operativo maximiza el aprovechamiento de los recursos con el objeto de garantizar que toda la CPU, memoria y E/S son empleadas de forma eficiente y que ningÃºn usuario utiliza mÃ¡s de lo que le corresponde.
Obviamente, en este tipo de sistemas la facilidad de uso estÃ¡ en un segundo plano.</p>
</div>
<div class="paragraph">
<p>Otros sistemas operativos se diseÃ±an para sistemas informÃ¡ticos que tienen poca o ninguna interacciÃ³n con los usuarios.
Es, por ejemplo, el caso de los sistema empotrados de los electrodomÃ©sticos.</p>
</div>
<div class="paragraph">
<p>Todos estos tipos de sistemas tienen interfaces muy diferentes, lo que dificulta obtener una definiciÃ³n Ãºnica de sistema operativo desde la perspectiva del usuario.</p>
</div>
<div class="paragraph">
<p>En los tres casos los objetivos con los que se diseÃ±a el sistema operativo son opuestos, por lo que seguramente sea diferente Â«lo que tiene que hacerÂ» cada sistema operativo para alcanzarlos.
Sin embargo, en los tres casos el sistema operativo es el responsable de la gestiÃ³n de los recursos computacionales y del control de los programas, funciones que definimos anteriormente desde la perspectiva del sistema informÃ¡tico y que no cambian de un tipo de sistema a otro.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tipos_de_sistemas_operativos">2. Tipos de sistemas operativos</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>22 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Ahora que sabemos que todos los sistemas operativos hacen lo mismo pero que el Â«cÃ³moÂ» lo hacen difiere de un tipo de sistema informÃ¡tico a otro, vamos a ver los tipos de sistemas informÃ¡ticos, las caracterÃ­sticas de los sistemas operativos que los gestionan y cÃ³mo han evolucionado a lo largo de la historia.</p>
</div>
<div class="sect2">
<h3 id="_mainframe">2.1. Mainframe</h3>
<div class="paragraph">
<p>Los <strong>ordenadores centrales</strong> o <em><strong>mainframes</strong></em> fueron los primeros computadores utilizados en muchas aplicaciones comerciales y cientÃ­ficas.
Se caracterizan no tanto por la potencia de su CPU como por su: gran capacidad de memoria, gran capacidad de almacenamiento secundario, gran cantidad de dispositivos de E/S y rapidez de Ã©stos y alta fiabilidad.</p>
</div>
<div class="paragraph">
<p>Los <em>mainframes</em> pueden funcionar durante aÃ±os sin problemas ni interrupciones y las reparaciones se realizan sin detener su funcionamiento.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La mayor diferencia entre los superordenadores y los <em>mainframes</em> estÃ¡ en que los primeros se centran en resolver problemas limitados por la velocidad de cÃ¡lculo âlo cual requiere miles de CPU de alto rendimientoâ mientras que los segundos se centran en la fiabilidad y en problemas limitados por la E/S âpor lo que los <em>mainframes</em> suelen tener Â«soloÂ» entre una y varias docenas de CPUâ.</p>
</div>
<div class="paragraph">
<p>Para mÃ¡s informaciÃ³n sobre los <em>mainframes</em>, vÃ©ase <a href="http://es.wikipedia.org/wiki/Ordenador_central">Â«Ordenador central&#8201;&#8212;&#8201;WikipediaÂ»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los <em>mainframes</em> aparecieron a finales de la dÃ©cada de los 50 del siglo pasado y han seguido evolucionando hasta la actualidad, por lo que dentro de este tipo de sistemas nos encontramos con varios categorÃ­as.</p>
</div>
<div class="sect3">
<h4 id="_sistemas_de_procesamiento_por_lotes">2.1.1. Sistemas de procesamiento por lotes</h4>
<div class="paragraph">
<p>
</p>
</div>
<div class="paragraph">
<p>Los primeros <em>mainframe</em> eran enormes mÃ¡quinas operadas desde una consola y conectados a lectores de tarjetas perforadas, dispositivos de cinta e impresoras.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Para imÃ¡genes y mÃ¡s informaciÃ³n sobre las tarjetas perforadas, vÃ©ase <a href="https://en.wikipedia.org/wiki/Computer_programming_in_the_punched_card_era">Â«Computer programming in the punched card era&#8201;&#8212;&#8201;WikipediaÂ»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El trabajo era preparado por cada programador ânormalmente en tarjetas perforadasâ y entregado al operador del sistema, que era quiÃ©n tenÃ­a acceso al sistema y la responsabilidad de ejecutar los programas y devolver los resultados al programador correspondiente.</p>
</div>
<div class="paragraph">
<p>No habÃ­a sistema operativo y el operador debÃ­a cargar y ejecutar cada programa de uno en uno.</p>
</div>
<div id="consola_ibm_705" class="imageblock">
<div class="content">
<img src="C02-tipos_de_sistemas/images/consola_ibm_705.jpg" alt="consola ibm 705">
</div>
<div class="title">Figura 2. Operadora en la consola de un mainframe IBM 705&#8201;&#8212;&#8201;Fuente: <a href="https://www.ibm.com/ibm/history/ibm100/images/icp/Y444110I58591Z46/us__en_us__ibm100__700_series__705__620x350.jpg">IBM</a></div>
</div>
<div class="paragraph">
<p>Estos sistemas se convirtieron en <strong>sistemas de procesamiento por lotes</strong> o <strong>sistemas en <em>batch</em></strong> cuando se comenzÃ³ a utilizar un pequeÃ±o programa âllamado <strong>monitor del sistema</strong>â cuya funciÃ³n era cargar y ejecutar sin interrupciÃ³n un conjunto âo loteâ de programas.</p>
</div>
<div class="paragraph">
<p>Para preparar los lotes, por lo general, el operador cargaba previamente en cinta magnÃ©tica el conjunto de programas a partir de las tarjetas perforadas proporcionadas por los programadores.
Para ello se utilizaba un lector de tarjetas autÃ³nomo, independiente del <em>mainframe</em>.</p>
</div>
<div id="sistemas_procesamiento_lotes" class="imageblock">
<div class="content">
<img src="C02-tipos_de_sistemas/images/sistemas_procesamiento_lotes.svg" alt="sistemas procesamiento lotes">
</div>
<div class="title">Figura 3. OrganizaciÃ³n de la memoria en sistemas de procesamiento por lotes.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>El <strong>monitor del sistema</strong> es un predecesor de los sistemas operativos y tenÃ­a las siguientes caracterÃ­sticas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>PermanecÃ­a cargado durante todo el tiempo en la memoria del sistema (vÃ©ase la <a href="#sistemas_procesamiento_lotes">Figura 3</a>).</p>
</li>
<li>
<p>Su Ãºnica tarea era cargar y transferir automÃ¡ticamente la ejecuciÃ³n de un programa al siguiente cuando el anterior terminaba.</p>
</li>
<li>
<p>El mayor inconveniente de este tipo de sistemas era que la CPU permanecÃ­a mucho tiempo desocupada porque era ây sigue siendoâ varios ordenes de magnitud mÃ¡s rÃ¡pida que los dispositivos de E/S.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Cualquier programa necesita realizar operaciones de E/S para obtener los datos requeridos para sus cÃ¡lculos âguardados en tarjetas perforadas y unidades de cinta o, si hablamos de hoy en dÃ­a, en discos duros y memorias USBâ.
TambiÃ©n necesita hacer operaciones de E/S para guardar o imprimir los resultados de esos cÃ¡lculos.</p>
</div>
<div class="paragraph">
<p>Si solo se puede ejecutar un programa la vez, cuando el programa solicita una operaciÃ³n de E/S, la CPU queda a la espera de que esta termine para continuar con la ejecuciÃ³n del programa, por lo que se pierde tiempo de CPU en no hacer nada.
Este desaprovechamiento de la CPU es peor cuanto mÃ¡s rÃ¡pida es la CPU respecto a los dispositivos de E/S.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_multiprogramados">2.1.2. Sistemas multiprogramados</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La soluciÃ³n al inconveniente de los sistemas de procesamiento por lotes con la E/S fue que los programas no accedieran directamente al dispositivo de E/S, sino que, en su lugar, solicitaran la operaciÃ³n al <strong>monitor del sistema</strong> para que Ã©ste la solicitara al hardware.
AsÃ­ el sistema operativo âcomo podemos comenzar a llamarloâ tiene la oportunidad de sustituir el programa en la CPU por otro, mientras la operaciÃ³n de E/S se completa.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, con la apariciÃ³n de la tecnologÃ­a de los discos magnÃ©ticos en la dÃ©cada de los 60 del siglo pasado, los trabajos de los programadores comenzaron a ser almacenados en discos, desde donde eran escogidos por el sistema operativo para su ejecuciÃ³n.</p>
</div>
<div class="paragraph">
<p>A estos sistemas se los llamÃ³ <strong>multiprogramados</strong>.</p>
</div>
<div id="sistemas_multiprogramados" class="imageblock">
<div class="content">
<img src="C02-tipos_de_sistemas/images/sistemas_multiprogramados.svg" alt="sistemas multiprogramados">
</div>
<div class="title">Figura 4. OrganizaciÃ³n de la memoria en sistemas multiprogramados.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En los <strong>sistemas multiprogramados</strong> la ejecuciÃ³n de los trabajos funcionaba de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>En el disco magnÃ©tico se almacenaba una cola donde se iban colocando todos los trabajos que tenÃ­an que ser ejecutados.</p>
</li>
<li>
<p>El sistema operativo cargaba varios trabajos en memoria del conjunto de trabajos en la cola en el disco magnÃ©tico (vÃ©ase la <a href="#sistemas_multiprogramados">Figura 4</a>).</p>
</li>
<li>
<p>El sistema operativo cede la CPU a uno de los trabajos en memoria.</p>
</li>
<li>
<p>Cuando el trabajo en la CPU requerÃ­a usar la E/S se lo pedÃ­a al sistema operativo.
En lugar de mantener a la CPU ocupada inÃºtilmente, el sistema operativo programaba la operaciÃ³n de E/S pero escogÃ­a otro trabajo de entre los que estaban en memoria y lo ejecutaba en la CPU.</p>
<div class="paragraph">
<p>Cuando la operaciÃ³n de E/S del anterior trabajo terminaba, el programa que ocupaba la CPU no era interrumpido, sino que debÃ­a esperar a una nueva oportunidad de ser escogido para ejecutarse en la CPU.</p>
</div>
</li>
<li>
<p>Cuando un programa en la CPU terminaba, sus recursos se liberaban, dejando memoria libre.
Por lo tanto, el sistema operativo escogÃ­a un nuevo trabajo de la cola de trabajos en el disco magnÃ©tico y lo cargaba en la memoria.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Todo este proceso se repetÃ­a mientras hubiera trabajos que ejecutar en la cola de trabajos en el disco.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Para operar de la forma descrita es necesario que el sistema operativo realice tres tareas esenciales:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La <strong>planificaciÃ³n de trabajos</strong>, cuya responsabilidad es seleccionar el siguiente trabajo que serÃ¡ cargado en la memoria principal para mantenerla llena.</p>
</li>
<li>
<p>La <strong>planificaciÃ³n de la CPU</strong>, cuya responsabilidad es elegir el siguiente trabajo que serÃ¡ ejecutado en la CPU, de entre los disponibles en la memoria principal.</p>
</li>
<li>
<p>La <strong>gestiÃ³n de la memoria</strong>, cuya responsabilidad es repartir la memoria principal entre los trabajos alojados en la misma.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Un ejemplo de este tipo de sistemas operativos es el IBM OS/360, que fue lanzado en 1966 para utilizarlo en los <em>mainframes</em> IBM System/360 (vÃ©ase el <a href="#_historia_segunda_generaciÃ³n">Apartado 3.2</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_de_tiempo_compartido">2.1.3. Sistemas de tiempo compartido</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los sistemas multiprogramados ofrecÃ­an un uso mÃ¡s eficiente de la CPU pero no eran capaces de proporcionar interacciÃ³n directa con los usuarios.
Los programadores seguÃ­an teniendo que entregar los trabajos al operador y esperar a que Ã©ste les devolviera los resultados.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas de tiempo compartido</strong> se desarrollaron tras observar que al dar acceso a un grupo de usuarios se podÃ­a conseguir un uso mÃ¡s eficiente del sistema, en comparaciÃ³n a cuando solo podÃ­a ser utilizado por un usuario a la vez.
Esto es debido a que, generalmente, un usuario introduce informaciÃ³n de forma continua para luego detenerse durante largos periodos de tiempo, mientras que en un grupo de usuarios, las pausas de uno de ellos se pueden llenar con la actividad de los otros.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los <strong>sistemas de tiempo compartido</strong> se caracterizaban por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tener <strong>terminales</strong>, es decir, hardware especializado en hacer de interfaz directa entre los usuarios y el sistema.
A travÃ©s de estas terminales los usuarios podÃ­an dar Ã³rdenes al sistema e interactuar con sus trabajos.
PodÃ­an haber mÃºltiples usuarios al mismo tiempo pero cada uno solo podÃ­a tener un trabajo en ejecuciÃ³n a la vez.</p>
</li>
<li>
<p>Usar la <strong>multiprogramaciÃ³n</strong> para tener varios trabajos en la memoria principal al mismo tiempo e intercambiar el trabajo en la CPU cuando Ã©ste solicitaba una operaciÃ³n de E/S, como ya se venÃ­a haciendo en los <strong>sistemas multiprogramados</strong> para hacer un uso mÃ¡s eficiente de la CPU.</p>
</li>
<li>
<p>Repartir el tiempo de CPU entre usuarios.
El sistema operativo asignaba un tiempo de CPU a cada usuario âdenominado <strong>ventana de tiempo</strong> o <strong>cuanto</strong> de CPUâ.
Cuando este tiempo se agotaba, el sistema intercambiaba el trabajo en la CPU por el de otro usuario en el sistema.
La ventana de tiempo era extremadamente pequeÃ±a, dando a cada usuario la impresiÃ³n de que su trabajo nunca se detenÃ­a, como si dispusiera de la CPU en exclusiva.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los sistemas que, como los de tiempo compartido, pueden ser utilizados por varios usuarios simultÃ¡neamente se denominan sistemas <strong>multiusuario</strong> .</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En los primeros sistemas se usaban <strong>terminales</strong> electro-mecÃ¡nicos con un teclado y una impresora, como el <a href="https://en.wikipedia.org/wiki/Teletype_Model_33">Teletype Model 3</a> (1963).
Posteriormente llegaron los terminales electrÃ³nicos, que usaban un monitor en lugar de una impresora, como el <a href="https://es.wikipedia.org/wiki/IBM_3270">IBM 3270</a>.
En cualquier caso solo disponÃ­an del hardware necesario para realizar la tarea de conectar a los usuarios con el ordenador central.</p>
</div>
<div class="paragraph">
<p>Estos terminales no deben confundirse con las terminales por software que traen algunos sistemas operativos modernos.
Las terminales por software o <em>terminales virtuales</em> se programan para emular las especificaciones de alguna versiÃ³n de esas terminales fÃ­sicas antiguas que hemos comentado.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los sistemas de tiempo compartido significaron un salto importante en complejidad por diversas razones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Como varios trabajos estÃ¡n en la memoria principal al mismo tiempo, el sistema operativo requiere mecanismos de <strong>gestiÃ³n de la memoria</strong> y <strong>protecciÃ³n</strong>.</p>
</li>
<li>
<p>Para tener un tiempo de respuesta razonable, los trabajos deben estar cargados en la memoria principal.
Para que quepan mÃ¡s trabajos de los usuarios en la memoria, el sistema operativo debe utilizar tÃ©cnicas de <strong>memoria virtual</strong> para ejecutar trabajos que no estÃ¡n completamente cargados en la memoria principal.</p>
</li>
<li>
<p>Como la CPU debe ser compartida entre todos los trabajos, el sistema operativo necesita mecanismos de <strong>planificaciÃ³n de la CPU</strong>.</p>
</li>
<li>
<p>Como varios trabajos pueden tener la necesidad de cooperar y que su ejecuciÃ³n siga cierto orden, el sistema operativo debe proporcionar mecanismos de <strong>sincronizaciÃ³n</strong> y <strong>comunicaciÃ³n</strong>.</p>
</li>
<li>
<p>Como el sistema debe disponer de un <strong>sistema de archivos</strong> para repartir el espacio en disco y facilitar a los usuarios el acceso y gestiÃ³n de sus datos, el sistema operativo necesita un componente de <strong>gestiÃ³n de discos</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Las primeras versiones de UNIX âlanzado por primera vez en 1970â el sistema operativo VMS âdesarrollado en 1978â para los VAX de Digital Equipment Corportation y el IBM OS/400 âintroducido en 1988â utilizado en los minicomputadoras AS/400, son algunos ejemplos de sistemas operativos de tiempo compartido (vÃ©ase el <a href="#_historia_tercera_generaciÃ³n">Apartado 3.3</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Estrictamente hablando, el tÃ©rmino <strong>sistemas de tiempo compartido</strong> hace referencia a estos <em>mainframes</em> desarrollados a partir de principios de la dÃ©cada de 1970.
AsÃ­ que no es comÃºn utilizarlo con <em>mainframe</em> modernos.</p>
</div>
<div class="paragraph">
<p>Los <em>mainframe</em> modernos permiten a un mismo usuario ejecutar varios trabajos al mismo tiempo, repartiendo el tiempo de CPU entre todos los trabajo en el sistema y no solo entre los usuarios.
Y lo mismo ocurre en la mayor parte de los sistemas operativos de propÃ³sito general actuales âutilizados en ordenadores de escritorio, servidores, portÃ¡tiles y dispositivos mÃ³vilesâ que con el tiempo han copiado muchas caracterÃ­sticas de los <strong>sistemas de tiempo compartido</strong>.
Por eso el termino actuales <strong>sistema multitarea</strong>, que es mucho mÃ¡s general.</p>
</div>
<div class="paragraph">
<p>La <strong>multitarea</strong>  es un mÃ©todo para tener varios procesos en memoria y ejecutarlos Â«al mismo tiempoÂ».
Generalmente requiere de tÃ©cnicas de multiprogramaciÃ³n, como las empleadas por los antiguos <strong>sistemas multiprogramados</strong>, y de reparto del tiempo de CPU, como ocurre en los antiguos <strong>sistemas de tiempo compartido</strong>.
Por eso se puede decir que esos dos tipos de sistemas <em>mainframe</em> eran <strong>sistemas multitarea</strong>.
Al igual que lo son los <em>mainframe</em> modernos y muchos sistemas operativos actuales de escritorio y de dispositivos mÃ³viles.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_escritorio">2.2. Sistemas de escritorio</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la dÃ©cada de los 70 del siglo pasado tambiÃ©n aparecieron las primeras CPU en microprocesadores y con Ã©stas llegaron las <strong>microcomputadoras</strong> o <strong>microordenadores</strong>.
Las primeras <strong>microcomputadoras</strong> no incluÃ­an teclado ni monitor y se programaban usando interruptores y ledes ubicados en el frontal de la unidad.
Pero en torno a 1977 apareciÃ³ la segunda generaciÃ³n de <strong>microcomputadoras</strong>, que si incluÃ­an estos perifÃ©ricos de E/S, por lo que eran mÃ¡s fÃ¡ciles de usar que sus predecesoras.
Entonces comenzaron a recibir el nombre de <em>ordenadores domÃ©sticos</em> y de su mano llegaron los primeros <strong>sistemas operativos de escritorio</strong>.</p>
</div>
<div id="ordenadores_domÃ©sticos_1977" class="imageblock">
<div class="content">
<img src="C02-tipos_de_sistemas/images/ordenadores_domÃ©sticos_1977.jpg" alt="ordenadores domÃ©sticos 1977">
</div>
<div class="title">Figura 5. Los tres ordenadores que la revista Byte denominÃ³ como la "Trinidad de 1977" de la computaciÃ³n domÃ©stica: el <a href="https://es.wikipedia.org/wiki/Commodore_PET">Commodore PET 2001</a>, el <a href="https://es.wikipedia.org/wiki/Apple_II">Apple II</a> y el <a href="https://es.wikipedia.org/wiki/TRS-80">TRS-80 Model I</a>&#8201;&#8212;&#8201;Fuente: <a href="https://commons.wikimedia.org/wiki/File:Trinity77.jpg">Wikipedia</a></div>
</div>
<div class="paragraph">
<p>Los <em>mainframes</em> y las minicomputadoras de la Ã©poca siguieron siendo los ordenadores corporativos por excelencia, ya que eran mucho mÃ¡s grandes y potentes, y tambiÃ©n costosos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El tÃ©rmino en desuso <strong>minicomputadora</strong> o <strong>miniordenador</strong> hace referencia a mÃ¡quinas multiusuario de rango medio, entre los <em>mainframes</em> y los ordenadores domÃ©sticos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los primeros <strong>sistemas operativos de escritorio</strong> eran muy bÃ¡sicos.
Por ejemplo, en un sistema diseÃ±ado para ser utilizado por un Ãºnico usuario no tiene sentido implementar un sistema de archivos con permisos.
AsÃ­ que, los primeros sistemas operativos de escritorio carecÃ­an de esta caracterÃ­stica que, sin embargo, ya existÃ­a en los sistemas de tiempo compartido de la Ã©poca.
De la misma manera, carecÃ­an de otros mecanismos de protecciÃ³n y no eran ni multiusuario ni multitarea.</p>
</div>
<div class="paragraph">
<p>Pese a estas diferencias, los <strong>sistemas operativos de escritorio</strong> se han beneficiado del desarrollo de los sistemas operativos para <em>mainframes</em>.
Los sistemas de escritorio actuales son <strong>multiusuario</strong> y <strong>multitarea</strong>; incluyen sistemas de archivos con permisos, autenticaciÃ³n y mecanismos de protecciÃ³n de la memoria âcomo medidas para proteger los datos de los usuariosâ y han incorporado muchas otras caracterÃ­sticas de los sistemas operativos para <em>mainframe</em>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Aunque con el tiempo los sistemas de escritorio han ido adquiriendo caracterÃ­sticas desarrolladas en los <em>mainframe</em>, no debemos olvidar que ambos tipos de sistemas se siguen diseÃ±ando con objetivos diferentes.
Mientras que en los <em>mainframe</em> se persigue maximizar la fiabilidad y utilizaciÃ³n eficiente de los recursos, en los sistemas de escritorio se maximiza la facilidad de uso y el tiempo de respuesta al usuario, poniendo algo de atenciÃ³n al rendimiento.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas operativos de escritorio</strong> modernos ya nos son Â«solo de escritorioÂ» ni se ejecutan Ãºnicamente en ordenadores domÃ©sticos.
Se utilizan en un altÃ­simo porcentaje en servidores, superordenadores y hasta en dispositivos mÃ³viles.
Por eso, en la actualidad, el tÃ©rmino <strong>sistema operativo de propÃ³sito general</strong>  es mucho mÃ¡s adecuado.</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El <strong>tiempo de respuesta</strong> al usuario se puede considerar como el intervalo de tiempo entre un comando de un usuario âpor ejemplo un clicâ y la respuesta del sistema a dicho comando.
En ocasiones este tiempo se minimiza a costa de un uso menos eficiente de los recursos del sistema, por lo que no es un objetivo deseable para diseÃ±ar un <em>mainframe</em>.
Para mÃ¡s informaciÃ³n, vÃ©ase el <a href="#_criterios_de_planificaciÃ³n">Apartado 14.3</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Son muchos los ejemplos de sistemas operativos en esta categorÃ­a. Van desde CP/M âlanzado en 1977â hasta los actuales GNU/Linux, Microsoft Windows y Apple macOS, pasando por MS-DOS, IBM OS/2 y todas las versiones anteriores de Microsoft Windows (vÃ©ase el <a href="#_historia_cuarta_generaciÃ³n">Apartado 3.4</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_mano">2.3. Sistemas de mano</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Con el nombre genÃ©rico de <strong>sistemas de mano</strong> hacemos referencia a las <em>tablets</em>, lectores de libros electrÃ³nicos y telÃ©fonos mÃ³viles.
Los desarrolladores de aplicaciones y sistemas de mano deben enfrentarse a diversos desafÃ­os, originados por el tamaÃ±o limitado de los dispositivos y la alimentaciÃ³n mediante el uso de baterÃ­as.
Debido a esas limitaciones muchos sistemas de mano tienen poca cantidad de memoria, procesadores lentos âen comparaciÃ³n con sus equivalentes de escritorioâ y pantallas mÃ¡s pequeÃ±as.</p>
</div>
<div class="paragraph">
<p>En el diseÃ±o del sistema operativo suele primar la facilidad de uso y buscar un buen equilibrio entre rendimiento y tiempo de vida de la baterÃ­a.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_multiprocesador">2.4. Sistemas multiprocesador</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Un <strong>sistema multiprocesador</strong> es aquel ordenador hay procesadores interconectados que comparten el bus del sistema, el reloj y, en ocasiones la memoria, y los perifÃ©ricos.</p>
</div>
<div class="paragraph">
<p>Hace aÃ±os esto solo se daban en sistemas con varias CPU, lo que era relativamente comÃºn en servidores y sistemas de alto rendimiento para trabajos tÃ©cnicos o cientÃ­ficos.
Sin embargo, en la actualidad cualquier dispositivo digital u ordenador domÃ©stico puede tener una CPU con mÃºltiples nÃºcleos, lo que los convierte en sistemas multiprocesador.</p>
</div>
<div class="paragraph">
<p>Las principales de ventajas de estos sistemas son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Aumentan la cantidad de trabajo realizado</strong>. A mayor nÃºmero de procesadores, mayor cantidad
de trabajo puede realizar el sistema.
Sin embargo debemos de tener en cuenta que un sistema con \$N\$ CPU no es un sistema \$N\$ veces mÃ¡s
rÃ¡pido.
Cuando varios procesadores cooperan para realizar una tarea, existe cierta pÃ©rdida de
rendimiento debida a los mecanismos de sincronizaciÃ³n requeridos para controlar el acceso a los recursos compartidos por los procesadores.</p>
</li>
<li>
<p><strong>EconomÃ­a de escala</strong>. Un sistema multiprocesador puede costar menos que mÃºltiples sistemas monoprocesadores conectados para hacer un trabajo equivalente, porque comparten perifÃ©ricos, almacenamiento, alimentaciÃ³n, etc.</p>
</li>
<li>
<p><strong>Alta disponibilidad</strong>. Con el hardware adecuado el sistema puede ser tolerante al fallo de uno de los procesadores.
En caso de fallo el sistema no se detendrÃ­a pero si trabajarÃ­a mÃ¡s despacio.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En la actualidad existen dos tipos de sistemas multiprocesador:</p>
</div>
<div id="smp" class="imageblock">
<div class="content">
<img src="C02-tipos_de_sistemas/images/multiprocesamiento_simÃ©trico.svg" alt="multiprocesamiento simÃ©trico">
</div>
<div class="title">Figura 6. Arquitectura de un sistema de multiprocesamiento simÃ©trico.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>En los <strong>sistemas de multiprocesamiento simÃ©trico</strong> o <strong>SMP</strong> (<em>Symmetric Multiprocessing</em>) todos los procesadores son iguales.
Todos comparten los mismos recursos, pueden acceder a los
mismos dispositivos (vÃ©ase la <a href="#smp">Figura 6</a>) y cada uno ejecuta una copia del nÃºcleo del sistema operativo.
El sistema operativo debe haber sido diseÃ±ado para saber repartir el trabajo entre los procesadores y compartir adecuadamente entre tareas y procesadores el resto de recursos del sistema.
Casi todos los sistemas multiprocesador modernos son de este tipo.</p>
</li>
<li>
<p>En los <strong>sistemas de multiprocesamiento asimÃ©trico</strong> o <strong>AMP</strong> (<em>Asymmetric Multiprocessing</em>) hay un procesador principal y varios secundarios a quienes el principal planifica y entrega las tareas que deben ejecutar.
En ocasiones los procesadores secundarios se distinguen del principal por haber sido diseÃ±ados para realizar algÃºn tipo concreto de tareas de forma muy eficiente o por estar conectadas a hardware especial.
Ejemplos de esto son las <a href="https://es.wikipedia.org/wiki/Unidad_de_procesamiento_gr%C3%A1fico">GPU</a>, que no son sino procesadores diseÃ±ados especÃ­ficamente para el procesamiento de grÃ¡ficos, o las CPU de E/S conectadas a
discos duros para gestionarlos de forma mÃ¡s eficiente.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un ejemplo bastante ilustrativo es el de <a href="https://es.wikipedia.org/wiki/Cell_(microprocesador)">Cell</a>, la CPU de PlayStation 3.
TenÃ­a un nÃºcleo principal de propÃ³sito general y 8 nÃºcleos optimizados para ejecutar de forma muy eficiente operaciones vectoriales.
Con la ayuda del sistema operativo, los programas debÃ­an envÃ­an tareas matemÃ¡ticamente intensivas a los procesadores secundarios, si querÃ­an extraer el mÃ¡ximo provecho de la arquitectura.</p>
</div>
<div class="paragraph">
<p>Desarrollar para un sistema asÃ­ es mÃ¡s complejo.
Por lo que, aunque sobre el papel esta arquitectura ofrecÃ­a gran rendimiento, aprovecharlo era un verdadero reto para los desarrolladores.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_distribuidos">2.5. Sistemas distribuidos</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En la actualidad es comÃºn el uso de redes para interconectar ordenadores individuales âpor ejemplo Internet o la red de Ã¡rea local de una oficinaâ cada uno equipado con su procesador, su memoria, sus dispositivos de almacenamiento, su fuente de alimentaciÃ³n, etc.
En las redes de ordenadores los procesadores de dichos ordenadores se comunican con otros procesadores a travÃ©s de lÃ­neas de comunicaciÃ³n, como: redes Ethernet, lÃ­neas telefÃ³nicas o wifi.
Estos sistemas son comÃºnmente denominados <strong>sistemas distribuidos</strong>.</p>
</div>
<div class="paragraph">
<p>Sin entrar en detalles, los sistemas distribuidos pueden ser clasificados en <strong>sistemas cliente-servidor</strong> y <strong>sistemas de redes entre iguales</strong>.</p>
</div>
<div class="sect3">
<h4 id="_sistemas_cliente_servidor">2.5.1. Sistemas cliente-servidor</h4>
<div class="paragraph">
<p>En los <strong>sistemas cliente-servidor</strong>  existen ordenadores que actÃºan como <strong>servidores</strong> encargados de satisfacer las peticiones generadas por otros ordenadores que actÃºan como <strong>clientes</strong>.</p>
</div>
<div class="paragraph">
<p>Este tipo de sistemas han sustituido, en un gran nÃºmero de casos, a los terminales conectados a <em>mainframes</em>, debido a que los sistemas de escritorio son cada vez mÃ¡s potentes y baratos.
Concretamente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los terminales han sido sustituidos por sistemas de escritorio que, al disponer de mÃ¡s recursos, son capaces de realizar muchas de las funcionalidades que anteriormente eran manejadas directamente por los <em>mainframes</em>.</p>
</li>
<li>
<p>Al mismo tiempo estos <em>mainframes</em> se han reemplazado por servidores, no muy diferentes a los sistemas de escritorios, pero preparados para atender las peticiones de sus clientes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ejemplos de este este tipo de sistemas son los servidores de base de datos, que responden a las consultas SQL de los clientes, o los servidores de archivos, que proporcionan una interfaz de sistema de archivos con la que los clientes pueden crear, leer, escribir y borrar archivos en el servidor; de forma similar a como si estuvieran almacenados localmente en el propio cliente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_de_redes_entre_iguales">2.5.2. Sistemas de redes entre iguales</h4>
<div class="paragraph">
<p>En los <strong>sistemas de redes entre iguales</strong>   o <strong>P2P</strong> (<em>peer-to-peer</em>) clientes y servidores no se distinguen los unos de los otros.
Todos los nodos del sistema son iguales y cada uno puede actuar como cliente o servidor, dependiendo de cuÃ¡ndo piden o proporcionan un servicio.</p>
</div>
<div class="paragraph">
<p>La ventaja fundamental de este tipo de sistemas es que en los sistemas cliente-servidor el servidor puede ser el cuello de botella del rendimiento, pero en los sistemas de redes entre iguales la carga se distribuye entre todos los nodos de la red.
Ejemplos de este tipo de sistemas son las redes <a href="https://es.wikipedia.org/wiki/BitTorrent">BitTorrent</a> y <a href="https://es.wikipedia.org/wiki/Bitcoin">Bitcoin</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un servidor puede ser el cuello de botella no solo por su potencia sino tambiÃ©n por el ancho de banda de su conexiÃ³n a la red.
La potencia del servidor es lo de menos cuando se intenta distribuir en Internet archivos de gran tamaÃ±o âpor ejemplo imÃ¡genes de CD o DVDâ pues el problema es que varias descargas simultÃ¡neas pueden consumir todo el ancho de banda del servidor durante largos periodos de tiempo.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_sistemas_operativos_para_sistemas_distribuidos">2.5.3. Sistemas operativos para sistemas distribuidos</h4>
<div class="paragraph">
<p>Desde el punto de vista de los sistemas operativos para sistemas distribuidos es posible hacer la siguiente distinciÃ³n:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los <strong>sistemas operativos de red</strong>  ofrecen a las aplicaciones que corren sobre ellos servicios de acceso a redes de ordenadores.
Por ejemplo, implementan algÃºn mecanismo que permita a diferentes procesos en diferentes ordenadores enviar y recibir mensajes.
AdemÃ¡s suelen incorporar la opciÃ³n de proporcionar algunos servicios de red, como la comparticiÃ³n de archivos y dispositivos con otros equipos de la misma red.</p>
<div class="paragraph">
<p>Los ordenadores con sistemas operativos de red son autÃ³nomos.
Simplemente es que gracias al sistema operativo de red, conocen la existencia de la red y saben usarla para comunicarse con otros ordenadores de la misma.</p>
</div>
<div class="paragraph">
<p>Este tipo de sistemas operativos son los mÃ¡s utilizados en los tipos de sistemas distribuidos comentados anteriormente.
En la actualidad, la inmensa mayorÃ­a de sistemas de escritorio y dispositivos de mano utilizan sistemas operativos de red.</p>
</div>
</li>
<li>
<p>Los <strong>sistemas operativos distribuidos</strong>  crean en el usuario la ilusiÃ³n de que estÃ¡ en un Ãºnico ordenador, aunque en realidad el sistema operativo controla todos los ordenadores de la red, dando al usuario acceso transparente a los recursos en todos los equipos de la misma.</p>
<div class="paragraph">
<p>Con este tipo de sistemas operativos el usuario no sabe en quÃ© ordenador se ejecutan sus procesos, dÃ³nde se almacenan sus archivos, ni quÃ© equipo tiene conectado los distintos perifÃ©ricos a los que tiene acceso.</p>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Un ejemplo de sistema operativo distribuido es <a href="https://en.wikipedia.org/wiki/Amoeba_(operating_system)">Amoeba</a>, un sistema operativo distribuido de investigaciÃ³n escrito por Andrew S. Tanenbaum en Vrije Universiteit.
Para mÃ¡s informaciÃ³n, vÃ©ase el <a href="http://www.cs.vu.nl/pub/amoeba/">sitio web de Amoeba</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_en_cluster">2.6. Sistemas en cluster</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Como los sistemas distribuidos, los <strong>sistemas en <em>cluster</em></strong> interconectar ordenadores individuales.
Sin embargo generalmente se acepta que los <strong>sistemas en <em>cluster</em></strong> comparten el almacenamiento y estÃ©n conectados por medio de una red local, condiciones que no tienen por quÃ© darse en los sistemas distribuidos.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas en <em>cluster</em></strong> se utilizan para:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Obtener servicios con alta disponibilidad</strong>.
Para ello un nodo del <em>cluster</em> puede estar ejecutando un servicio mientras otro nodo lo monitoriza.
En caso de fallo en el nodo que da el servicio, el que lo monitoriza lo sustituye.</p>
<div class="paragraph">
<p>Si es necesario proporcionar varios servicios, el mecanismo anterior se puede extender repartiendo los servicios entre dos o mÃ¡s nodos y haciendo que se monitoricen entre ellos.</p>
</div>
</li>
<li>
<p><strong>ComputaciÃ³n de alto rendimiento</strong> o <strong>HPC</strong>.
En este caso todos los nodos se utilizan para dar un mismo servicio.
Un nodo especial, denominado balanceador de carga, tiene la responsabilidad de repartir el trabajo entre los nodos.</p>
<div class="paragraph">
<p>Este tipo de <strong>sistemas en <em>cluster</em></strong> se utiliza para realizar trabajos de cÃ¡lculo muy pesados, como simulaciones âpor ejemplo simulaciÃ³n meteorolÃ³gica, nuclear o de gestiÃ³n hospitalariaâ o romper sistemas de cifrado.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>TambiÃ©n es muy utilizado en servidores de Internet âcomo servidores web, correo electrÃ³nico o de mensajerÃ­a instantÃ¡neaâ o servidores de base de datos que deban dar
servicio a una gran cantidad de clientes simultÃ¡neamente.
En estos casos el balanceador de carga realiza su trabajo repartiendo las conexiones de los usuarios entre los servidores del <em>cluster</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_tiempo_real">2.7. Sistemas de tiempo real</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los <strong>sistemas de tiempo real</strong> se utilizan cuando existen requerimientos estrictos de tiempo en la ejecuciÃ³n de ciertas tareas o en el procesamiento de flujos de datos.</p>
</div>
<div class="paragraph">
<p>En general se usan frecuentemente en dispositivos de control donde, dentro de unos mÃ¡rgenes estrictos de tiempo, se deben tomar datos de uno o varios sensores, para analizarlos posteriormente y realizar, en consecuencia, alguna acciÃ³n con algÃºn mecanismo de control.
Por ejemplo, se suelen utilizar en sistemas de control industrial, domÃ³tica, armamento, automociÃ³n âen la inyecciÃ³n electrÃ³nica de combustible, sistemas de frenado y de control de tracciÃ³nâ o en dispositivos mÃ©dicos.</p>
</div>
<div class="paragraph">
<p>Los <strong>sistema de tiempo real</strong> estÃ¡n muy relacionados con los <strong>sistemas empotrados</strong>.
Estos Ãºltimos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se diseÃ±an para realizar tareas muy especÃ­ficas. No son sistemas de propÃ³sito general sino de propÃ³sito especÃ­fico.</p>
</li>
<li>
<p>Sus sistemas operativos tienen caracterÃ­sticas muy limitadas y no tienen que tener necesariamente una interfaz de usuario.</p>
</li>
<li>
<p>Estos sistemas estÃ¡n tanto en el motor de los automÃ³viles y los robots que los fabrican, como en reproductores de DVD, microondas o dispositivos de red.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los <strong>sistemas de tiempo real</strong> pueden ser clasificados en <strong>sistemas de tiempo real estricto</strong> y <strong>sistemas de tiempo real flexible</strong>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Los <strong>sistemas de tiempo real estricto</strong>  o <strong>hard real-time</strong> garantizan que las tareas serÃ¡n realizadas dentro de unos mÃ¡rgenes estrictos de tiempo.</p>
<div class="paragraph">
<p>Para ello, todas las situaciones imprevistas que puedan ocasionar retardos en el funcionamiento del sistema operativo deben estar perfectamente limitadas en tiempo.
Por lo tanto, suelen carecer de memoria virtual y de otras abstracciones que aÃ­slen al desarrollador del funcionamiento real del hardware ya que introducen impredecibilidad.</p>
</div>
<div class="paragraph">
<p>Los sistemas de tiempo real estricto no son compatibles con los sistemas de tiempo compartido.</p>
</div>
</li>
<li>
<p>Los <strong>sistemas de tiempo real flexible</strong>   o <strong>soft real-time</strong> son Ãºtiles cuando en un sistema operativo convencional hay tareas que tienen mayor importancia que el resto, por lo que deben ser realizadas con mayor prioridad.</p>
<div class="paragraph">
<p>El tiempo real flexible no sirve cuando se tienen tareas con limitaciones precisas de tiempo, porque no hay manera de garantizar que dichas restricciones se van a cumplir.
Sin embargo si es Ãºtil para tareas relacionadas con la multimedia, la realidad virtual, los videojuegos, etc. y es compatible con la memoria virtual y otras caracterÃ­sticas presentes en los sistemas de escritorio.
Por eso la mayor parte de los sistemas de escritorio actuales soportan tareas de tiempo real flexible.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_historia_de_los_sistemas_operativos">3. Historia de los sistemas operativos</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>19 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>La historia de los sistemas operativos se puede dividir en cinco grandes etapas o generaciones, obviamente conectadas con las generaciones de los ordenadores donde funcionaban.</p>
</div>
<div class="sect2">
<h3 id="_historia_primera_generaciÃ³n">3.1. 1Âª GeneraciÃ³n (1945-55)</h3>
<div class="paragraph">
<p>En la primera generaciÃ³n de ordenadores no se utilizaban sistemas operativos.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Sus principales caracterÃ­sticas son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Computadoras construidas con electrÃ³nica de <a href="https://es.wikipedia.org/wiki/V%C3%A1lvula_termoi%C3%B3nica">vÃ¡lvulas de vacÃ­o</a>.</p>
</li>
<li>
<p>Sin sistema operativo.</p>
</li>
<li>
<p>Sin lenguajes de programaciÃ³n.
Se programaban directamente en lenguaje mÃ¡quina.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Algunos ejemplos de ordenadores destacables fueron:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://es.wikipedia.org/wiki/ENIAC">ENIAC</a> (1945)</dt>
<dd>
<p>Se le considera el primer ordenador electrÃ³nico digital de propÃ³sito general, aunque existe cierta polÃ©mica sobre este punto.
Lo cierto es que se construyeron otros ordenadores antes que Ã©ste pero o no eran de propÃ³sito general âcomo las famosas computadoras <a href="https://es.wikipedia.org/wiki/Colossus">Colossus</a> (1944), que fueron diseÃ±adas para ayudar en <a href="https://es.wikipedia.org/wiki/Criptoan%C3%A1lisis">criptoanÃ¡lisis</a>â o no eran electrÃ³nicos sino electro-mecÃ¡nicos âcomo la computadora <a href="https://es.wikipedia.org/wiki/Z3">Z3</a> (1941), que usaba <a href="https://es.wikipedia.org/wiki/Rel%C3%A9">relÃ©s</a>â.</p>
<div class="paragraph">
<p>No era un producto comercial sino un proyecto experimental de defensa que principalmente se diseÃ±o y utilizÃ³ para calcular tablas de tiro de artillerÃ­a destinadas al Laboratorio de InvestigaciÃ³n BalÃ­stica del EjÃ©rcito de los Estados Unidos.</p>
</div>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/Z4">Z4</a> (1945) fue el primer ordenador digital comercial, pero era electro-mecÃ¡nico.</p>
</div>
</dd>
<dt class="hdlist1"><a href="https://es.wikipedia.org/wiki/IBM_701">IBM 701</a> (1953)</dt>
<dd>
<p>Fue el primer <em>mainframe</em> de la serie IBM 700, que a la larga se convertirÃ­a en un Ã©xito de ventas.
Utilizaba tubos de vacÃ­o y tarjetas perforadas.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El IBM 7090 âversiÃ³n transistorizada del 709, que utilizaba vÃ¡lvulas de vacÃ­o, como todos los de la serie 700â y el posterior 7094, fueron usados por la NASA para los cÃ¡lculos de control de las misiones de los programas espaciales Mercury y Gemini y durante la primera etapa del programa Apolo.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_historia_segunda_generaciÃ³n">3.2. 2Âª GeneraciÃ³n (1955-64)</h3>
<div class="paragraph">
<p>En la segunda generaciÃ³n de ordenadores los transistores reemplazan a las vÃ¡lvulas de vacÃ­o.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En lo que respecta a los sistemas operativos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Aparecen los monitores del sistema, que se pueden considerar un predecesor de los sistemas operativos.</p>
</li>
<li>
<p>Sistema de procesamiento por lotes.</p>
</li>
<li>
<p>Se comienzan a utilizar lenguajes de programaciÃ³n, como: ensamblador, FORTRAN y COBOL.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/GM-NAA_I/O">GM-NAA I/O</a> (<em>General Motors and North American Aviation Input/Output system</em>) fue el primer sistema operativo.
Fue desarrollado por General Motors Research Laboratory en 1956 para el <em>mainframe</em> <a href="https://en.wikipedia.org/wiki/IBM_704">IBM 704</a> con el fin de automatizar la carga y ejecuciÃ³n de un nuevo trabajo una vez habÃ­a terminado el anterior.
Para su desarrollo se basaron en un monitor del sistema creado en 1955 por programadores de General Motors para el IBM 701.</p>
</div>
<div id="instalaciÃ³n_ibm_702" class="imageblock">
<div class="content">
<img src="C03-historia/images/instalaciÃ³n_ibm_702.jpg" alt="instalaciÃ³n ibm 702">
</div>
<div class="title">Figura 7. InstalaciÃ³n de un mainframe IBM 702&#8201;&#8212;&#8201;Fuente: <a href="https://commons.wikimedia.org/wiki/File:BRL61-IBM_702.jpg">Wikipedia</a></div>
</div>
</div>
<div class="sect2">
<h3 id="_historia_tercera_generaciÃ³n">3.3. 3Âª GeneraciÃ³n (1965-1968)</h3>
<div class="paragraph">
<p>En la tercera generaciÃ³n se comenzaron a utilizar los circuitos integrados, que fue una invenciÃ³n de finales de la dÃ©cada de 1950.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En lo que respecta a los sistemas operativos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Aparecen los sistemas operativos multiprogramados.</p>
</li>
<li>
<p>Aparecen mÃ¡s lenguajes de programaciÃ³n.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>El ejemplo mÃ¡s destacado de esta Ã©poca es el <a href="https://en.wikipedia.org/wiki/OS/360_and_successors">IBM OS/260</a>
Fue un sistema operativo desarrollado por IBM para su <em>mainframe</em> <a href="https://en.wikipedia.org/wiki/IBM_System/360">IBM System/360</a> (S/360) (vÃ©ase la <a href="#instalaciÃ³n_ibm_system_360">Figura 8</a>).
Su versiÃ³n DOS/360 (<em>Disk Operating System/360</em>) fue el primer sistema operativo en hacer los discos magnÃ©ticos un requisito para poder operar.</p>
</div>
<div id="instalaciÃ³n_ibm_system_360" class="imageblock">
<div class="content">
<img src="C03-historia/images/instalaciÃ³n_ibm_system_360.jpg" alt="instalaciÃ³n ibm system 360">
</div>
<div class="title">Figura 8. InstalaciÃ³n de un mainframe IBM System/360&#8201;&#8212;&#8201;Fuente: <a href="http://www-03.ibm.com/ibm/history/ibm100/us/en/icons/system360/impacts/">IBM</a></div>
</div>
<div class="paragraph">
<p>Se anunciÃ³ en 1964 pero fue lanzado en 1966, con un aÃ±o de retraso respecto a la fecha prevista originalmente.
Los motivos fundamentales fueron ciertos problemas de organizaciÃ³n interna de la compaÃ±Ã­a y la falta de experiencia en proyectos de esa envergadura.
Las previsiones iniciales eran de 1 millÃ³n de lÃ­neas de cÃ³digo y miles de componentes de software.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Algunos autores fechan los inicios de la ingenierÃ­a del software en la publicaciÃ³n del libro Â«The Mythical Man-Month: Essays on Software EngineeringÂ», escrito por Frederick Brooks y publicado en 1975.
Frederick Brooks se basÃ³ en la experiencia adquirida mientras administraba el desarrollo del IBM OS/360, donde era jefe de proyecto.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_historia_cuarta_generaciÃ³n">3.4. 4Âª GeneraciÃ³n (1965-1980)</h3>
<div class="paragraph">
<p>La cuarta generaciÃ³n abarca desde mediados de los aÃ±os 60 hasta finales de la dÃ©cada de los 70.
Respecto a los ordenadores, es el resultado del desarrollo de los microprocesadores.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En lo que respecta a los sistemas operativos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Aparecen los sistemas operativos de tiempo compartido.</p>
</li>
<li>
<p>Aparecen los terminales, los programas interactivos y las mÃ¡quinas virtuales.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>A continuaciÃ³n veremos los ejemplos mÃ¡s representativos de esta Ã©poca.</p>
</div>
<div class="sect3">
<h4 id="_multics">3.4.1. MULTICS</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/Multics">MULTICS</a> fue anunciado en 1964, fruto de la colaboraciÃ³n entre el MIT, General Electrics y Bell Labs, como el primer sistema operativo de propÃ³sito general.</p>
</div>
<div id="multics_mainframe" class="imageblock">
<div class="content">
<img src="C03-historia/images/multics_mainframe.jpg" alt="multics mainframe">
</div>
<div class="title">Figura 9. Mainframe GE-6180 con sistema MULTICS, entorno a 1976 en el MIT&#8201;&#8212;&#8201;Fuente: <a href="http://www.multicians.org/multics-stories.html">Multicians</a></div>
</div>
<div class="paragraph">
<p>Fue el primer sistema operativo en proporcionar un sistema de archivos jerÃ¡rquico, intÃ©rprete de comandos implementado como programa de usuario, listas de control de acceso individuales para cada archivo y enlazado dinÃ¡mico, entre otras caracterÃ­sticas novedosas.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s experimentÃ³ con eliminar la separaciÃ³n entre el espacio de direcciones de los procesos y los archivos.
Es decir, como si todos los archivos estuvieran mapeados en memoria, permitiendo a los procesos acceder al contenido de los archivos directamente (vÃ©ase el <a href="#_archivos_mapeados_en_memoria">Apartado 17.6</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_vmcms">3.4.2. VM/CMS</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/VM_(sistema_operativo)">VM/CMS</a> es un sistema de IBM utilizado en los <em>mainframe</em> <a href="https://en.wikipedia.org/wiki/IBM_System/360">IBM System/360</a>, System/370, System/390 y zSeries.
VM es un <a href="https://es.wikipedia.org/wiki/Hipervisor">hipervisor</a> que se encarga de virtualizar el hardware para crear mÃºltiples mÃ¡quinas virtuales, dando la sensaciÃ³n de que cada una es un <em>mainframe</em> independiente.</p>
</div>
<div class="paragraph">
<p>Como sistema operativo de las maquinas virtuales, una opciÃ³n comÃºn es CMS, un sistema interactivo y monousuario muy ligero, diseÃ±ado para operar fundamentalmente en una mÃ¡quina virtual de VM.
Gracias a VM/CMS, cada usuario tiene la sensaciÃ³n de trabajar en un sistema completamente independiente y seguro.</p>
</div>
<div class="paragraph">
<p>El desarrollo de VM/CMS comenzÃ³ en 1965 y la primera versiÃ³n estuvo disponible a primeros de 1966.
Las versiones actuales se denominan IBM z/VM.</p>
</div>
</div>
<div class="sect3">
<h4 id="_unix">3.4.3. UNIX</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/Unix">UNIX</a> fue desarrollado originalmente por Bell Labs en 1970 para los sistemas <a href="https://es.wikipedia.org/wiki/PDP-11">PDP-11/20</a> (vÃ©ase la <a href="#dec_pdp11">Figura 10</a>).
La autorÃ­a del mismo se le atribuye a un grupo de programadores, liderados por Ken Thompson, que decidieron rehacer el trabajo de MULTICS pero a menor escala; despuÃ©s de que Bell Labs abandonara el proyecto MULTICS en 1969.
Inicialmente se llamÃ³ UNICS y fue desarrollado para los sistemas PDP-7.</p>
</div>
<div id="dec_pdp11" class="imageblock">
<div class="content">
<img src="C03-historia/images/dec_pdp11_ken_den.jpg" alt="dec pdp11 ken den">
</div>
<div class="title">Figura 10. Dennis Ritchie (de pie) y Ken Thompson (sentado) frente a un PDP-11 y sus dos terminales <a href="https://en.wikipedia.org/wiki/Teletype_Model_33">Teletype 33</a>&#8201;&#8212;&#8201;Fuente: <a href="https://www.bell-labs.com/usr/dmr/www/picture.html">Dennis Ritchie</a></div>
</div>
<div class="paragraph">
<p>La primer versiÃ³n de UNIX fue implementada en ensamblador, como era comÃºn en la Ã©poca.
Posteriormente, Dennis Ritchie y Brian Kernighan diseÃ±aron un nuevo lenguaje de programaciÃ³n llamado Â«CÂ», especialmente pensado para que UNIX fuera escrito con Ã©l.
Eso facilitÃ³ que UNIX pudiera ser portado a ordenadores diferentes.
AdemÃ¡s, gracias al lenguaje C, el cÃ³digo era mÃ¡s conciso y compacto, lo que se tradujo en que se pudieron desarrollar nuevas funcionalidades mÃ¡s rÃ¡pidamente.</p>
</div>
<div class="paragraph">
<p>AT&amp;T, la compaÃ±Ã­a matriz de Bell Labs, no podÃ­a competir en la industria de los ordenadores, por lo que puso el cÃ³digo fuente de UNIX a disposiciÃ³n de universidades, compaÃ±Ã­as privadas y del gobierno de los Estados Unidos.
Eso aumento su difusiÃ³n y dio resultados inesperados.
Por ejemplo, una de las variantes mÃ¡s importantes de UNIX fue <a href="https://es.wikipedia.org/wiki/Berkeley_Software_Distribution">BSD</a>, desarrollada por la Universidad de California en Berkeley.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>La versiÃ³n 4.2BSD (<em>Berkeley Software Distribution</em>) de esta variante de UNIX fue la primera que incluyÃ³ la interfaz de <em>sockets</em> para facilitar la comunicaciÃ³n entre procesos a travÃ©s de Internet y otras redes.
Esta interfaz se ha convertido en estÃ¡ndar en prÃ¡cticamente cualquier sistemas operativo.</p>
</div>
<div class="paragraph">
<p>TambiÃ©n implementÃ³ y ayudÃ³ a difundir el estÃ¡ndar de comunicaciones TCP/IP, base de la actual Internet.
Muchos sistemas operativos actuales, tanto libres como privativos, utilizan cÃ³digo de BSD en su implementaciones de los protocolos TCP/IP y de diversas utilidades de red.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En la actualidad se considera que hay dos grandes familias de UNIX y las distintas variantes pertenecen a una u otra en funciÃ³n del UNIX del que derivaron originalmente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La familia derivada de <strong>AT&amp;T UNIX System V</strong>, en la que se incluyen sistemas operativos no libres, tales como: <a href="https://es.wikipedia.org/wiki/SCO_OpenServer">SCO OpenServer</a>, <a href="https://es.wikipedia.org/wiki/Solaris_(sistema_operativo)">Oracle/Sun Microsystems Solaris Operating Environment</a> y <a href="https://es.wikipedia.org/wiki/UnixWare">SCO UnixWare</a>.</p>
</li>
<li>
<p>La familia derivada de <strong>BSD</strong>, en la que se incluyen sistemas libres como: <a href="https://es.wikipedia.org/wiki/FreeBSD">FreeBSD</a>, <a href="https://es.wikipedia.org/wiki/NetBSD">NetBSD</a>, <a href="https://es.wikipedia.org/wiki/OpenBSD">OpenBSD</a>, <a href="https://en.wikipedia.org/wiki/Darwin_(operating_system)">Darwin</a> y <a href="https://es.wikipedia.org/wiki/DragonFly_BSD">DragonFly BSD</a>, entre muchos otros.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/FreeBSD">FreeBSD</a> es el sistema base de algunos sistemas no libres.
Por ejemplo, <a href="https://en.wikipedia.org/wiki/Darwin_(operating_system)">Darwin</a> es el sistema operativo en el que se basan los sistemas operativos de Apple: macOS, IOS, watchOS, tvOS e iPadOS.
A su vez Darwin utiliza mÃºltiples elementos de FreeBSD (vÃ©ase el <a href="#_mach">Apartado 3.5.8</a>).</p>
</div>
<div class="paragraph">
<p>Otro ejemplo destacable es <a href="https://en.wikipedia.org/wiki/PlayStation_4_system_software">Orbis OS</a> âel sistema operativo de PlayStation 4â que tambiÃ©n estÃ¡ basado en FreeBSD.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_vms">3.4.4. VMS</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/OpenVMS">VMS</a> es un sistema operativo de 32 bits diseÃ±ado originalmente por Digital Equipment Corporation (DEC) âahora propiedad de HPâ en 1978 para usarlo en minicomputadoras <a href="https://es.wikipedia.org/wiki/VAX">VAX</a>.
Posteriormente fue portado a sistemas DEC Alpha e Intel Itanium.</p>
</div>
<div id="dec_vax11" class="imageblock">
<div class="content">
<img src="C03-historia/images/dec_vax11.jpg" alt="dec vax11">
</div>
<div class="title">Figura 11. InstalaciÃ³n de VAX 11/780 en 1980&#8201;&#8212;&#8201;Fuente: <a href="http://www.chilton-computing.org.uk/">Science and Technology Facilities Council</a></div>
</div>
<div class="paragraph">
<p>Las siglas VMS vienen de <em>Virtual Memory System</em>, ya que una de sus principales caracterÃ­sticas era explotar el concepto de <strong>memoria virtual</strong>.
Este concepto tambiÃ©n es muy utilizando en los sistemas operativos modernos.
Permite que los procesos se ejecuten aislados, unos de otros, en la memoria principal y sin tener que ser cargados completamente, lo que permite que cada uno consuma memos memoria.</p>
</div>
<div class="paragraph">
<p>VMS era un sistema multiusuario y multiprocesador que podÃ­a distribuir el trabajo entre varias mÃ¡quinas, lo que le permitÃ­a ser tolerante a fallos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>VMS es en cierta medida un ancestro de Microsoft Windows NT (vÃ©ase el <a href="#_windows_nt">Apartado 3.5.6</a>).
Para desarrollar Windows NT, Microsoft contratÃ³ a un grupo de desarrolladores de Digital Equipment Corporation.
Muchos aspectos del diseÃ±o de Windows NT reflejan la experiencia de DEC en VMS.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_ibm_os400">3.4.5. IBM OS/400</h4>
<div class="paragraph">
<p>El <a href="https://es.wikipedia.org/wiki/OS/400">IBM OS/400</a> es un sistema utilizado en la familia de minicomputadoras <a href="https://es.wikipedia.org/wiki/AS/400">IBM AS/400</a> âllamada iSeries desde 2006â.
Fueron introducidos en el mercado en 1988, pero aÃºn es posible verlos en algunas organizaciones.
En 2008 el sistema operativo IBM OS/400 pasÃ³ a llamarse IBM i y siguen publicÃ¡ndose nuevas versiones en la actualidad.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_5Âº_generaciÃ³n_desde_1980">3.5. 5Âº GeneraciÃ³n (desde 1980):</h3>
<div class="paragraph">
<p>Esta Ãºltima generaciÃ³n abarca desde la dÃ©cada de 1980 hasta la actualidad.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Respecto a los sistemas operativos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Incluye a los sistemas operativos de escritorio y ordenadores personales (PC).</p>
</li>
<li>
<p>Aparecen mÃºltiples conceptos nuevos: monousuario, multitarea, distribuidos, paralelos, tiempo real, etc.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Se puede observar una muestra de la interfaz grÃ¡fica de usuario de algunos estos sistemas en el artÃ­culo <a href="https://www.webdesignerdepot.com/2009/03/operating-system-interface-design-between-1981-2009/">Â«Operating System Interface Design Between 1981-2009Â»</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_cpm">3.5.1. CP/M</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/CP/M">CP/M</a> (1974) fue el sistema operativo estÃ¡ndar en la primera generaciÃ³n de microcomputadoras. Fue creado por Digital Research, Inc. âfundada por Gary Kildallâ para ser el sistema operativo de los microordenadores basados en <a href="https://es.wikipedia.org/wiki/Intel_8080">Intel 8080/85</a> y <a href="https://es.wikipedia.org/wiki/Zilog_Z80">Zilog Z80</a>.</p>
</div>
<div class="paragraph">
<p>Con la elecciÃ³n de MS-DOS por parte de IBM para su <a href="https://es.wikipedia.org/wiki/IBM_PC">IBM PC</a>, CP/M fue perdiendo mercado paulatinamente hasta desaparecer.
Sin embargo, la influencia de CP/M en MS-DOS es indudable, en tanto en cuanto 86-DOS, el predecesor de MS-DOS, estaba basado en las ideas de CP/M.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ms_dos">3.5.2. MS-DOS</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/MS-DOS">MS-DOS</a> fue el sistema operativo estÃ¡ndar en la segunda generaciÃ³n de microcomputadoras.
No era ni multitarea ni multiusuario.
Fue el primer sistema operativo del <a href="https://es.wikipedia.org/wiki/IBM_PC">IBM PC</a> âlanzado en 1981â y durante mucho tiempo fue ampliamente utilizado en toda la plataforma Â«PC compatibleÂ».</p>
</div>
<div class="paragraph">
<p>MS-DOS fue creado por Seattle Computer Products (SCP) con el nombre de <a href="https://es.wikipedia.org/wiki/QDOS">86-DOS</a> en 1979.
Se basaron en ideas de CP/M, pues pretendÃ­an ofrecer una versiÃ³n de CP/M para procesadores <a href="https://es.wikipedia.org/wiki/Intel_8086_y_8088">Intel 8086</a>.
Inicialmente era conocido como QDOS (<em>Quick and Dirty Operating System</em>) pero SCP le cambiÃ³ el nombre en 1980, cuando comenzaron al licenciarlo.
Posteriormente Microsoft adquiriÃ³ el sistema y lo vendiÃ³ a IBM en 1981 con el nombre de MS-DOS.</p>
</div>
<div class="paragraph">
<p>Tanto IBM como Microsoft lanzaron versiones de DOS, aunque originalmente IBM solamente validaba y empaquetaba el software de Microsoft.
Microsoft lanzaba sus versiones bajo el nombre de MS-DOS, mientras IBM las lanzaba bajo el nombre de <a href="https://es.wikipedia.org/wiki/IBM_PC_DOS">IBM PC-DOS</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En <a href="https://www.pcjs.org/">PCjs</a> se pueden probar de forma sencilla sistemas operativos y aplicaciones antiguas del IBM PC.
Solo hace falta acceder con el navegador y elegir la experiencia que mÃ¡s nos llame la atenciÃ³n.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_os2">3.5.3. OS/2</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/OS/2">OS/2</a> fue un sistema operativo creado por Microsoft e IBM para aprovechar las nuevas caracterÃ­sticas de la segunda generaciÃ³n de ordenadores personales de IBM, equipados con procesador <a href="https://es.wikipedia.org/wiki/Intel_80286">Intel 80286</a>.
Pero al final terminÃ³ siendo desarrollado en exclusiva por IBM.</p>
</div>
<div class="paragraph">
<p>OS/2 fue pensado como un sucesor con <strong>operaciÃ³n en modo dual</strong> de MS-DOS y de Microsoft Windows 2.0.
Fue anunciado en abril y lanzado en diciembre de 1987 como un sistema operativo en modo texto.
En la versiÃ³n 1.1, lanzada en noviembre de 1988, se le aÃ±adiÃ³ interfaz grÃ¡fica.</p>
</div>
<div id="os_2_1" class="imageblock">
<div class="content">
<img src="C03-historia/images/os_2_1.png" alt="os 2 1">
</div>
<div class="title">Figura 12. Panel de control de Microsoft-IBM OS/2 1.1&#8201;&#8212;&#8201;Fuente: Michal Necasek</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En los sistemas con <strong>operaciÃ³n en modo dual</strong> se distingue entre dos modos de ejecuciÃ³n, de tal forma que solo en el modo en el que se ejecuta el cÃ³digo del sistema operativo se pueden realizar operaciones peligrosas.
En el otro modo y con menos privilegios, se ejecutan las aplicaciones de usuario.
Para mÃ¡s informaciÃ³n, vÃ©ase el <a href="#_operaciÃ³n_en_modo_dual">Apartado 7.2</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>La colaboraciÃ³n entre IBM y Microsoft terminÃ³ en 1990, entre el lanzamiento de Windows 3.0 y la de OS/2 1.3.
El aumento de popularidad de Windows llevo a Microsoft a dejar de centrarse en el desarrollo de OS/2, lo que hizo que IBM se preocupara por los continuos retrasos en el desarrollo de OS/2 2.0.
Inicialmente ambas compaÃ±Ã­as acordaron que IBM tomarÃ­a el mantenimiento de OS/2 1.0 y el desarrollo de OS/2 2.0, mientras Microsoft continuarÃ­a desarrollando OS/2 3.0, que entonces era conocido como Â«NT OS/2Â».
Sin embargo Microsoft finalmente decidiÃ³ renombrar NT OS/2 como Windows NT, dejando el futuro desarrollo de OS/2 en manos de IBM.</p>
</div>
<div class="paragraph">
<p>OS/2 Warp 3 fue un sistema completo de 32 bits lanzado en 1994.
Le seguirÃ­a OS/2 Warp 4, en 1996.
Poco despuÃ©s, IBM anunciÃ³ que OS/2 desaparecerÃ­a.</p>
</div>
</div>
<div class="sect3">
<h4 id="_windows_3_x">3.5.4. Windows 3.x</h4>
<div class="paragraph">
<p>La familia <a href="https://es.wikipedia.org/wiki/Windows_3.1x">Windows 3.x</a> de Microsoft Windows fue desarrollada desde 1990 hasta 1994.
Windows 3.0 fue la primera versiÃ³n de Ã©xito de Windows, permitiendo a Microsoft competir con el <a href="https://es.wikipedia.org/wiki/Macintosh">Macintosh</a> de Apple Computer y el <a href="https://es.wikipedia.org/wiki/Commodore_Amiga">Commodore Amiga</a>.</p>
</div>
<div id="windows_30" class="imageblock">
<div class="content">
<img src="C03-historia/images/windows_30.png" alt="windows 30">
</div>
<div class="title">Figura 13. Administrador de programas de Microsoft Windows 3.0&#8201;&#8212;&#8201;Fuente: <a href="https://guidebookgallery.org/screenshots/win30">Guidebook</a></div>
</div>
<div class="paragraph">
<p>En 1983, Microsoft anunciÃ³ el desarrollo de Windows, una interfaz grÃ¡fica de usuario para su sistema MS-DOS, que se usaba en los IBM PC y compatibles desde 1981.
Windows requerÃ­a una instalaciÃ³n previa de MS-DOS y era iniciado como un programa mÃ¡s, que podÃ­a ser terminado en cualquier momento, devolviendo al usuario a la lÃ­nea de comandos de MS-DOS.</p>
</div>
<div class="paragraph">
<p>MS-DOS le proporcionaba a Windows controladores de dispositivo para ciertas tareas, como el acceso al CD-ROM o a la interfaz de red.
Sin embargo Windows ejecutaba aplicaciones especificas de Windows, almacenadas en un formato ejecutable mucho mÃ¡s complejo que el de los programas de MS-DOS.
AdemÃ¡s, debido a que MS-DOS no aislaba a las aplicaciones del hardware y no se protegÃ­a asÃ­ mismo de los errores en dichas aplicaciones, Windows disponÃ­a de controladores de dispositivo propios, asÃ­ como sus propios sistemas de gestiÃ³n de procesos y de memoria.
En realidad Windows no se ejecutaba sobre MS-DOS, sino que hacÃ­a uso de Ã©l.
Por ello puede ser considerado como un sistema operativo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_windows_95_98_me">3.5.5. Windows 95, 98, Me</h4>
<div class="paragraph">
<p>La familia Windows 3.x fue sustituida por una serie de sistemas operativos grÃ¡ficos hÃ­bridos de 16/32 bits.</p>
</div>
<div id="windows_95" class="imageblock">
<div class="content">
<img src="C03-historia/images/windows_95.png" alt="windows 95">
</div>
<div class="title">Figura 14. Escritorio de Microsoft Windows 95&#8201;&#8212;&#8201;Fuente: <a href="http://www.guidebookgallery.org/screenshots/win95">Guidebook</a></div>
</div>
<div class="paragraph">
<p>Windows 95 fue lanzado en 1995.
Fue el primer Windows unido a una versiÃ³n de MS-DOS especÃ­fica, aunque este hecho se intentaba mantener oculto.
Entre las caracterÃ­sticas de Windows 95 destacan: mejoras significativas en la interfaz de usuario (vÃ©ase la <a href="#windows_95">Figura 14</a>), nombres de archivo de hasta 256 caracteres con conservaciÃ³n de mayÃºsculas y minÃºsculas âen MS-DOS el lÃ­mite era de 8 caracteres para el nombre mÃ¡s 3 de extensiÃ³nâ y multitarea expropiativa para las aplicaciones de 32 bits.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Como veremos en el <a href="#_planificaciÃ³n_expropiativa">Apartado 14.1</a>, la planificaciÃ³n expropiativa es una tÃ©cnica que permite al sistema operativo expulsar de la CPU a los procesos en ciertas circunstancias; como, por ejemplo, que lleven demasiado tiempo utilizando la CPU de forma ininterrumpida.</p>
</div>
<div class="paragraph">
<p>En la familia Windows 3.x la planificaciÃ³n era cooperativa, es decir, los procesos abandonaban la CPU voluntariamente.
Esto ocasionaba problemas con programas que no devolvÃ­a la CPU al sistema con la suficiente frecuencia, ya que asÃ­ el resto de procesos no tenÃ­a ocasiÃ³n de ejecutarse para hacer su trabajo o responder al usuario.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Windows 98 fue lanzado el 25 de junio de 1998.
Le siguiÃ³ Windows Me, el 14 de septiembre de 2000.
Windows Me fue la Ãºltima versiÃ³n de la familia de sistemas operativos hÃ­bridos de 16/32 bits que sucediÃ³ a la familia Windows 3.x.</p>
</div>
</div>
<div class="sect3">
<h4 id="_windows_nt">3.5.6. Windows NT, 2000, XP, Vista, 7, 8 y 10</h4>
<div class="paragraph">
<p>Windows NT fue un sistema operativo de 32 bits.
El primero de la familia de sistemas operativos Microsoft Windows actuales.</p>
</div>
<div class="paragraph">
<p>Su desarrollo empezÃ³ en 1988 con el nombre de OS/2 3.0.
Cuando Windows 3.0 fue lanzado en mayo de 1990, tuvo tanto Ã©xito que Microsoft decidiÃ³ cambiar la API del aÃºn en desarrollo NT OS/2 âque era como Microsoft lo llamaba entoncesâ pasando de ser una versiÃ³n extendida de la API de OS/2 a una versiÃ³n extendida de la API de Windows 3.0.
Esta decisiÃ³n causÃ³ tensiÃ³n entre Microsoft e IBM y provocÃ³ que finalmente la colaboraciÃ³n terminara.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Una interfaz de programaciÃ³n de aplicaciones o API (del inglÃ©s <em>Application Programming Interface</em>) es el conjunto de funciones, procedimientos o mÃ©todos que ofrece el sistema operativo para ser utilizado por las aplicaciones.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como hemos comentado anteriormente, Microsoft contratÃ³ a un grupo de desarrolladores de Digital Equipment Corporation para crear Windows NT.
Por lo que muchos de sus elementos reflejan la experiencia anterior de DEC en VMS.</p>
</div>
<div class="paragraph">
<p>Windows NT soportaba varias API de distintos sistemas operativos âpor ejemplo Win32, POSIX y OS/2 2.1â que eran implementadas como subsistemas encima de un API nativo no documentado pÃºblicamente.
Esta estructura en subsistemas, fue lo que permitiÃ³ la adopciÃ³n tardÃ­a de la API de Windows 3.0 como API principal, tal y como hemos comentado.</p>
</div>
<div class="paragraph">
<p>La primera versiÃ³n âWindows NT 3.1â lanzada el 13 de julio de 1993, era un sistema operativo <em>microkernel</em> (vÃ©ase el <a href="#_mach">Apartado 3.5.8</a> un poco mÃ¡s adelante) multiplataforma que corrÃ­a sobre procesadores <a href="https://es.wikipedia.org/wiki/IA-32">x86</a>, <a href="https://es.wikipedia.org/wiki/DEC_Alpha">DEC Alpha</a>, <a href="https://es.wikipedia.org/wiki/MIPS_(procesador)">MIPS R4000</a> y <a href="https://es.wikipedia.org/wiki/PowerPC">PowerPC</a>.</p>
</div>
<div class="paragraph">
<p>Windows NT 4.0 âlanzado en 1996â fue la Ãºltima versiÃ³n en soportar plataformas distintas a Intel IA-32.
Aunque el desarrollo de Windows 2000 para procesador Alpha continuÃ³ un poco mÃ¡s, hasta 1999, cuando Compaq dejÃ³ de soportar Windows NT en esa arquitectura.
AdemÃ¡s Windows NT 4.0 integrÃ³ en el nÃºcleo mÃ¡s funciones âpor ejemplo, parte del subsistema grÃ¡ficoâ para obtener un rendimiento mÃ¡s prÃ³ximo al de Windows 95 en ese apartado.</p>
</div>
<div class="paragraph">
<p>Windows 2000 âo Windows NT 5.0â fue lanzado en el 17 de febrero de 2000 y fue el primer sistema operativo de la familia NT al que se le eliminaron las siglas del nombre.
Fue por motivos de marketing, para favorecer la unificaciÃ³n de las dos familias de sistemas operativos Microsoft Windows de entonces âWindows 9x y Windows NTâ alrededor de la tecnologÃ­a NT.</p>
</div>
<div class="paragraph">
<p>Windows XP âo Windows NT 5.1â completÃ³ en 2001 el proceso de unificaciÃ³n de las dos familias de sistemas operativos Windows.
Con su apariciÃ³n forzÃ³ la extinciÃ³n de la familia Windows 9x, al sustituirla con una versiÃ³n de Windows XP denominada Windows XP Home Edition, especÃ­fica para la informÃ¡tica domÃ©stica.</p>
</div>
</div>
<div class="sect3">
<h4 id="_gnulinux">3.5.7. GNU/Linux</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/GNU/Linux">GNU/Linux</a> es un sistema operativo libre y, tal vez, el mÃ¡s famoso proyecto de <a href="https://es.wikipedia.org/wiki/Software_libre">software libre</a>.</p>
</div>
<div class="paragraph">
<p>El proyecto GNU se iniciÃ³ en 1983, con el fin de desarrollar un sistema operativo estilo UNIX enteramente libre.
El proyecto incluÃ­a la creaciÃ³n de herramientas de desarrollo de software y aplicaciones de usuario.</p>
</div>
<div class="paragraph">
<p>Mucho tiempo despuÃ©s, el estudiante universitario finÃ©s Linus Torvalds comenzÃ³ a desarrollar el nÃºcleo Linux como hobby, mientras estudiaba en la Universidad de Helsinki.
Torvalds originalmente usaba <a href="https://es.wikipedia.org/wiki/MINIX">Minix</a>, un sistema operativo simplificado escrito por Andrew Tanenbaum para enseÃ±ar diseÃ±o de sistemas operativos.
Sin embargo, el hecho de que Tanenbaum no diera soporte a las mejoras del sistema operativo que eran propuestas por otros desarrolladores, llevÃ³ a Torvalds a escribir un sustituto de MINIX.</p>
</div>
<div class="paragraph">
<p>En 1991, cuando se liberÃ³ la primera versiÃ³n del nÃºcleo Linux, el proyecto GNU habÃ­a desarrollado todos los componentes necesarios del sistema operativo excepto el nÃºcleo.
Torvalds y otros desarrolladores rÃ¡pidamente adaptaron Linux para que funcionara con los componentes de GNU, creando un sistema operativo completamente funcional que se denomina GNU/Linux.</p>
</div>
<div class="paragraph">
<p>El nÃºcleo Linux fue licenciado bajo la GNU General Public License (GPL), como el resto del proyecto GNU.
Pero Linux no es parte de dicho proyecto.
El proyecto GNU tiene su propio nÃºcleo, denominado <a href="https://es.wikipedia.org/wiki/GNU_Hurd">GNU/Hurd</a>, que lleva 30 aÃ±os en desarrollo y parece que aun estÃ¡ muy lejos de estar listo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>GNU no es el Ãºnico sistema operativo que utiliza el nÃºcleo Linux.
<a href="https://es.wikipedia.org/wiki/Android">Android</a>, por ejemplo, es un sistema operativo que usa el nÃºcleo Linux pero no es GNU.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_mach">3.5.8. Mach</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/Mach_(n%C3%BAcleo)">Mach</a> es un nÃºcleo de sistema operativo desarrollado en la Universidad Carnegie-Mellon (CMU).
El proyecto en la CMU se desarrollÃ³ desde 1985 hasta 1994.</p>
</div>
<div class="paragraph">
<p>Mach explora el concepto que denominamos <strong><em>microkernel</em></strong>.
En los sistemas operativos <strong><em>microkernel</em></strong> solo se implementa en el nÃºcleo del sistema un conjunto mÃ­nimo de servicios bÃ¡sicos.
El resto de los servicios proporcionados por el sistema operativo se implementan como procesos con menos privilegios.</p>
</div>
<div class="paragraph">
<p>Por sus ventajas en cuanto a seguridad y fiabilidad, en algÃºn momento se pensÃ³ que los <em>microkernel</em> dominarÃ­an el universo de los sistema operativos.
Sin embargo, el mayor esfuerzo hasta la fecha para conseguirlo es <a href="https://es.wikipedia.org/wiki/GNU_Hurd">GNU/Hurd</a>, que lleva varias dÃ©cadas de retraso.
Por fortuna, otros sistemas operativos <em>microkernel</em> han tenido algo mÃ¡s Ã©xito, como es el caso de <a href="https://es.wikipedia.org/wiki/QNX">QNX</a> o <a href="https://en.wikipedia.org/wiki/MINIX_3">MINIX 3</a>.
Mientras que Google parece que lo va a intentar con <a href="https://es.wikipedia.org/wiki/Google_Fuchsia">Google Fuchsia</a>, el posible sustituto de Android.</p>
</div>
<div class="paragraph">
<p>A mediados de los 90, Apple Computers seleccionÃ³ <a href="https://es.wikipedia.org/wiki/NEXTSTEP">OpenStep</a> como base para el sucesor de su clÃ¡sico <a href="https://es.wikipedia.org/wiki/Mac_OS_Classic">Mac OS</a>.
OpenStep es realmente una versiÃ³n actualizada de NeXTSTEP que era un sistema basado en un nÃºcleo Mach 2.5 con porciones del sistema BSD de la Universidad de Berkeley.
Por tanto, la mezcla de Mach con BSD de OpenStep es la base del sistema operativo <a href="https://es.wikipedia.org/wiki/MacOS">macOS</a> actual de Apple.</p>
</div>
<div id="openstep_42" class="imageblock">
<div class="content">
<img src="C03-historia/images/openstep_42.png" alt="openstep 42">
</div>
<div class="title">Figura 15. Entorno grÃ¡fico de OpenStep 4.2&#8201;&#8212;&#8201;Fuente: <a href="https://guidebookgallery.org/screenshots/openstep42">Guidebook</a></div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Para ser exactos, la base del sistema operativo macOS es un sistema operativo libre denominado <a href="https://en.wikipedia.org/wiki/Darwin_(operating_system)">Darwin</a> y desarrollado por Apple .
Se trata de un sistema <a href="https://es.wikipedia.org/wiki/FreeBSD">FreeBSD</a> adaptado para correr sobre el nÃºcleo Mach.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="C03-historia/images/historia_sistemas_operativos.svg" alt="historia sistemas operativos">
</div>
<div class="title">Figura 16. LÃ­nea de tiempo de la historia de los sistemas operativos.</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="_organizaciÃ³n_de_los_sistemas_operativos" class="sect0">Parte II: OrganizaciÃ³n de los sistemas operativos</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>El estudio de la organizaciÃ³n interna de los sistemas operativos requiere del anÃ¡lisis de tres aspectos diferentes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los componentes del sistema operativo y sus interrelaciones.</p>
</li>
<li>
<p>Los servicios que el sistema operativo proporciona a travÃ©s del funcionamiento coordinado de dichos componentes.</p>
</li>
<li>
<p>La interfaz de programaciÃ³n que el sistema operativo ofrece a usuarios y programadores como forma de acceso a dichos servicios.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>TambiÃ©n veremos como como se categorizan los sistemas operativos segÃºn la forma en la que se interconectan sus componentes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_componentes_del_sistema">4. Componentes del sistema</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>11 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Crear un software tan complejo como un sistema operativo no es sencillo, por ello resulta mÃ¡s prÃ¡ctico dividirlo en piezas mÃ¡s pequeÃ±as especializadas en aspectos concretos de la gestiÃ³n del sistema.</p>
</div>
<div class="paragraph">
<p>Cada sistema operativo tiene diferentes componentes con distinto nombre.
Lo que veremos en este capÃ­tulo es un esquema de los mÃ¡s comunes a la mayorÃ­a de sistemas operativos actuales.</p>
</div>
<div class="sect2">
<h3 id="_gestiÃ³n_de_procesos">4.1. GestiÃ³n de procesos</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La gestiÃ³n de los procesos es un elemento central de todo sistema operativo:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>El <strong>proceso</strong> es la unidad de trabajo en cualquier sistema operativo moderno.
Es quiÃ©n realiza las tareas que interesan a los usuarios.
Por eso, es a cada proceso al que se le asigna el tiempo de CPU y el resto de recursos del sistema, como por ejemplo: memoria, archivos o dispositivos de E/S abiertos.</p>
</li>
<li>
<p>Un <strong>proceso</strong> es un programa en ejecuciÃ³n.
Un programa se convierte en proceso cuando las instrucciones del programa son cargadas en la memoria desde el archivo del ejecutable y se le asignan recursos para su ejecuciÃ³n.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Los procesos son entidades activas que necesita recursos âCPU, memoria, archivos, dispositivos E/Sâ.
Algunos de esos recursos se asignan durante su creaciÃ³n, mientras que otros son solicitados por el proceso durante su ejecuciÃ³n âpor ejemplo la memoria, de la que todo proceso necesita cierta cantidad para comenzar pero que luego puede pedir mÃ¡s dinÃ¡micamente durante su ejecuciÃ³nâ.
Cuando el proceso termina el sistema operativo reclama de estos recursos aquellos que sean reutilizables para otros procesos.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Un <strong>programa</strong> no es un proceso, es una entidad pasiva.
Es el contenido de un archivo en disco con las instrucciones que algÃºn dÃ­a una CPU ejecutarÃ¡.
Un programa no puede hacer ningÃºn tipo de trabajo a menos que sus instrucciones sean ejecutadas por una CPU, pero si eso ocurre, ya no serÃ­a un programa sino un proceso.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Aunque varios procesos estÃ©n asociados al mismo programa no pueden ser considerados el mismo proceso.
La CPU ejecuta las instrucciones de cada proceso una detrÃ¡s de otra, de manera que para conocer la siguiente instrucciÃ³n a ejecutar cada proceso tiene un contador de programa que se lo indica a la CPU, asÃ­ como valores en los registros de la CPU que dependen de la historia pasada del proceso.
Aunque varios procesos ejecuten el mismo programa, la secuencia de instrucciones ejecutadas y el estado del proceso en cada momento seguramente sean diferentes.
Por lo tanto, no son el mismo proceso.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Por el momento estamos considerando que <strong>proceso</strong> y <strong>trabajo</strong> hacen referencia al mismo concepto porque en los sistemas mÃ¡s antiguos (vÃ©ase el <a href="#_mainframe">Apartado 2.1</a>) la unidad de trabajo se llamaba <strong>trabajo</strong> mientras que en los sistemas modernos se llama <strong>proceso</strong>, de tal forma que podemos considerar al segundo una evoluciÃ³n del primero.</p>
</div>
<div class="paragraph">
<p>Sin embargo, mirÃ¡ndolo exclusivamente desde la perspectiva de los sistemas operativos modernos, son dos conceptos diferentes aunque relacionados.
En un sistema moderno un trabajo puede ser realizado por un solo proceso o mediante la colaboraciÃ³n de varios.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_responsabilidades_de_la_gestiÃ³n_de_procesos">4.1.1. Responsabilidades de la gestiÃ³n de procesos</h4>
<div class="paragraph">
<p>El componente de gestiÃ³n de procesos es el responsable de la siguientes actividades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Crear y terminar procesos.</p>
</li>
<li>
<p>Suspender y reanudar los procesos.</p>
</li>
<li>
<p>Proporcionar mecanismos para la sincronizaciÃ³n de procesos.</p>
</li>
<li>
<p>Proporcionar mecanismos para la comunicaciÃ³n entre procesos.</p>
</li>
<li>
<p>Proporcionar mecanismos para el tratamiento de interbloqueos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestiÃ³n_de_la_memoria_principal">4.2. GestiÃ³n de la memoria principal</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La memoria principal es un recurso fundamental para las operaciones de cualquier sistema operativo moderno.
Esto es asÃ­ porque generalmente es el Ãºnico almacenamiento al que la CPU tiene acceso directo.
Para que un programa pueda ser ejecutado debe ser copiado a la memoria principal.
Y para que un proceso tenga acceso a datos almacenados en cualquier otro dispositivo de almacenamiento, primero deben ser copiados a la memoria principal.</p>
</div>
<div class="paragraph">
<p>Para mejorar el aprovechamiento de la CPU y la respuesta al usuario es necesario tener en la memoria varios programas al mismo tiempo.
Puesto que dichos programas deben compartir la memoria durante su ejecuciÃ³n, automÃ¡ticamente existe la necesidad de que el sistema operativo disponga de un componente de gestiÃ³n de la memoria principal.</p>
</div>
<div class="sect3">
<h4 id="_responsabilidad_de_la_gestiÃ³n_de_la_memoria">4.2.1. Responsabilidad de la gestiÃ³n de la memoria</h4>
<div class="paragraph">
<p>El componente de gestiÃ³n de la memoria debe asumir las siguientes responsabilidades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Controlar quÃ© partes de la memoria estÃ¡n actualmente en uso y cuÃ¡les no.</p>
</li>
<li>
<p>Decidir que procesos âo partes de procesosâ aÃ±adir o extraer de la memoria cuando hay o falta espacio en la misma.</p>
</li>
<li>
<p>Asignar y liberar espacio de la memoria principal segÃºn sea necesario.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestiÃ³n_del_sistema_de_es">4.3. GestiÃ³n del sistema de E/S</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El <strong>sistema de E/S</strong> hace de interfaz con el hardware, oculta las peculiaridades del hardware al resto del sistema.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>El sistema de E/S consta de:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Un componente de gestiÃ³n de memoria especializado en E/S</strong>, con soporte para servicios de <em>buffering</em>, <em>caching</em> y <em>spooling</em>.
Estos servicios son utilizados por el resto del sistema de E/S.</p>
</li>
<li>
<p><strong>Una interfaz genÃ©rica de acceso a los controladores de dispositivo</strong>.
Cada dispositivo es diferente, pero los procesos y el resto de componentes del sistema no deben tener necesidad de conocer sus particularidades a la hora de acceder a ellos.
Es decir, para acceder a cualquier disco duro el sistema ofrece una misma interfaz, impedientemente de su marca y modelo.
Y lo mismo ocurre con las tarjetas de sonido o con los dispositivos de entrada, como teclados y ratones.
AsÃ­ los programadores pueden acceder a cualquier dispositivo abstrayendo de las particularidades concretas del hardware instalado en cada ordenador.</p>
</li>
<li>
<p><strong>Controladores de dispositivo</strong>, que generalmente son desarrollados por los fabricantes de los dispositivos y son el componente que realmente conoce las peculiaridades especÃ­ficas del dispositivo.
Por tanto, las peticiones que hacen los procesos a la interfaz de E/S genÃ©rica la traslada el sistema a los controladores de dispositivo para que Ã©stos las conviertan en acciones concretas sobre el hardware del dispositivo.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Una caracterÃ­stica de los sistemas UNIX es que todos los dispositivos de E/S se representa como un archivo en el sistema de archivos.
Esto se puede comprobar rÃ¡pidamente visitando el directorio <code>/dev</code> en cualquier sistema GNU/Linux o BSD, ya que es allÃ­ donde suelen estar.</p>
</div>
<div class="paragraph">
<p>AsÃ­ no hace falta diseÃ±ar y aprender una interfaz diferente para cada tipo de dispositivo.
Los procesos que quiere utilizar cualquier dispositivo de E/S solo tienen que usar las mismas funciones y llamadas al sistema que emplean para manipular los archivos normales.
Por ejemplo, <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>, <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a>, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a> o <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_buffering">4.3.1. Buffering</h4>
<div class="paragraph">
<p>El <strong>buffering</strong> o uso de memoria intermedia es una estrategia en la que se almacenan los datos de manera temporal en una zona de la memoria, llamada bÃºfer.</p>
</div>
<div class="paragraph">
<p>Consiste en que el controlador indica a un dispositivo que escriba los bloques de datos solicitados en un bÃºfer.
Cuando la escritura del bÃºfer se ha completado, se transfiere su contenido al proceso que hizo la solicitud para que procese los datos.
Mientras lo hace, el controlador indica al dispositivo que copie nuevos datos en el bÃºfer.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, al grabar sonido del dispositivo de sonido del sistema no se entregan las muestras una a una al proceso.
En su lugar se graban varios miles de muestras que se escriben en un bÃºfer.
Cuando el bÃºfer estÃ¡ lleno, se transfieren todas las muestras al proceso de una sola vez y se siguen grabando muestras en el bÃºfer.</p>
</div>
<div class="paragraph">
<p>Lo mismo ocurre al reproducir sonido.
El proceso no entrega las muestras de sonido de una en una al dispositivo, sino que empaqueta varias miles que se copian al bÃºfer de una sola vez.
Entonces el controlador indica al dispositivo que lea las muestras desde ese bÃºfer segÃºn lo vaya necesitando.</p>
</div>
</div>
<div class="sect3">
<h4 id="_caching">4.3.2. Caching</h4>
<div class="paragraph">
<p>En el <strong>caching</strong> el sistema mantiene en la memoria principal una copia de datos  leÃ­dos o escritos recientemente en los dispositivos de E/S del sistema âpor ejemplo, en los discos duros o en las memorias USBâ.
Esto mejora la eficiencia del sistema si accede con frecuencia a los mismos datos, puesto que el acceso a la memoria principal es mÃ¡s rÃ¡pido que el acceso a los dispositivos de E/S.
La memoria principal es de tamaÃ±o limitado, por lo que sÃ³lo se mantiene copia de los datos utilizados con mayor frecuencia.</p>
</div>
</div>
<div class="sect3">
<h4 id="_spooling">4.3.3. Spooling</h4>
<div class="paragraph">
<p>El <strong>spooling</strong> se utiliza en dispositivos que no admiten el acceso simultÃ¡neo de varias aplicaciones a vez, como es el caso de impresoras y unidades de cinta.</p>
</div>
<div class="paragraph">
<p>Cuando varias aplicaciones intentan enviar un trabajo a una impresora, el sistema operativo lo intercepta para copiar los datos enviados a un archivo independiente.
Cuando una aplicaciÃ³n termina de enviar el trabajo, el archivo correspondiente se mete en una cola de donde son extraÃ­dos los trabajos para su impresiÃ³n de uno en uno.
AsÃ­ no hay acceso simultÃ¡neo al dispositivo por parte de varios procesos, mientras que Ã©stos pueden entregar el trabajo y continuar con su trabajo sin esperar a que la impresora estÃ© disponible.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestiÃ³n_del_almacenamiento_secundario">4.4. GestiÃ³n del almacenamiento secundario</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Dentro de los dispositivos de E/S, los dedicados al almacenamiento secundario âcomo discos duros, memorias USB o lectores de DVD-ROMâ merecen un tratamiento especial.</p>
</div>
<div class="paragraph">
<p>Los programas que se desean ejecutar deben estar en la memoria principal âo almacenamiento primarioâ pero Ã©sta es demasiado pequeÃ±a para alojar todos los datos y todos los programas del sistema.
AdemÃ¡s, incluso aunque pudiera ser asÃ­, los datos almacenados en la memoria principal se perderÃ­an en caso de que ocurriera un fallo de alimentaciÃ³n.
Por eso los ordenadores disponen de un almacenamiento secundario para guardar datos de forma masiva y permanente.</p>
</div>
<div class="paragraph">
<p>El gestor del almacenamiento secundario utiliza el sistema de E/S para acceder a los dispositivos y ofrecer al sistema servicios mÃ¡s complejos.</p>
</div>
<div class="sect3">
<h4 id="_responsabilidades_de_la_gestiÃ³n_del_almacenamiento_secundario">4.4.1. Responsabilidades de la gestiÃ³n del almacenamiento secundario</h4>
<div class="paragraph">
<p>El gestor del almacenamiento secundario es el responsable de:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gestionar el espacio libre en discos duros y resto de dispositivos de almacenamiento secundario.</p>
</li>
<li>
<p>Asignar el espacio de almacenamiento.</p>
</li>
<li>
<p>Planificar el acceso a los dispositivos, de tal forma que se ordenen las operaciones de forma eficiente.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestiÃ³n_del_sistema_de_archivos">4.5. GestiÃ³n del sistema de archivos</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los ordenadores pueden almacenar informaciÃ³n en diferentes tipos de medios fÃ­sicos âpor ejemplo en discos duros magnÃ©ticos, CD/DVD-ROM, memorias USB o SSDâ cada uno de los cuales tiene caracterÃ­sticas propias.
El acceso a cada tipo de medio es controlado por un dispositivo âpor ejemplo el controlador de disco o la unidad de DVD-ROMâ que tambiÃ©n tiene caracterÃ­sticas propias.
El sistema de E/S y la gestiÃ³n del almacenamiento secundario simplifican el acceso a estos dispositivos, pero no lo suficiente como para que sea cÃ³modo usarlos constantemente en cualquier programa.</p>
</div>
<div class="paragraph">
<p>Para simplificar aun mÃ¡s el acceso al almacenamiento, el sistema operativo proporciona una visiÃ³n lÃ³gica uniforme de todos los sistemas de almacenamiento.
Es decir, abstrae las propiedades fÃ­sicas de los dispositivos de almacenamiento para definir el <strong>archivo</strong>, una unidad de almacenamiento lÃ³gico con la que trabajan los procesos para guardar y recuperar datos.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Un <strong>archivo</strong> o fichero es una colecciÃ³n de datos relacionados, identificados por un nombre, que es tratada por el sistema operativo como una unidad de informaciÃ³n en el almacenamiento secundario âpor ejemplo un programa, una imagen o un documentoâ.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Los archivos normalmente se organizan en directorios para facilitar su uso y organizaciÃ³n.</p>
</div>
<div class="sect3">
<h4 id="_responsabilidades_de_la_gestiÃ³n_del_sistema_de_archivos">4.5.1. Responsabilidades de la gestiÃ³n del sistema de archivos</h4>
<div class="paragraph">
<p>El sistema de archivos utiliza al gestor del almacenamiento secundario y al sistema de E/S y es responsable de las siguientes actividades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Crear y borrar archivos.</p>
</li>
<li>
<p>Crear y borrar directorios para organizar los archivos.</p>
</li>
<li>
<p>Soportar operaciones bÃ¡sicas para la manipulaciÃ³n de archivos y directorios: lectura y escritura de datos, cambio de nombre, cambio de permisos, etc.</p>
</li>
<li>
<p>Mapear en memoria archivos del almacenamiento secundario.</p>
</li>
<li>
<p>Hacer copias de seguridad de los archivos en sistemas de almacenamiento estables y seguros.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestiÃ³n_de_red">4.6. GestiÃ³n de red</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>El componente de red se responsabiliza de la comunicaciÃ³n con otros sistemas interconectados mediante una red de ordenadores âpor ejemplo, en Internet o en la red de Ã¡rea local de una oficinaâ.</p>
</div>
</div>
<div class="sect2">
<h3 id="_protecciÃ³n_y_seguridad">4.7. ProtecciÃ³n y seguridad</h3>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>ProtecciÃ³n</strong> es cualquier mecanismo para controlar el acceso de los procesos y usuarios a los recursos definidos por el sistema.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Son mecanismos necesarios cuando un sistema informÃ¡tico tiene mÃºltiples usuarios y permite la ejecuciÃ³n concurrente de varios procesos, pues asÃ­ sÃ³lo pueden utilizar los recursos aquellos procesos que hayan obtenido la autorizaciÃ³n del sistema operativo.</p>
</li>
<li>
<p>Permite mejorar la fiabilidad, al permitir detectar los elementos del sistema que no operan correctamente.
Un recurso desprotegido no puede defenderse contra el uso âo mal usoâ de un usuario no autorizado o incompetente.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Ejemplos tÃ­picos de mecanismos de protecciÃ³n son el hardware de direccionamiento de memoria, que se utiliza para que los procesos se ejecuten en su propio espacio de direcciones, y el temporizador, que garantiza que ningÃºn proceso toma el control de la CPU por tiempo indefinido.
AdemÃ¡s, los registros de los dispositivos de E/S suelen estar protegidos del acceso directo de los usuarios, lo que protege la integridad de los dispositivos.
Mientras que en algunos sistemas se pueden establecer permisos sobre los archivos para garantizar que sÃ³lo los procesos con la debida autorizaciÃ³n tengan acceso.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Un sistema puede tener la protecciÃ³n adecuada pero estar expuesto a fallos y permitir accesos inapropiados.
Por eso es necesario disponer de mecanismos de <strong>seguridad</strong> que se encarguen de defender el sistema frente a ataques internos y externos.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Eso incluye a virus y gusanos, ataques de <a href="https://es.wikipedia.org/wiki/Ataque_de_denegaci%C3%B3n_de_servicio">denegaciÃ³n de servicio</a>, robo de identidad y uso no autorizado del sistema, entre muchos otros tipos de ataque.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_servicios_del_sistema">5. Servicios del sistema</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>5 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Un sistema operativo proporciona un entorno para la ejecuciÃ³n de programas.
Ese entorno debe proporcionar ciertos servicios a los programas y a los usuarios de esos programas.
Estos servicios son proporcionados gracias al funcionamiento coordinado de los diferentes componentes del sistema.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="C05-servicios/images/organizaciÃ³n_sistema.svg" alt="organizaciÃ³n sistema">
</div>
<div class="title">Figura 17. Diagrama general de organizaciÃ³n de los sistemas operativos.</div>
</div>
<div class="paragraph">
<p>Aunque cada sistema operativo proporciona servicios diferentes, es posible identificar unas pocas clases comunes.</p>
</div>
<div class="sect2">
<h3 id="_servicios_que_garantizan_el_funcionamiento_eficiente_del_sistema">5.1. Servicios que garantizan el funcionamiento eficiente del sistema</h3>
<div class="ulist">
<ul>
<li>
<p><strong>AsignaciÃ³n de recursos</strong>.
Cuando hay mÃºltiples usuarios o mÃºltiples trabajos ejecutÃ¡ndose los recursos deben ser asignados a cada uno de ellos.</p>
<div class="paragraph">
<p>Ejemplos de estos recursos son la CPU âasignada por el planificador de la CPU del gestor de procesosâ la memoria principal âasignada por el gestor de memoriaâ y el almacenamiento de archivos âasignada por el sistema de archivos y el gestor del almacenamiento secundarioâ.
Esta asignaciÃ³n debe hacerse con el fin de garantizar la mÃ¡xima eficacia del sistema.</p>
</div>
</li>
<li>
<p><strong>MonitorizaciÃ³n</strong>.
Es normal querer hacer seguimiento de los recursos que los usuarios usan y en quÃ© cantidad.
Esto puede ser Ãºtil para facturar a los usuarios por el uso de los recursos âpor ejemplo, facturar por el tiempo de CPUâ para configurar el sistema mejorando el rendimiento o para limitar cuÃ¡nto de cada recurso puede usar cada usuario como mÃ¡ximo.</p>
</li>
<li>
<p><strong>ProtecciÃ³n y seguridad</strong>.
ProtecciÃ³n implica asegurar que el acceso a los recursos del sistema
estÃ¡ controlado.
Por ejemplo, que la informaciÃ³n almacenada en un sistema multiusuario sÃ³lo puede ser accedida por su propietario o que un proceso no pueda interferir con otro o con el sistema operativo.
La seguridad del sistema respecto a los agentes exteriores tambiÃ©n es
importante.
Empieza obligando a los usuarios a autenticarse en Ã©l para obtener acceso a los recursos del mismo, pero incluye defender de intentos de acceso invÃ¡lidos a travÃ©s de la red.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_servicios_Ãºtiles_para_el_usuario">5.2. Servicios Ãºtiles para el usuario</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Interfaz de usuario</strong>. Los sistemas operativos diseÃ±ados para que los usuarios interactÃºen con ellos deben proporcionar una interfaz de usuario adecuada, que puede ser diferente formas segÃºn le propÃ³sito del sistema.</p>
</li>
<li>
<p><strong>Operaciones de E/S</strong>. Un programa puede necesitar realizar operaciones de E/S que pueden
involucrar a archivos o a dispositivos de E/S.
Por eficiencia y protecciÃ³n un usuario, normalmente los procesos no puede tener acceso directo a los dispositivos; por lo que el sistema operativo debe proporcionar medios para solicitar estas operaciones a los componentes correspondientes del sistema operativo.</p>
</li>
<li>
<p><strong>ManipulaciÃ³n de sistemas de archivos</strong>. Los programas necesitan leer y escribir archivos y
directorios, crearlos y borrarlos por nombre, buscar un archivo dado y listar informaciÃ³n
acerca del mismo.</p>
</li>
<li>
<p><strong>Comunicaciones</strong>. Los procesos necesitan poder intercambiar informaciÃ³n entre ellos, tanto si
se ejecutan en el mismo ordenador, como en diferentes equipos unidos por una red.</p>
</li>
<li>
<p><strong>DetecciÃ³n de errores</strong>. El sistema operativo necesita tener conocimiento de los posibles errores y para cada tipo de error debe tomar la acciÃ³n apropiada para asegurar una computaciÃ³n consiste y segura.
Por ejemplo, pueden haber errores del hardware âcomo fallos de energÃ­a o errores en la
memoriaâ en la E/S âcomo errores de paridad o falta de papel en la impresoraâ y en los
programas de usuario âcomo desbordamientos aritmÃ©ticos o accesos ilegales a la memoriaâ.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_interfaz_de_usuario">5.3. Interfaz de usuario</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>La <strong>interfaz de usuario</strong> es un servicio fundamental para todos los sistemas diseÃ±ados para que los usuarios interactÃºen con ellos directamente, por lo que nos vamos a detener un poco mÃ¡s en Ã©l.</p>
</div>
<div class="paragraph">
<p>Las interfaces de usuario pueden ser de diferentes tipos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Interfaz de lÃ­nea de comandos</strong> o <strong>intÃ©rprete de comandos</strong>, que permite que los usuarios introduzcan directamente los comandos que el sistema operativo debe ejecutar.
En algunos sistemas este tipo de interfaz se incluye dentro del nÃºcleo, pero en la mayor parte âcomo MSDOS y UNIXâ se trata de un programa especial denominado <em>shell</em> que se ejecuta cuando un usuario inicia una sesiÃ³n.</p>
</li>
<li>
<p><strong>Interfaz de proceso por lotes</strong>, en la que los comandos y directivas para controlar dichos comandos se listan en archivos que posteriormente pueden ser ejecutados.
Este tipo de interfaz es la utilizada en sistemas no interactivos, como los antiguos sistemas de procesamiento por lotes y los sistemas multiprogramados.</p>
<div class="paragraph">
<p>TambiÃ©n suele estar disponible en los sistemas de tiempo compartido y en los sistemas de escritorio modernos, junto con algÃºn otro tipo de interfaz de usuario.
Por ejemplo, la <em>shell</em> de los sistemas UNIX permite indicar comandos uno a uno âde forma interactivaâ pero tambiÃ©n permite usar <em>scripts</em> âun archivo con una lista de Ã³rdenes para que se ejecuten automÃ¡ticamente de principio a finâ.</p>
</div>
</li>
<li>
<p><strong>Interfaz grÃ¡fica de usuario</strong> o <strong>GUI</strong> (<em>Graphical User Interface</em>) que permite a los usuarios utilizar un sistema de ventanas y menÃºs controlable mediante el ratÃ³n.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Puesto que la interfaz de usuario puede variar de un sistema a otro, y de un usuario a otro dentro del mismo sistema, no se suele etiquetar como un componente bÃ¡sico del sistema operativo, sino como un servicio ofrecido por el sistema operativo.</p>
</div>
<div class="paragraph">
<p>A parte de la interfaz de usuario, cualquier sistema operativo moderno incluye una colecciÃ³n de <strong>programas del sistema</strong>.
El papel de estos programas del sistema es proporcionar un entorno conveniente para la ejecuciÃ³n y desarrollo de programas.
Entre los programas del sistema se suelen incluir aplicaciones para manipular archivos y directorios, programas para obtener informaciÃ³n sobre el estado del sistema âcomo la fecha y hora o la memoria y el espacio en disco disponibleâ herramientas de desarrollo âcomo intÃ©rpretes, compiladores, enlazadores y depuradoresâ programas de comunicaciones âcomo clientes de correo electrÃ³nico y navegadores webâ etc.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, muchos sistemas operativos disponen de programas que son Ãºtiles para resolver los problemas mÃ¡s comunes de los usuarios.
Entre estos programas se suelen incluir: editores de archivos de texto y procesadores de texto, hojas de cÃ¡lculo, sistemas de base de datos, juegos, etc.
Ha esta colecciÃ³n de aplicaciones se la suele conocer con el tÃ©rmino de <strong>utilidades del sistema</strong> o <strong>programas de aplicaciÃ³n</strong>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interfaz_de_programaciÃ³n_de_aplicaciones">6. Interfaz de programaciÃ³n de aplicaciones</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>15 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Un sistema operativo proporciona un entorno controlado para la ejecuciÃ³n de programas.
Dicho entorno debe proporcionar ciertos servicios que pueden ser accedidos por los programas a travÃ©s de una <strong>interfaz de programaciÃ³n de aplicaciones</strong> o <strong>API</strong> (<em>Application Programming Interface</em>).</p>
</div>
<div class="sect2">
<h3 id="_interfaces_de_programaciÃ³n_de_aplicaciones">6.1. Interfaces de programaciÃ³n de aplicaciones</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Algunas de las API disponibles para los desarrolladores de aplicaciones son Windows API y POSIX.</p>
</div>
<div class="sect3">
<h4 id="_windows_api">6.1.1. Windows API</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/Win32_API">Windows API</a> es el nombre que recibe la <strong>interfaz de programaciÃ³n de aplicaciones</strong> de Microsoft Windows, con la que prÃ¡cticamente tienen que interactuar todas las aplicaciones, de una forma u otra.</p>
</div>
<div class="paragraph">
<p>Antiguamente se denominaba Win32 API, pero Microsoft ha querido aglutinar bajo una misma denominaciÃ³n las distintas versiones de la API de Windows que han existido, como Win16 âusada en las versiones de 16 bits de Windowsâ o Win64 âque es la variante de Win32 adaptada a arquitecturas de 64 bitsâ.</p>
</div>
<div class="paragraph">
<p>EstÃ¡ compuesta por funciones en C almacenadas, principalmente, en las librerÃ­as de enlace dinÃ¡mico (<a href="https://es.wikipedia.org/wiki/Biblioteca_de_enlace_din%C3%A1mico">DLL</a>): <code>kernel32.dll</code>, <code>user32.dll</code> y <code>gdi32.dll</code>.
Aunque segÃºn se ha ido ampliando la API, se han incorporado otras librerÃ­as adicionales.</p>
</div>
<div class="paragraph">
<p>Provee un conjunto muy amplio de servicios: E/S a archivos y dispositivos, gestiÃ³n de procesos, hilos y memoria, manejo de errores, registro de Windows, interfaz a dispositivos grÃ¡ficos âpantallas e impresorasâ gestiÃ³n de ventanas, comunicaciones en red, etc.</p>
</div>
</div>
<div class="sect3">
<h4 id="_posix">6.1.2. POSIX</h4>
<div class="paragraph">
<p><a href="https://es.wikipedia.org/wiki/POSIX">POSIX</a> (<em>Portable Operating System Interface for Unix</em>) es el nombre de una familia de estÃ¡ndares que definen una <strong>interfaz de programaciÃ³n de aplicaciones</strong> para sistemas operativos.
Esto permite que un mismo programa pueda ser ejecutado en distintos sistemas operativos, siempre que sean compatibles con POSIX.</p>
</div>
<div class="paragraph">
<p>El lenguaje C fue diseÃ±ado originalmente para implementar sistemas UNIX y por eso la librerÃ­a estÃ¡ndar de C tenÃ­a mucho parecido con la librerÃ­a del sistema de UNIX.
Con el tiempo, al ir aÃ±adiendo mÃ¡s funcionalidades, la librerÃ­a del sistema de los sistemas UNIX de los distintos fabricantes fue divergiendo, haciendo muy complicado desarrollar programas que usaran las caracterÃ­sticas mÃ¡s avanzadas y que a la vez pudieran ejecutarse en varios de ellos.
Por eso el <a href="https://es.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers">IEEE</a> desarrollo el estÃ¡ndar POSIX, que define una API comÃºn para todos los UNIX y sistemas estilo UNIX modernos âcomo es el caso de GNU/Linuxâ.
AsÃ­ que la prÃ¡ctica totalidad de estos sistemas son compatible POSIX.</p>
</div>
<div class="paragraph">
<p>Por su origen, la API POSIX es un superconjunto de la API de la librerÃ­a estÃ¡ndar de C.
Por eso en los sistemas POSIX, la librerÃ­a estÃ¡ndar de C es parte de la librerÃ­a del sistema, en lugar de dos librerÃ­as separadas.</p>
</div>
<div class="paragraph">
<p>Las funciones POSIX estÃ¡n almacenadas, principalmente, en la librerÃ­a <code>libc</code>.
Aunque algunas caracterÃ­sticas pueden estar en otras librerÃ­as, como <code>libm</code> âla librerÃ­a matemÃ¡ticaâ o <code>libpthread</code> âla librerÃ­a de hilosâ.</p>
</div>
<div class="paragraph">
<p>Los desarrolladores del sistema a veces aÃ±aden funciones no incluidas en el estÃ¡ndar POSIX, con el objeto de soportar algÃºn tipo de funcionalidad avanzada del sistema.
Antes de usarlas debemos tener presente que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un programa que solo utilice la API POSIX podrÃ¡ ejecutarse en cualquier sistema operativo compatible POSIX.</p>
</li>
<li>
<p>Mientras que uno que utilice, por ejemplo, alguna funcionalidad adicional no POSIX de Linux o macOS, solo podrÃ¡ compilarse y ejecutarse en Linux o en macOS, segÃºn el caso.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_llamadas_al_sistema">6.2. Llamadas al sistema</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Para un programa, acceder a los servicios del sistema operativo no es tan sencillo como invocar una funciÃ³n.
Para invocar una funciÃ³n, un programa necesita conocer la direcciÃ³n en la memoria del punto de entrada de dicha funciÃ³n âes decir, la ubicaciÃ³n de su primera instrucciÃ³nâ.
Sin embargo, el cÃ³digo del nÃºcleo del sistema puede estar en cualquier ubicaciÃ³n de la memoria principal.
AsÃ­ que las direcciones de los puntos de entrada a las funciones del nÃºcleo son desconocidas.
AdemÃ¡s, generalmente, el cÃ³digo y los datos del nÃºcleo estÃ¡n protegidos frente a accesos indebidos (vÃ©ase el <a href="#_protecciÃ³n_de_la_memoria">Apartado 7.3</a>).
Eso significa que para que un proceso pueda invocar los servicios que necesita hace falta un procedimiento diferente, denominado <strong>llamada al sistema</strong>.</p>
</div>
<div class="sect3">
<h4 id="_invocar_llamadas_al_sistema">6.2.1. Invocar llamadas al sistema</h4>
<div class="paragraph">
<p>Generalmente una llamada al sistema se invoca mediante una instrucciÃ³n especÃ­fica en lenguaje ensamblador que genera una <strong>excepciÃ³n</strong> âque no es mÃ¡s que una interrupciÃ³n lanzada por la propia CPU al detectar instrucciones especiales o un error al ejecutar una instrucciÃ³n, como una divisiÃ³n por 0 o un acceso indebido a ciertas zonas de la memoriaâ.
Por ejemplo, en MIPS e Intel x86 se usa la instrucciÃ³n <code>syscall</code>, que lanza un excepciÃ³n, haciendo que la CPU salte a una rutina en el cÃ³digo del nÃºcleo del sistema, deteniendo asÃ­ la ejecuciÃ³n del proceso que la invocÃ³.</p>
</div>
<div class="paragraph">
<p>Al realizar una llamada, es necesario que el sistema sepa quÃ© operaciÃ³n le estÃ¡ pidiendo el proceso.
Esto se suele hacer poniendo un nÃºmero identificativo de la llamada en un registro concreto de la CPU.
Por ejemplo, en Linux para x86 la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> âque se utiliza para abrir archivosâ se identifica con el nÃºmero 2 o con el 5, segÃºn si es en 64 o en 32 bits, respectivamente.
Este nÃºmero se debe guardar en el registro <code>v0</code> en MIPS o <code>eax</code> en x86, antes de la instrucciÃ³n <code>syscall</code>.</p>
</div>
<div class="paragraph">
<p>Los nÃºmeros utilizados para identificar cada llamada al sistema dependen del sistema operativo.
Mientras que el registro donde se guarda, la instrucciÃ³n utilizada y el resto de detalles sobre cÃ³mo realizar la llamada, dependen tambiÃ©n de la arquitectura de la CPU.</p>
</div>
</div>
<div class="sect3">
<h4 id="_paso_de_argumentos">6.2.2. Paso de argumentos</h4>
<div class="paragraph">
<p>Obviamente una llamada al sistema suele requerir mÃ¡s informaciÃ³n que la identidad de la llamada.
Si, por ejemplo, se quiere abrir un archivo, al menos es necesario indicar su nombre, asÃ­ como si se abre para leer o para escribir.</p>
</div>
<div class="paragraph">
<p>En concreto hay tres mÃ©todos para pasar parÃ¡metros adicionales al identificador a una llamada al sistema:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Mediante registros de la CPU</strong>.
Consiste en cargar los parÃ¡metros de la llamada al sistema en los registros de la CPU antes de realizar la llamada al sistema.
Este mÃ©todo es el mÃ¡s eficiente, pero limita el nÃºmero de parÃ¡metros al nÃºmero de registros disponibles.</p>
<div class="paragraph">
<p>Es utilizado, por ejemplo, en Linux para MIPS (vÃ©ase el <a href="#linux_mips_syscall">Ejemplo 1</a>) y en la mayorÃ­a de sistemas operativos para x86-64.</p>
</div>
</li>
<li>
<p><strong>Mediante tabla en memoria</strong>
Consiste en copiar los parÃ¡metros de la llamada al sistema en una tabla en la memoria principal y luego guardar la direcciÃ³n de dicha tabla en un registro especÃ­fico de la CPU, antes de la llamada al sistema.
AsÃ­ no se limita el nÃºmero de parÃ¡metros que pueden ser pasados en cada llamada al sistema.</p>
<div class="paragraph">
<p>Era utilizado por Microsoft Windows 2000 y anteriores.
TambiÃ©n en Linux para x86 32 bits, cuando el nÃºmero de parÃ¡metros es superior a 6.</p>
</div>
</li>
<li>
<p><strong>Mediante la pila del proceso</strong> se insertan los parÃ¡metros de la llamada al sistema en la pila del proceso âque tambiÃ©n se suele usar para guardar variables locales y, en algunas arquitecturas, los argumentos pasados al llamar a funcionesâ y el sistema operativo los recupera de allÃ­ durante la llamada al sistema.
Al igual que en el caso anterior, tampoco limita el nÃºmero de parÃ¡metros que pueden ser pasados en cada llamada al sistema.</p>
<div class="paragraph">
<p>Es utilizado, por ejemplo, en sistemas BSD y en Windows XP y posteriores para x86 de 32 bits.</p>
</div>
</li>
</ul>
</div>
<div id="linux_mips_syscall" class="exampleblock">
<div class="title">Ejemplo 1. Llamada al sistema en Linux MIPS.</div>
<div class="content">
<div class="paragraph">
<p>Veamos como invocar directamente la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a> en Linux para MIPS.</p>
</div>
<div class="paragraph">
<p>Esta llamada sirve para escribir datos en un archivo.
AsÃ­ que necesita tres argumentos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>SIZE</strong>: El nÃºmero de bytes a escribir.</p>
</li>
<li>
<p><strong>BUFFER</strong>: La direcciÃ³n de la memoria de la que coger los bytes.</p>
</li>
<li>
<p><strong>FILEDES</strong>: El descriptor que identifica a un archivo abierto donde se van a escribir los datos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Al terminar devuelve el nÃºmero de bytes escritos en el archivo, que puede ser inferior a <code>SIZE</code>.</p>
</div>
<div class="paragraph">
<p>El identificador de la llamada al sistema es 4004, segÃºn el <a href="https://git.linux-mips.org/cgit/ralf/linux.git/tree/arch/mips/include/uapi/asm/unistd.h">listado de llamadas al sistema</a> para Linux en MIPS.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>  lw      $a0, FILEDES   <i class="conum" data-value="1"></i><b>(1)</b>
  la      $a1, BUFFER    <i class="conum" data-value="1"></i><b>(1)</b>
  lw      $a2, SIZE      <i class="conum" data-value="1"></i><b>(1)</b>
  li      $v0, 40004     <i class="conum" data-value="2"></i><b>(2)</b>
  syscall                <i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Cargar cada uno de los 3 argumentos de la llamada al sistema en los registros <code>a0</code>, <code>a1</code> y <code>a2</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Cargar el identificador de la llamada <code>write()</code> en el registro <code>v0</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Invocar la llamada al sistema.
Aunque vemos que es una Ãºnica instrucciÃ³n, lo que realmente va a ocurrir es que el sistema operativo va a tomar el control de la CPU para realizar la tarea solicitada.
La siguiente instrucciÃ³n no comenzarÃ¡ a ejecutarse hasta que el sistema operativo no lo decida, por lo que, desde el punto de vista del programa, va a ser como si <code>syscall</code> fuera una instrucciÃ³n mÃ¡s lenta de lo normal.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Al ejecutar la siguiente instrucciÃ³n del cÃ³digo del programa, el registro <code>v0</code> contendrÃ¡ el nÃºmero de bytes escritos.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap06/syscall.s">syscalls.s</a> se puede ver un ejemplo completo similar, pero para Linux x86 de 64 bits.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>En cualquier caso, sea cual sea el mÃ©todo utilizado, el sistema operativo es responsable de comprobar de manera estricta la validez de los parÃ¡metros enviados en la llamada al sistema antes de realizar cualquier operaciÃ³n, puesto que nunca debe confiar en que los procesos hagan su trabajo correctamente.
A fin de cuentas, una de las funciones del sistema operativo es el control de dichos procesos.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_librerÃ­a_del_sistema">6.3. LibrerÃ­a del sistema</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Las <strong>llamadas al sistema</strong> proporcionan una interfaz con la que los procesos pueden invocar los servicios que el sistema operativo ofrece.
El problema es que como se hacen mediante instrucciones en lenguaje ensamblador (vÃ©ase el <a href="#linux_mips_syscall">Ejemplo 1</a>) no son demasiado cÃ³modas de utilizar.
AsÃ­ que generalmente los programas no las invocan directamente.
En su lugar, lo que hacen es llamar a funciones de la <strong>librerÃ­a del sistema</strong>, que a su vez son las encargadas de hacer las llamadas al sistema necesarias.</p>
</div>
<div class="paragraph">
<p>Cuando hablamos anteriormente de <a href="https://es.wikipedia.org/wiki/Win32_API">Windows API</a> y del estÃ¡ndar <a href="https://es.wikipedia.org/wiki/POSIX">POSIX</a>, hablÃ¡bamos de la interfaz de la <strong>librerÃ­a del sistema</strong> en esos sistemas operativos.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>La <strong>librerÃ­a del sistema</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Es parte del sistema operativo, por lo que se distribuye con Ã©l.</p>
</li>
<li>
<p>Es una colecciÃ³n de clases o funciones que ofrecen los servicios del sistema operativo a los programas, apoyÃ¡ndose en las llamadas al sistema.</p>
<div class="paragraph">
<p>Algunas funciones de la librerÃ­a del sistema son traducciones literales de llamadas al sistema âpor ejemplo, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a> o <a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a>â mientras que otras pueden ser mÃ¡s complejas, hacer mÃ¡s trabajo o mostrar conceptos mÃ¡s abstractos que los usados por el sistema operativo al nivel de llamadas al sistema.</p>
</div>
</li>
<li>
<p>Constituye la verdadera <strong>interfaz de programaciÃ³n de aplicaciones</strong> del sistema operativo.
Es la forma recomendada de solicitar servicios al sistema operativo.
Invocar directamente las llamadas al sistema debe ser el Ãºltimo recurso.</p>
</li>
<li>
<p>Sus funciones se llaman como cualquier otra.
Al igual que el resto de librerÃ­as, se carga dentro de la regiÃ³n de memoria asignada al proceso.
Por lo tanto, la invocaciÃ³n de las funciones de la librerÃ­a del sistema se realiza como si fueran cualquier otra funciÃ³n del programa.</p>
</li>
<li>
<p>Es muy comÃºn que estÃ© implementada en C, lo que permite que tanto los programas en C como en C&#43;&#43; la puedan utilizar directamente.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_librerÃ­a_estÃ¡ndar">6.4. LibrerÃ­a estÃ¡ndar</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Lenguajes distintos de C y C&#43;&#43; pueden tener difÃ­cil usar las funciones de la librerÃ­a del sistema.
Pero de alguna forma deben poder hacerlo, porque sus programadores necesitan acceso a los servicios que ofrece el sistema operativo.</p>
</div>
<div class="paragraph">
<p>Incluso en C y en C&#43;&#43; puede ser interesante tener acceso a funcionalidades adicionales a las ofrecidas por la API del sistema operativo: estructuras de datos, algoritmos de ordenamiento o bÃºsqueda, funciones para manipular cadenas, funciones matemÃ¡ticas, etc.
TambiÃ©n abstracciones de los servicios del sistema, que encajen mejor con las particularidades del lenguaje de programaciÃ³n en cuestiÃ³n.
Por ejemplo, utilizando clases y objetos en lenguajes que soportan programaciÃ³n orientada a objetos.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Por eso, junto a cada intÃ©rprete o compilador de cada lenguaje de programaciÃ³n suele ir una <strong>librerÃ­a estÃ¡ndar</strong> que ofrece clases o funciones con las que los programas pueden acceder a los servicios del sistema operativo y realizar las tareas mÃ¡s comunes de forma mÃ¡s sencilla.</p>
</div>
<div class="paragraph">
<p>Estas librerÃ­as generalmente no forman parte del sistema operativo, sino de las herramientas de desarrollo de cada lenguaje de programaciÃ³n, y constituyen la <strong>interfaz de programaciÃ³n de aplicaciones</strong> del lenguaje al que acompaÃ±an.</p>
</div>
<div class="paragraph">
<p>La <strong>librerÃ­a estÃ¡ndar</strong> necesita acceder a los servicios del sistema operativo para, a su vez, dar servicio a los programas que la usan.
Es decir, cuando un programa invoca alguna funciÃ³n o mÃ©todo de la librerÃ­a estÃ¡ndar que lo acompaÃ±a, es muy probable que Ã©sta necesite invocar uno o mÃ¡s servicios del sistema operativo para atender la peticiÃ³n convenientemente.
Para ello la <strong>librerÃ­a estÃ¡ndar</strong> utiliza la <strong>librerÃ­a del sistema</strong> que acompaÃ±a al sistema operativo, que a su vez realiza las <strong>llamadas al sistema</strong> necesarias.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">De archivos a flujos</div>
<div class="paragraph">
<p>Un ejemplo del papel de las <strong>librerÃ­as estÃ¡ndar</strong> lo podemos encontrar en el acceso a los archivos.</p>
</div>
<div class="paragraph">
<p>Las llamadas al sistema y la librerÃ­a del sistema de los sistemas operativos ofrecen funciones bÃ¡sicas para manipular archivos.
Los archivos se abren indicando su ruta y, al hacerlo, el sistema operativo devuelve un identificador del archivo abierto (vÃ©ase <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>).
Este identificador se puede usar para leer o escribir en bytes el contenido del archivo.</p>
</div>
<div class="paragraph">
<p>Si embargo en C, C&#43;&#43; y otros lenguajes, todo lo que son flujos de datos se generalizan en el concepto de flujo o <em>stream</em> (vÃ©ase <a href="https://en.cppreference.com/w/c/io">stdio.h</a> e <a href="https://en.cppreference.com/w/cpp/header/iostream">iostream</a>).
En Ã©l. se incluye la entrada de teclado y la salida por pantalla, la impresiÃ³n de documentos, las conexiones de red âpotencialmenteâ y, obviamente, el acceso a archivos y a dispositivos.</p>
</div>
<div class="paragraph">
<p>Los flujos pueden ser de texto o binarios, lo que implica algunas transformaciones en los datos.
AdemÃ¡s van ligados al concepto del <em>buffering</em>, es decir, que los bytes o caracteres escritos en el flujo no se Â«envÃ­anÂ» inmediatamente, sino que se acumulan en la memoria para ser enviados en bloque.</p>
</div>
<div class="paragraph">
<p>Todas estas caracterÃ­sticas adicionales las implementa la <strong>librerÃ­a estÃ¡ndar</strong>.
Pero por debajo, al final, los datos tiene que ser escritos en un archivo, una impresora o el monitor, recursos que gestiona el sistema operativo.
Por lo tanto, las <strong>librerÃ­as estÃ¡ndar</strong> necesitan hacer uso de la <strong>librerÃ­a del sistema</strong> para comunicarse con el sistema operativo.</p>
</div>
<hr>
<div class="paragraph">
<p>Algo que suele ocurrir al crear mayores abstracciones es que se suele perder control y caracterÃ­sticas especÃ­ficas.
Por ejemplo, la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> con la que se pueden crear archivos permite asignar permisos o crear archivos temporales.
Sin embargo, con las interfaces de <em>streams</em> de C y C&#43;&#43; no se puede hacer eso, ya que los permisos y la temporalidad son propiedades de los archivos que no son comunes a todas fuentes de flujos de datos.</p>
</div>
<div class="paragraph">
<p>AsÃ­ que en ocasiones puede ser que nos resulte mÃ¡s Ãºtil llamar a las funciones de la <strong>librerÃ­a del sistema</strong>, que usar las facilidades de la <strong>librerÃ­a estÃ¡ndar</strong>.
Sin embargo, debemos valorar que asÃ­ perdemos portabilidad, ya que ahora nuestro programa ya no podrÃ¡ usarse allÃ­ donde haya un compilador o intÃ©rprete de nuestro lenguaje, sino solo en sistemas operativos con una <strong>librerÃ­a del sistema</strong> compatible.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_con_todas_las_piezas_juntas">6.5. Con todas las piezas juntas</h3>
<div class="paragraph">
<p>En la <a href="#api_win32">Figura 18</a> se ilustra el papel de todos los elementos comentados, con el ejemplo de programas en C y Python, ejecutados en Microsoft Windows, que invocan los mÃ©todos <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> y <code>file()</code> de la librerÃ­a estÃ¡ndar de estos lenguajes, respectivamente.</p>
</div>
<div id="api_win32" class="imageblock">
<div class="content">
<img src="C06-api/images/interfaz_programaciÃ³n_aplicaciones_win32.svg" alt="interfaz programaciÃ³n aplicaciones win32">
</div>
<div class="title">Figura 18. Elementos de la interfaz de programaciÃ³n de aplicaciones en Microsoft Windows.</div>
</div>
<div class="paragraph">
<p>En ambos casos, la librerÃ­a estÃ¡ndar llama a la funciÃ³n <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a> de la librerÃ­a del sistema de Windows, que finalmente realiza una llamada al sistema que hace que el sistema operativo tome el control, deteniendo la ejecuciÃ³n del proceso que la solicita.
Entonces se realiza la tarea solicitada mediante el funcionamiento coordinado de los diferentes componentes del sistema (vÃ©ase el <a href="#_componentes_del_sistema">CapÃ­tulo 4</a>).</p>
</div>
<div class="paragraph">
<p>El programa en C, puede usar tanto la funciÃ³n <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> de su librerÃ­a estÃ¡ndar como llamar directamente a la funciÃ³n <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a> de la librerÃ­a del sistema âmarcado en rojo en la <a href="#api_win32">Figura 18</a>â.
Sin embargo, en el programa en Python no tenemos esa facilidad âal menos directamenteâ.</p>
</div>
<div class="paragraph">
<p>Usar directamente las funciones de la librerÃ­a del sistema desde programas en C o C&#43;&#43; tiene la ventaja de que permite utilizar todas las caracterÃ­sticas del sistema operativo.
Por ejemplo, utilizar las opciones adicionales de <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">HANDLE</span> <span class="n">WINAPI</span> <span class="nf">CreateFile</span><span class="p">(</span>
  <span class="n">LPCTSTR</span> <span class="n">lpFileName</span><span class="p">,</span>                           <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">DWORD</span> <span class="n">dwDesiredAccess</span><span class="p">,</span>                        <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="n">DWORD</span> <span class="n">dwShareMode</span><span class="p">,</span>                            <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="n">LPSECURITY_ATTRIBUTES</span> <span class="n">lpSecurityAttributes</span><span class="p">,</span>   <i class="conum" data-value="4"></i><b>(4)</b>
  <span class="n">DWORD</span> <span class="n">dwCreationDisposition</span><span class="p">,</span>                  <i class="conum" data-value="5"></i><b>(5)</b>
  <span class="n">DWORD</span> <span class="n">dwFlagsAndAttributes</span><span class="p">,</span>                   <i class="conum" data-value="6"></i><b>(6)</b>
  <span class="n">HANDLE</span> <span class="n">hTemplateFile</span>                          <i class="conum" data-value="7"></i><b>(7)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre del archivo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Modo de acceso: lectura o escritura.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Modo en el que se compartirÃ¡ el archivo con otros procesos que accedan al mismo tiempo.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Permisos del archivo, en caso de crearlo.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>AcciÃ³n en caso de que el archivo exista o no: siempre crear, solo abrir, truncar si existe, etc.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Atributos del archivo, en caso de crearlo.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Archivo abierto del que copiar los atributos para copiarlo en Ã©ste,
en caso de crearlo.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>que <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> no posee:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">FILE</span><span class="o">*</span> <span class="nf">fopen</span><span class="p">(</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mode</span>  <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre del archivo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Modo de acceso: lectura o escritura.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sin embargo, debemos tener en cuenta que se pierde portabilidad pues <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a> solo estÃ¡ disponible en Microsoft Window, mientras que <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> viene con la librerÃ­a estÃ¡ndar de cualquier compilador de C.</p>
</div>
<div class="paragraph">
<p>En la <a href="#api_posix">Figura 19</a> se puede observar un ejemplo similar en <a href="https://es.wikipedia.org/wiki/GNU/Linux">GNU/Linux</a> âun sistema compatible <a href="https://es.wikipedia.org/wiki/POSIX">POSIX</a>â pero en esta ocasiÃ³n con programas en C y C&#43;&#43;.
En este caso la llamada al sistema es <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> y tanto <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> en C como <a href="https://en.cppreference.com/w/cpp/io/basic_ofstream/open">std::ofstream::open()</a>1 en C&#43;&#43; la utilizan.
AdemÃ¡s, ambos lenguajes pueden invocar directamente la librerÃ­a del sistema âmarcado en rojo en la <a href="#api_posix">Figura 19</a>â si necesitan alguna caracterÃ­stica adicional de la funciÃ³n <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>.</p>
</div>
<div id="api_posix" class="imageblock">
<div class="content">
<img src="C06-api/images/interfaz_programaciÃ³n_aplicaciones_posix.svg" alt="interfaz programaciÃ³n aplicaciones posix">
</div>
<div class="title">Figura 19. Elementos de la interfaz de programaciÃ³n de aplicaciones en GNU/Linux.</div>
</div>
<div class="paragraph">
<p>La Ãºnica diferencia es que en <a href="#api_posix">Figura 19</a> las funciones <a href="https://en.cppreference.com/w/c/io/fopen">fopen()</a> y <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a> estÃ¡n realmente en la misma librerÃ­a, porque en los sistemas POSIX la librerÃ­a del sistema y la librerÃ­a estÃ¡ndar de C pueden ser la misma, dado que el estÃ¡ndar POSIX se diseÃ±Ã³ como un superconjunto de la librerÃ­a estÃ¡ndar de C.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operaciÃ³n_del_sistema_operativo">7. OperaciÃ³n del sistema operativo</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>16 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Dado que el sistema operativo y los procesos de usuarios comparten los recursos del sistema informÃ¡tico, necesitamos estar seguros de que un error en un programa sÃ³lo afecte al proceso que lo ejecuta âpor ejemplo, que un proceso no puede modificar la memoria de otro proceso o la del nÃºcleo del sistemaâ.
Por eso es necesario establecer mecanismos de protecciÃ³n frente a los errores en los programas que se ejecutan en el sistema.</p>
</div>
<div class="sect2">
<h3 id="_software_controlado_mediante_interrupciones">7.1. Software controlado mediante interrupciones</h3>
<div class="paragraph">
<p>Antes de entender como funcionan estos mecanismos de protecciÃ³n debemos entender que los sistemas operativos modernos pertenecen a un tipo de software que se dice que estÃ¡ controlado mediante interrupciones.</p>
</div>
<div class="paragraph">
<p>Los sucesos que requieren la atenciÃ³n del sistema casi siempre se indican mediante una interrupciÃ³n:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando un proceso comete un error âcomo una divisiÃ³n por cero o un acceso a memoria no vÃ¡lidoâ o un programa solicita un servicio al sistema operativo a travÃ©s de una llamada al sistema lo que se genera es una excepciÃ³n.
Esta excepciÃ³n despierta al sistema operativo para que haga lo que sea mÃ¡s conveniente.</p>
</li>
<li>
<p>Cuando un proceso necesita un servicio lo que hace es lanzar una llamada al sistema, que no es mÃ¡s que ejecutar una instrucciÃ³n que lanza una excepciÃ³n.
Esta excepciÃ³n despierta al sistema operativo para que atienda la peticiÃ³n.</p>
</li>
<li>
<p>Cuando los dispositivos de E/S requieren la atenciÃ³n del sistema operativo âpor ejemplo, porque se ha completado una transferencia de datosâ se genera una interrupciÃ³n que despierta al sistema operativo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Esto funciona asÃ­ porque el sistema operativo configura la CPU durante el arranque para que si ocurre cualquier interrupciÃ³n o excepciÃ³n la ejecuciÃ³n, salte a rutinas en el cÃ³digo del nÃºcleo, con el objeto de darles el tratamiento adecuado.</p>
</div>
<div class="paragraph">
<p>Si ningÃºn proceso realiza una acciÃ³n ilegal o pide un servicio, ni ningÃºn dispositivo de E/S pide la atenciÃ³n del sistema, el sistema operativo permanece inactivo esperado a que algo ocurra.</p>
</div>
<div class="paragraph">
<p>Teniendo todo esto en cuenta podremos entender mejor como funciona el modo dual.</p>
</div>
</div>
<div class="sect2">
<h3 id="_operaciÃ³n_en_modo_dual">7.2. OperaciÃ³n en modo dual</h3>
<div class="paragraph">
<p>Para proteger el sistema de programas con errores es necesario poder distinguir entre la ejecuciÃ³n de cÃ³digo del sistema operativo y del cÃ³digo de los programas de usuario, de tal forma que el cÃ³digo de los programas de usuario estÃ© mÃ¡s limitado en lo que puede hacer que el del sistema operativo.</p>
</div>
<div class="paragraph">
<p>El mÃ©todo que utilizan la mayor parte de los sistemas operativos consiste en utilizar algÃºn tipo de soporte en la CPU que permita diferenciar entre varios modos de ejecuciÃ³n y restringir la utilizaciÃ³n de las instrucciones peligrosas âllamadas <strong>instrucciones privilegiadas</strong>â para que sÃ³lo puedan ser utilizadas en el modo en el que se ejecuta el cÃ³digo del sistema operativo.</p>
</div>
<div class="sect3">
<h4 id="_modos_de_operaciÃ³n">7.2.1. Modos de operaciÃ³n</h4>
<div class="paragraph">
<p>AsÃ­ que como mÃ­nimo son necesarios dos modos de operaciÃ³n diferentes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>En el <strong>modo usuario</strong>, en el que se ejecuta el cÃ³digo de los procesos de los usuarios.
Si se hace un intento de ejecutar una instrucciÃ³n privilegiada en este modo, el hardware la trata como ilegal y genera una excepciÃ³n que es interceptada por el sistema operativo, en lugar de ejecutar la instrucciÃ³n.</p>
</li>
<li>
<p>En el <strong>modo privilegiado</strong> âtambiÃ©n denominado <strong>modo supervisor</strong>, <strong>modo del sistema</strong> o <strong>modo kernel</strong>â se ejecuta el cÃ³digo de las tareas del sistema operativo.
La CPU es la encargada de garantizar que las instrucciones privilegiadas sÃ³lo pueden ser ejecutadas en este modo.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>El modo actual de operaciÃ³n puede venir indicado por un <strong>bit de modo</strong> en alguno de los registros de configuraciÃ³n de la CPU, de tal forma que, si por ejemplo, el bit estÃ¡ a 0, la CPU considera que el cÃ³digo en ejecuciÃ³n opera en modo privilegiado, mientras que si el bit estÃ¡ a 1, el cÃ³digo en ejecuciÃ³n opera en modo usuario.</p>
</div>
<div class="paragraph">
<p>ComÃºnmente en el grupo de las <strong>instrucciones privilegiadas</strong> se suelen incluir:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La instrucciÃ³n para conmutar al modo usuario desde el modo privilegiado.</p>
</li>
<li>
<p>Las instrucciones para acceder a dispositivos de E/S.</p>
</li>
<li>
<p>Las instrucciones necesarias para la gestiÃ³n de las interrupciones.
Por ejemplo, para desactivarlas âevitando que se lancenâ, activarlas y configurarlas.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Niveles de privilegio en procesadores x86</div>
<div class="paragraph">
<p>Aunque para operar en modo dual solo se necesita que la CPU admita los dos modos descritos, existen procesadores que soportan mÃ¡s, con la idea de tener mayor control sobre el nivel de privilegio en el que se ejecuta cada componente del sistema.</p>
</div>
<div class="paragraph">
<p>Es el caso de la arquitectura Intel x86, que soporta 4 modos de operaciÃ³n.
El modo 0 es para el software mÃ¡s confiable y el que necesita mÃ¡s privilegios, que generalmente es el nÃºcleo.
Mientras que el modo 3 se utiliza para el software menos confiable y que necesita mÃ¡s supervisiÃ³n, que normalmente son los procesos de usuario.</p>
</div>
<div class="paragraph">
<p>La idea detrÃ¡s de tener los modos 1 y 2 es usarlos para controladores de dispositivo o procesos que dan servicio al resto del sistema.
AsÃ­ estos componentes pueden tener mayores privilegios que los procesos de usuario âpor ejemplo, los controladores de dispositivo necesitan acceso directo al hardwareâ pero al mismo tiempo serÃ­an supervisados y no podrÃ­an afectar al nÃºcleo, que se ejecuta en el modo 0.</p>
</div>
<div class="paragraph">
<p>Sin embargo, los sistemas operativos con mayor cuota de mercado âincluyendo Microsoft Windows, macOS, Linux y Androidâ solo utilizan los modos 0 y 3.
Los motivos son que los desarrolladores de sistemas no encuentran realmente ninguna ventaja en utilizar mÃ¡s modos y que complica portar el sistema operativo a procesadores donde solo se soporten dos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
En procesadores x86 recientes, que vienen con instrucciones especÃ­ficas para facilitar la ejecuciÃ³n de mÃ¡quinas virtuales, se ha incorporado un modo -1, para que el nÃºcleo del sistema operativo virtualizado se ejecute en el modo 0 mientras es supervisado desde el modo -1 por el nÃºcleo del sistema operativo anfitriÃ³n.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Para mÃ¡s informaciÃ³n, vÃ©ase <a href="https://es.wikipedia.org/wiki/Anillo_(seguridad_inform%C3%A1tica)">Â«Anillo (seguridad informÃ¡tica)&#8201;&#8212;&#8201;WikipediaÂ»</a>.</p>
</div>
<hr>
<div class="paragraph">
<p>En los procesadores x86 es importante no confundir los <strong>modos real</strong> y <strong>protegido</strong> con el modo dual y los niveles de privilegio de los que estamos hablando.</p>
</div>
<div class="paragraph">
<p>Por compatibilidad hacia atrÃ¡s, los procesadores x86 se inician en modo real, donde se comportan como una CPU <a href="https://es.wikipedia.org/wiki/Intel_8086_y_8088">Intel 8086</a>.
En este modo, por ejemplo, solo tienen acceso al primer mega de memoria RAM âya que los procesadores <a href="https://es.wikipedia.org/wiki/Intel_8086_y_8088">Intel 8086</a> solo tenÃ­an 20 bits para direcciones de memoriaâ.</p>
</div>
<div class="paragraph">
<p>Cuando un sistema operativo moderno arranca, lo primero que hace es iniciar el modo protegido, en el que se activan todas las caracterÃ­sticas de la CPU.
Entra otras, el direccionamiento de 32 o 64 bits âsegÃºn el procesador que seaâ y la posibilidad de usar los 4 niveles de privilegio, de los que hemos hablado, para que el nÃºcleo pueda supervisar al resto de componentes.</p>
</div>
<div class="paragraph">
<p>Para mÃ¡s informaciÃ³n, vÃ©ase <a href="https://es.wikipedia.org/wiki/Modo_protegido">Â«Modo protegido&#8201;&#8212;&#8201;WikipediaÂ»</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejecuciÃ³n_de_instrucciones">7.2.2. EjecuciÃ³n de instrucciones</h4>
<div class="paragraph">
<p>A continuaciÃ³n podemos ver el ciclo de vida de la ejecuciÃ³n de instrucciones en un sistema con modo dual de operaciÃ³n:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Inicialmente, al arrancar el ordenador, la CPU se inicia en el modo privilegiado âes decir, en nuestro ejemplo, con el bit de modo a 0â.
En este modo se carga el nÃºcleo del sistema operativo e inicia su ejecuciÃ³n.</p>
</li>
<li>
<p>El nÃºcleo del sistema operativo debe cambiar al modo usuario âponiendo el bit de modo a 1â antes de ceder la CPU a un proceso de usuario.
Esto ocurre cuando es necesario que un proceso de usuario continÃºe o inicie su ejecuciÃ³n (vÃ©ase el <a href="#_el_asignador">Apartado 14.2</a>).
AsÃ­ se asegura que el cÃ³digo de los procesos de usuario siempre se ejecuten en modo usuario, con menos privilegios.</p>
</li>
<li>
<p>La CPU conmuta a modo privilegiado cuando ocurre una interrupciÃ³n o una excepciÃ³n âponiendo el bit de modo a 0â antes de comenzar el cÃ³digo del sistema operativo que se encargarÃ¡ de tratarlas.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Esto Ãºltimo es muy importante.
Como ya hemos comentado, los sistemas operativos estÃ¡n controlados mediante interrupciones.
Al activarse el modo privilegiado cada vez que ocurre una interrupciÃ³n, podemos estar seguros de que las tareas del sistema operativo se ejecutarÃ¡n siempre en modo privilegiado.</p>
</div>
<div class="paragraph">
<p>Cuando se dispone de la protecciÃ³n del modo dual, el hardware se encarga de detectar los errores de ejecuciÃ³n y de notificarlo al sistema operativo mediante excepciones, siendo responsabilidad de este Ãºltimo realizar un tratamiento adecuado de los mismos.
Por lo general, si un programa falla de alguna forma âcomo por ejemplo, intentando utilizar una instrucciÃ³n ilegal o de acceder a una zona de memoria invÃ¡lidaâ el sistema operativo lo hace terminar.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_protecciÃ³n_de_la_memoria">7.3. ProtecciÃ³n de la memoria</h3>
<div class="paragraph">
<p>La memoria principal debe acomodar tanto el sistema operativo como a los diferentes procesos de los usuarios.
Por eso la memoria normalmente se divide en dos partes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>La primera parte sirve para albergar el nÃºcleo del sistema operativo.</p>
<div class="paragraph">
<p>El sistema operativo puede estar localizado tanto en la parte baja como en la parte alta de la memoria.
El factor determinante en la elecciÃ³n es la localizaciÃ³n del vector de interrupciones, que es una tabla en la memoria que define las direcciones a las que saltarÃ¡ la CPU en caso de que ocurra una interrupciÃ³n o una excepciÃ³n.</p>
</div>
<div class="paragraph">
<p>Puesto que en la mayor parte de las arquitecturas Ã©ste reside en la parte baja de la memoria, normalmente el sistema operativo tambiÃ©n se aloja en la parte baja.</p>
</div>
</li>
<li>
<p>La segunda parte alberga los procesos de usuario.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Sin embargo, en los sistemas operativos modernos, los procesos no tienen acceso libre a toda memoria fÃ­sica, con el objeto de proteger a los procesos en ejecuciÃ³n y al sistema operativo de posibles errores en cualquiera de ellos:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>El sistema operativo proporciona a cada proceso una Â«vistaÂ» privada de la memoria RAM; similar a la que tendrÃ­an si cada uno de ellos se estuviera ejecutando en solitario (vÃ©ase la <a href="#protecciÃ³n_memoria">Figura 20</a>).</p>
</li>
<li>
<p>A esa Â«vistaÂ» que tiene cada proceso de la memoria es a lo que se denomina <strong>espacio de direcciones virtual</strong> del proceso.
EstÃ¡ formada por el conjunto de todas las direcciones que puede generar la CPU para un proceso dado.
Por ejemplo, en una CPU de 32 bits el espacio de direcciones virtual tiene 4GB, desde la direcciÃ³n 0x00000000 a 0xFFFFFFFF.</p>
</li>
<li>
<p>En los accesos a la memoria principal durante la ejecuciÃ³n del proceso, estas <strong>direcciones virtuales</strong> son convertidas por la CPU en direcciones fÃ­sicas, antes de ser enviadas a la memoria principal.
Por tanto las <strong>direcciones fÃ­sicas</strong> son las direcciones reales que ve la memoria.
Mientras que el <strong>espacio de direcciones fÃ­sico</strong> es el conjunto de direcciones fÃ­sicas que corresponden a todas las direcciones virtuales de un espacio de direcciones virtual dado.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="protecciÃ³n_memoria" class="imageblock">
<div class="content">
<img src="C07-modo_dual/images/protecciÃ³n_memoria.svg" alt="protecciÃ³n memoria">
</div>
<div class="title">Figura 20. Mapeo de la memoria fÃ­sica en el espacio de direcciones virtual de un proceso.</div>
</div>
<div class="paragraph">
<p>La conversiÃ³n de una direcciÃ³n virtual en una fÃ­sica, la realiza en tiempo de ejecuciÃ³n un componente de la CPU denominado MMU (<em>Memory-Management Unit</em>).</p>
</div>
<div class="paragraph">
<p>Las ventajas de usar esta tÃ©cnica, desde el punto de vista de la protecciÃ³n de la memoria son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Permite el aislamiento de los procesos, creando para cada uno la ilusiÃ³n de que toda la memoria es para Ã©l y evitando que un proceso pueda acceder a la memoria de otros procesos.</p>
</li>
<li>
<p>Permite marcar modos de acceso autorizados en las diferentes regiones de la memoria âcomo por ejemplo lectura, escritura y ejecuciÃ³nâ evitando que el cÃ³digo ejecutado en modo usuario tenga acceso a zonas a las que no deberÃ­a tenerlo.
El acceso a la memoria en un modo no autorizado se considera una instrucciÃ³n privilegiada, por lo que ese tipo de acceso desde el modo usuario siempre genera una excepciÃ³n.
Por ejemplo, si se intenta ejecutar instrucciones en una zona de memoria no marcada con el permiso de ejecuciÃ³n.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_el_temporizador">7.4. El temporizador</h3>
<div class="paragraph">
<p>El <strong>temporizador</strong> se configura por el sistema operativo durante el arranque del sistema para interrumpir a la CPU a intervalos regulares.
AsÃ­, cuando el temporizador interrumpe, el control se transfiere automÃ¡ticamente al nÃºcleo del sistema.
Entonces Ã©ste puede:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Conceder mÃ¡s tiempo al proceso en ejecuciÃ³n.</p>
</li>
<li>
<p>Detenerlo y darle mÃ¡s tiempo de CPU en el futuro</p>
</li>
<li>
<p>Tratar la interrupciÃ³n como un error y terminar el programa.</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>El temporizador se utiliza para asegurar que ningÃºn proceso acapara la CPU indefinidamente.
Por ejemplo, un programa mal desarrollado que entra en un bucle infinito, del que no sale jamÃ¡s.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Obviamente, las instrucciones que pueden modificar el contenido del temporizador son instrucciones privilegiadas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_maquinas_virtuales">7.5. Maquinas virtuales</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Utilizando las tÃ©cnicas comentadas anteriormente, el sistema operativo crea a los procesos la ilusiÃ³n de que se ejecutan en su propio procesador y memoria principal, aunque realmente los comparten.
Aun asÃ­, los procesos saben que hay un sistema operativo que los supervisa, porque le deben solicitar a Ã©l los distintos recursos a travÃ©s de las llamadas al sistema.</p>
</div>
<div class="paragraph">
<p>Una mÃ¡quina virtual tambiÃ©n es un proceso en un sistema operativo una mÃ¡quina real âtambiÃ©n llamado sistema operativo anfitriÃ³nâ.
Se utilizan la mismas tÃ©cnicas para crear la ilusiÃ³n de que se ejecuta en su propia mÃ¡quina.
Sin embargo, en lugar de llamadas al sistema, el software que gestiona la mÃ¡quina virtual ofrece una interfaz de hardware virtual.
Es decir:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El sistema operativo de la mÃ¡quina virtual intenta acceder al hardware, ya que presupone que se ejecuta en una mÃ¡quina real.</p>
</li>
<li>
<p>El sistema operativo anfitriÃ³n intercepta estos intentos âya que son instrucciones privilegiadas, prohibidas para los procesos en el modo usuarioâ y, en lugar de detener el proceso, comunica el suceso al software de gestiÃ³n de la mÃ¡quina virtual.</p>
</li>
<li>
<p>El software de gestiÃ³n de la mÃ¡quina virtual identifica a quÃ© dispositivo y que intenta hacer el sistema operativo de la mÃ¡quina virtual en Ã©l âpara lo que generalmente se utilizan mÃ¡quinas de estado que simulan el comportamiento del hardware realâ y lo transforma en peticiones al sistema operativo anfitriÃ³n.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Por ejemplo, los intentos del sistema operativo virtual de acceder a los discos duros del hardware virtual, son convertidos en operaciones sobre un archivo, en un sistema de archivos real que contiene la imagen en disco de la mÃ¡quina virtual.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arranque_del_sistema">7.6. Arranque del sistema</h3>
<div class="paragraph">
<p>Desde el momento en que el ordenador se pone en marcha hasta que el sistema operativo inicia
su ejecuciÃ³n se realizan una serie de operaciones.
Estos son los pasos mÃ¡s comunes en el arranque de un sistema:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Llega a la CPU una seÃ±al de RESET motivada por el encendido del sistema o por un reinicio.</p>
</li>
<li>
<p>La CPU inicializa el contador de programa a una direcciÃ³n predefinida de la memoria.
En esa direcciÃ³n estÃ¡ el <em>bootstrap</em> inicial.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El <em>bootstrap</em> es el programa que se encarga en primera instancia del arranque.
Debe estar almacenado en una memoria no volÃ¡til âROM o Flashâ por que la RAM estÃ¡ en un estado indeterminado en el momento del arranque.</p>
</div>
<div class="paragraph">
<p>En los PC el <em>bootstrap</em> forma parte del <em>firmware</em> âsea BIOS o UEFIâ de las placas madres.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El tÃ©rmino <em>firmware</em> viene de que por sus caracterÃ­sticas se sitÃºa en algÃºn lugar entre el hardware y el software.
Concretamente es un componente de software instalado en un dispositivo hardware para encargase de su control a bajo nivel.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_tareas_del_bootstrap">7.6.1. Tareas del bootstrap</h4>
<div class="paragraph">
<p>El <em>bootstrap</em> debe realizar diversas tareas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Diagnostico de la mÃ¡quina</strong> âo <em>Power-on Self-Test</em> (POST)â.
El <em>bootstrap</em> se detiene en este punto si el sistema no supera el diagnostico.</p>
</li>
<li>
<p><strong>Inicializar el sistema</strong>.
Por ejemplo, configurar los registros de la CPU, inicializar los dispositivos y contenido de la memoria, etc.</p>
</li>
<li>
<p><strong>Iniciar el sistema operativo</strong>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Al iniciar el sistema operativo hay que considerar que puede estar en diferentes ubicaciones segÃºn el tipo de dispositivo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En <strong>consolas de videojuegos, mÃ³viles y otros dispositivos empotrados</strong> se almacena el sistema operativo en alguna forma de memoria de sÃ³lo lectura âROM o Flashâ.
Como la ejecuciÃ³n en esas memorias es mÃ¡s lenta que en la RAM, muchas veces el <em>bootstrap</em> suele copiar el sistema a la RAM durante el arranque, antes de iniciarlo.</p>
</li>
<li>
<p>En <strong>sistemas operativos de gran tamaÃ±o</strong> âincluidos los de propÃ³sito generalâ el sistema se almacena en disco.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En los sistemas mas antiguos, el <em>bootstrap</em> lee de una posiciÃ³n fija del disco âgeneralmente el bloque 0â el gestor de arranque, lo copia en la memoria y lo ejecuta.
Esto es lo que ocurre en los PC mÃ¡s antiguos que utilizan BIOS y particiones MBR.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>TambiÃ©n se llama MBR a ese bloque 0 del disco donde estÃ¡ el gestor de arranque.
De hecho MBR son las siglas de <em>Master Boot Record</em> o <a href="https://es.wikipedia.org/wiki/Registro_de_arranque_principal">registro de arranque principal</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Aunque en ocasiones el cÃ³digo de ese bloque inicial de arranque sabe cargar e iniciar el sistema operativo completo, es comÃºn que sÃ³lo sepa donde estÃ¡ el resto del gestor de arranque en el disco, para cargarlo y ejecutarlo.
No debemos olvidar que el cÃ³digo cargado por el <em>bootstrap</em> debe caber en un sÃ³lo bloque del disco, que generalmente tiene solo 512 bytes.</p>
</div>
<div class="paragraph">
<p>En los PC mÃ¡s modernos que utilizan UEFI y particiones GPT, la UEFI tiene la capacidad de leer el sistema de archivo en las particiones para buscar directamente los archivos del gestor de arranque completo.
Una vez el <em>bootstrap</em> los encuentra, los carga y ejecuta.</p>
</div>
<div class="paragraph">
<p>En ambos casos, el gestor de arranque completo es el programa que sabe como iniciar el sistema operativo asÃ­ que: explora el sistema de ficheros en busca del nÃºcleo del sistema, lo carga e inicia su ejecuciÃ³n.</p>
</div>
<div class="paragraph">
<p>A partir de esto punto cada sistema operativo prosigue de forma diferente.
A modo de ejemplo, veremos como prosigue el arranque en sistemas UNIX en modo texto.</p>
</div>
</div>
<div class="sect3">
<h4 id="_arranque_de_sistemas_unix">7.6.2. Arranque de sistemas UNIX</h4>
<div class="paragraph">
<p>Al iniciarse el nÃºcleo del sistema, este realiza una serie de tareas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Configura el sistema para crear un entorno adecuado para la ejecuciÃ³n de los procesos: configuraciÃ³n de interrupciones, configuraciÃ³n de los modos de ejecuciÃ³n âprivilegiado y usuarioâ y de la gestiÃ³n de la memoria; inicializaciÃ³n de dispositivos y controladores; montaje del sistema de ficheros raÃ­z; creaciÃ³n del proceso inactivo âque se ejecutarÃ¡ cuando no haya nada que hacerâ etc.</p>
</li>
<li>
<p>Crea el proceso <strong>init</strong> âque por ser el primero tiene PID 1â a partir de la carga del programa <code>init</code> almacenado en el sistema de ficheros raÃ­z.
En los sistemas GNU/Linux actuales el proceso <strong>init</strong> mÃ¡s comÃºn es <a href="https://es.wikipedia.org/wiki/Systemd">systemd</a>.</p>
</li>
<li>
<p>El planificador de la CPU toma el control de la gestiÃ³n de la CPU y el nÃºcleo queda dormido.
Puesto que la funciÃ³n del planificador es asignar procesos a la CPU y solo hay uno, el proceso <strong>init</strong>, Ã©ste es escogido y comienza su ejecuciÃ³n.</p>
</li>
<li>
<p>El proceso <strong>init</strong> lanza los <em>scripts</em> encargados de configurar los servicios âtambiÃ©n llamados demoniosâ del sistema.
Por ejemplo, para el registro de eventos del sistema, gestiÃ³n de dispositivos, particiones, impresoras, entre otros.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El proceso <strong>init</strong> tambiÃ©n configura el entorno de usuario.
Configura las terminales del sistema, inicia un proceso <strong>login</strong> conectado a cada una y se duerme a la espera.
Estos procesos <strong>login</strong> son monitorizados por <strong>init</strong> para reiniciarlos en caso de que mueran.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Aunque, por lo general, un sistema de escritorio tiene una Ãºnica pareja de teclado y monitor y, por lo tanto, una Ãºnica terminal real; el sistema suele esta configurado para crear varios terminales virtuales entre los que el usuario puede conmutar usando las combinaciones de teclas adecuadas.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Los procesos <strong>login</strong> se encargan de autenticar a los usuarios y de iniciar y configurar su sesiÃ³n:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Muestran una pantalla de inicio de sesiÃ³n donde se solicita el nombre del usuario y su contraseÃ±a.</p>
</li>
<li>
<p>Autentican al usuario comprobando las credenciales proporcionadas por el mismo.</p>
</li>
<li>
<p>Si la autenticaciÃ³n es positiva, el proceso <strong>login</strong> cambia su identidad actual âgeneralmente de <em>root</em> o administrador del sistemaâ por la del usuario autenticado, configura la sesiÃ³n y sustituye su programa actual por el del intÃ©rprete de comandos que tiene configurado ese usuario (vÃ©ase el <a href="#procesos_posix_api">Apartado 9.7.3.2</a>).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El interprete de comandos completa la configuraciÃ³n del entorno en base a sus ficheros de configuraciÃ³n, muestra el <a href="https://es.wikipedia.org/wiki/Prompt">prompt</a> y queda a la espera del primer comando del usuario.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sistemas_operativos_por_su_estructura">8. Sistemas operativos por su estructura</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>9 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Ya hemos discutido anteriormente acerca de los componentes mÃ¡s comunes en un sistema operativo (vÃ©ase el <a href="#_componentes_del_sistema">CapÃ­tulo 4</a>).
En esta secciÃ³n comentaremos cÃ³mo se clasifican los distintos sistemas operativos segÃºn la organizaciÃ³n e interconexiÃ³n de sus componentes.</p>
</div>
<div class="sect2">
<h3 id="_estructura_sencilla">8.1. Estructura sencilla</h3>
<div class="paragraph">
<p></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los sistemas con <strong>estructura sencilla</strong> se caracterizan por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No tener una estructura bien definida.
Los componentes no estÃ¡n bien separados y las interfaces entre ellos no estÃ¡n bien definidas.</p>
</li>
<li>
<p>Son sistemas <strong>monolÃ­ticos</strong>, dado que gran parte de la funcionalidad del sistema se implementa en el nÃºcleo.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ms_dos_2">8.1.1. MS-DOS</h4>
<div class="paragraph">
<p>Por ejemplo, en el <a href="https://es.wikipedia.org/wiki/MS-DOS">MS-DOS</a> los programas de aplicaciÃ³n podÃ­an acceder directamente a toda la memoria y a cualquier dispositivo.
Disponiendo de esa libertad un programa errÃ³neo cualquiera podÃ­a corromper el sistema completo.</p>
</div>
<div id="estructura_msdos" class="imageblock">
<div class="content">
<img src="C08-estructura/images/estructura_msdos.svg" alt="estructura msdos">
</div>
<div class="title">Figura 21. Esquema de la estructura de MS-DOS.</div>
</div>
<div class="paragraph">
<p>Como el <a href="https://es.wikipedia.org/wiki/Intel_8086_y_8088">Intel 8086</a> para el que fue escrito MS-DOS no proporcionaba un modo dual de operaciÃ³n, los diseÃ±adores del sistema no tuvieron mÃ¡s opciÃ³n que dejar accesible el hardware a los programas de usuario.</p>
</div>
</div>
<div class="sect3">
<h4 id="_unix_2">8.1.2. UNIX</h4>
<div class="paragraph">
<p>Otro ejemplo es el de <a href="https://es.wikipedia.org/wiki/Unix">UNIX original</a>, donde si habÃ­a una separaciÃ³n clara entre procesos de usuario y cÃ³digo del sistema, pero juntaba un montÃ³n de funcionalidad en el nÃºcleo del sistema.</p>
</div>
<div id="estructura_unix" class="imageblock">
<div class="content">
<img src="C08-estructura/images/estructura_unix.svg" alt="estructura unix">
</div>
<div class="title">Figura 22. Esquema de la estructura de UNIX.</div>
</div>
<div class="paragraph">
<p>El nÃºcleo proporciona la planificaciÃ³n de CPU, la gestiÃ³n de la memoria, el soporte de los sistemas de archivos y muchas otras funcionalidades del sistema operativo.
En general se trata de una enorme cantidad de funcionalidad que es difÃ­cil de implementar y mantener, si no se compartimenta adecuadamente.</p>
</div>
<div class="paragraph">
<p>Tanto MS_DOS como UNIX eran originalmente sistemas pequeÃ±os y simples, limitados por las funcionalidades del hardware de su Ã©poca, que fueron creciendo mÃ¡s allÃ¡ de las previsiones originales.
Lo cierto es que con mejor soporte del hardware se puede dividir el sistema operativo en piezas mÃ¡s pequeÃ±as y apropiadas que las del MS-DOS y el UNIX original.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructura_en_capas">8.2. Estructura en capas</h3>
<div class="paragraph">
<p></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los sistemas con <strong>estructura en capas</strong> se caracterizan por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La funcionalidad se divide en capas, de tal forma que una capa solo utiliza funciones y servicios de la capa inmediatamente inferior y lo hace a travÃ©s de una interfaz bien definida.</p>
</li>
<li>
<p>Como en la programaciÃ³n orientada a objetos, cada capa oculta a la capa superior los detalles de su implementaciÃ³n.
Por ejemplo, las estructuras de datos internas que usa y las operaciones o el hardware de la capa inferior que utiliza.</p>
</li>
<li>
<p>Escalan mejor que los sistemas con <strong>estructura sencilla</strong> porque las capas hacen que el cÃ³digo estÃ© mejor compartimentado.
Por ejemplo, al corregir un <em>bug</em> o aÃ±adir una nueva funcionalidad solo hay que preocuparse de su efecto en la capa a la que afecta y no en todo el cÃ³digo del nÃºcleo âsiempre que no se altere la interfaz de la capa con el exteriorâ.</p>
</li>
<li>
<p>Ser menos eficiente que la de los sistemas de <strong>estructura sencilla</strong>.
En cada capa los argumentos son transformados y los datos necesarios deben de ser transferidos al invocar operaciones en la capa inferior, por lo que cada una aÃ±ade cierto nivel de sobrecarga al funcionamiento del sistema.</p>
</li>
<li>
<p>TambiÃ©n son sistemas <strong>monolÃ­ticos</strong>, dado que gran parte de la funcionalidad del sistema se implementa en el nÃºcleo, aunque ahora el nÃºcleo estÃ© compartimentado en capas.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Un ejemplo de este tipo de sistemas operativos es el <a href="https://es.wikipedia.org/wiki/OS/2">OS/2</a>.</p>
</div>
<div id="estructura_os2" class="imageblock">
<div class="content">
<img src="C08-estructura/images/estructura_os2.svg" alt="estructura os2">
</div>
<div class="title">Figura 23. Esquema de la estructura de IBM OS/2.</div>
</div>
<div class="sect3">
<h4 id="_dificultades_con_el_diseÃ±o">8.2.1. Dificultades con el diseÃ±o</h4>
<div class="paragraph">
<p>Es importante tener en cuenta que diseÃ±ar un sistema con <strong>estructura en capas</strong> no es tan sencillo como pudiera parecer.
La definiciÃ³n de las capas y sus funcionalidades debe ser planificada cuidadosamente debido a la restricciÃ³n, comentada anteriormente, de que un capa sÃ³lo puede utilizar los servicios de las capas inferiores.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, el planificador de la CPU suele tener informaciÃ³n de los procesos que estÃ¡n en la memoria.
Parte de esa informaciÃ³n puede ser almacenada en el disco para aumentar la memoria principal disponible.
Esto nos deberÃ­a llevar a pensar que la gestiÃ³n del almacenamiento secundario debe ir en una capa inferior a la del planificador de la CPU, para que asÃ­ el segundo pueda pedir al primero que guarde los datos en disco.</p>
</div>
<div class="paragraph">
<p>Sin embargo, el planificador de la CPU debe asignar la CPU a otro proceso cuando el proceso que actualmente la ocupa solicita alguna operaciÃ³n de E/S âlo tÃ­pico en multiprogramaciÃ³nâ.
Como es la gestiÃ³n del almacenamiento secundario el que debe pedir una operaciÃ³n al planificador de la CPU, ahora el primero debe estar sobre el segundo.</p>
</div>
<div class="paragraph">
<p>La soluciÃ³n a esta dependencia circular es hacer que ambos componentes estÃ©n en la misma capa.
Este tipo de dependencias no son raras, ocurre en muchos otros casos, ya que los componentes del sistema operativo suelen depender mucho unos de otros.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Al final, la soluciÃ³n de compromiso es tender hacia sistemas con muy pocas capas donde cada una tiene mucha funcionalidad.
Esto limita mucho las ventajas de esta tÃ©cnica porque no permite compartimentar el nÃºcleo tanto como serÃ­a deseable.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_microkernel">8.3. Microkernel</h3>
<div class="paragraph">
<p>
</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los sistemas con <strong>estructura microkernel</strong> se caracterizan por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Eliminar todos los componentes no esenciales del nÃºcleo e implementarlos como procesos a nivel de usuario.</p>
</li>
<li>
<p>Un nÃºcleo <strong>microkernel</strong> proporciona funciones mÃ­nimas de gestiÃ³n de procesos y de memoria y algÃºn mecanismo de comunicaciÃ³n entre procesos.
Sin embargo, hay que tener en cuenta que hay poco consenso a este respecto, por lo que algunos <strong>microkernel</strong> reales incluyen en el nÃºcleo algunas funcionales adicionales.</p>
</li>
<li>
<p>El mecanismo de comunicaciÃ³n permite a los procesos de los usuarios solicitar servicios a los componentes del sistema.
TambiÃ©n sirve para que los componentes del sistema se comuniquen entre sÃ­ y se pidan servicio.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Dado que los componentes del sistema estÃ¡n aislados unos de otros âya que se implementan como procesos de usuarioâ el mecanismo de comunicaciÃ³n entre procesos es la Ãºnica forma que tienen los procesos de los usuarios y los componentes, de solicitarles un servicio.</p>
</div>
<div id="estructura_minix3" class="imageblock">
<div class="content">
<img src="C08-estructura/images/estructura_minix3.svg" alt="estructura minix3">
</div>
<div class="title">Figura 24. Esquema de la estructura microkernel de MINIX 3.</div>
</div>
<div class="paragraph">
<p>Generalmente esta comunicaciÃ³n se implementa mediante paso de mensajes (vÃ©ase el <a href="#_comunicaciÃ³n_entre_procesos">Apartado 9.8.2</a>).</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Entre los beneficios de estos sistemas operativos se incluyen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Facilidad a la hora de aÃ±adir nuevas funcionalidades</strong>.
Los nuevos servicios son aÃ±adidos como aplicaciones de nivel de usuario, por lo que no es necesario hacer modificaciones en el nÃºcleo.
Desarrollar en el modo privilegiado siempre es mÃ¡s peligrosos que en el modo usuario porque los errores pueden ser catastrÃ³ficos: bloqueo o caÃ­da del sistema, corrupciÃ³n de datos, etc.</p>
</li>
<li>
<p><strong>Facilidad a la hora de portar el sistema a otras plataformas</strong>.
Puesto que el nÃºcleo es muy pequeÃ±o, resulta muy sencillo de portar a otras plataformas.</p>
</li>
<li>
<p><strong>MÃ¡s seguridad y fiabilidad</strong>.
Puesto que la mayor parte de los servicios se ejecutan a nivel de usuario en procesos separados, un servicio que falla no puede afectar a otros ni puede ser utilizado para ganar acceso a otros servicios o al nÃºcleo.
AdemÃ¡s se pueden implementar estrategias para mejorar la tolerancia a fallos, como reiniciar un servicio que ha fallado, como si fuera un programa cualquiera.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rendimiento">8.3.1. Rendimiento</h4>
<div class="paragraph">
<p>El mayor inconveniente es el pobre rendimiento que puede tener, causado por la sobrecarga que aÃ±ade el mecanismo de comunicaciÃ³n.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, <a href="https://es.wikipedia.org/wiki/Windows_NT">Microsoft Windows NT</a> naciÃ³ con una estructura de <strong>microkernel</strong> en capas donde una parte importante de los servicios eran proporcionados por unos procesos de usuario llamados subsistemas.</p>
</div>
<div class="paragraph">
<p>El sistema operativo podÃ­a mostrar diferentes personalidades o <em>entornos operativos</em> âbÃ¡sicamente de OS/2, POSIX y MSDOSâ a travÃ©s del uso de subsistemas ambientales, que tambiÃ©n se ejecutaban como procesos de usuario.
Las aplicaciones de Microsoft Windows NT se comunicaban con estos subsistemas utilizando un mecanismo de comunicaciÃ³n denominado <a href="https://en.wikipedia.org/wiki/Local_Inter-Process_Communication">LPC</a> (<em>Local Inter-Process Communication</em>).</p>
</div>
<div class="paragraph">
<p>Con esta estructura, la pÃ©rdida de rendimiento respecto a Microsoft Windows 95 era tan importante âespecialmente en lo relativo a operaciones grÃ¡ficasâ que los diseÃ±adores se vieron obligados a mover mÃ¡s servicios al espacio del nÃºcleo en la versiÃ³n 4.0.
El resultado es que los Windows sucesores a Windows NT 4.0 tienen una arquitectura mÃ¡s monolÃ­tica que microkernel, ya que aunque muchos servicios siguen siendo proporcionados por procesos de usuario, esto sÃ³lo ocurre con aquellos donde el rendimiento no es un factor crÃ­tico.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Microsoft Windows XP tiene 280 llamadas al sistema a las que hay que sumar las mÃ¡s de 650 llamadas del subsistema grÃ¡fico, que tambiÃ©n se aloja en el nÃºcleo desde Microsoft Windows NT 4.0.
Mientras que Microsoft Windows NT 3.51 tenÃ­a algo menos de 200 llamadas al sistema.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sin embargo varios sistemas operativos siguen utilizando nÃºcleos <strong>microkernel</strong>, como <a href="https://es.wikipedia.org/wiki/QNX">QNX</a> o <a href="https://en.wikipedia.org/wiki/MINIX_3">MINIX 3</a>.
Ambos son sistemas operativos de tiempo real, que basan en la estructura de <strong>microkernel</strong> su estabilidad como sistema para tareas crÃ­ticas.</p>
</div>
<div class="paragraph">
<p>En la <a href="#estructura_minix3">Figura 24</a>, por ejemplo, se puede observar un esquema de <a href="https://en.wikipedia.org/wiki/MINIX_3">MINIX 3</a>.
El nÃºcleo es muy pequeÃ±o âapenas tiene 5000 lÃ­neas de cÃ³digoâ por lo que la mayor parte de la funcionalidad reside en los procesos de servicios y de controladores de dispositivo.</p>
</div>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/MINIX_3">MINIX 3</a> es un sistema compatible POSIX.
AsÃ­ que soporta las llamadas al sistema definidas por este estÃ¡ndar, pero Ã©stas se convierten en mensajes enviados al servidor correspondiente con la peticiÃ³n, y no en llamadas directas al nÃºcleo.
Para que un servidor pueda atender una peticiÃ³n, quizÃ¡s tenga que enviar peticiones a otros servidores o controladores de dispositivo.
Incluso pueden tener que hacer llamadas al nÃºcleo, para solicitar alguna operaciÃ³n privilegiada que no se puede implementar en el modo usuario.
Por ejemplo, operaciones de E/S âfundamentales para los controladores de dispositivoâ o el acceso a tablas del nÃºcleo âcomo la tabla de procesosâ.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Es este trasiego de mensaje con peticiones y respuestas ây la correspondiente conmutaciÃ³n de procesos en la CPU para ejecutar el proceso que atiende cada mensajeâ para resolver una peticiÃ³n de un proceso de usuario, lo que teÃ³ricamente justica el menor rendimiento de los sistemas <strong>microkernel</strong>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructura_modular">8.4. Estructura modular</h3>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los sistemas con <strong>estructura modular</strong> se caracterizan por:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Dividir el nÃºcleo en mÃ³dulos, cada uno de los cuales implementa funciones y servicios concretos y se comunican entre sÃ­ a travÃ©s de una interfaz bien definida.</p>
</li>
<li>
<p>Como en la programaciÃ³n orientada a objetos, cada mÃ³dulo oculta al resto los detalles de su implementaciÃ³n.</p>
</li>
<li>
<p>Todos los mÃ³dulos pueden llamar a funciones de la interfaz de cualquier otro mÃ³dulo, a diferencia de los sistemas operativos con <strong>estructura en capas</strong>, donde una capa solo podÃ­a usar a la inmediatamente inferior.</p>
</li>
<li>
<p>TambiÃ©n son sistemas <strong>monolÃ­ticos</strong>, dado que gran parte de la funcionalidad del sistema se implementa en el nÃºcleo, aunque ahora el nÃºcleo estÃ© compartimentado en mÃ³dulos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Estos nÃºcleos suelen disponer de un pequeÃ±o conjunto de componentes fundamentales que se cargan durante el arranque.
Posteriormente pueden cargar mÃ³dulos adicionales, tanto durante la inicializaciÃ³n del sistema como en tiempo de ejecuciÃ³n.</p>
</div>
<div id="estructura_linux" class="imageblock">
<div class="content">
<img src="C08-estructura/images/estructura_linux.svg" alt="estructura linux">
</div>
<div class="title">Figura 25. Esquema de la estructura del nÃºcleo Linux.</div>
</div>
<div class="paragraph">
<p>En este aspecto se asemejan a los nÃºcleos <strong>microkernel</strong>, ya que el mÃ³dulo principal sÃ³lo tiene funciones bÃ¡sicas.
Sin embargo los nÃºcleos modulares:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Son mÃ¡s eficientes</strong> al no necesitar un mecanismo de comunicaciÃ³n, puesto que los componentes se cargan en la memoria destinada al nÃºcleo, por lo que pueden llamarse directamente.</p>
</li>
<li>
<p><strong>Son menos seguros y fiables</strong>, puesto que gran parte de su funcionalidad se ofrece desde el modo privilegiado.
Un error en cualquier componente puede comprometer o hacer caer el sistema.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este tipo de estructura es la utilizada en los UNIX modernos, como <a href="https://es.wikipedia.org/wiki/Solaris_(sistema_operativo)">Oracle/Sun Microsystems Solaris</a>, <a href="https://es.wikipedia.org/wiki/FreeBSD">FreeBSD</a>, <a href="https://es.wikipedia.org/wiki/GNU/Linux">Linux</a> (vÃ©ase la <a href="#estructura_linux">Figura 25</a>) y <a href="https://es.wikipedia.org/wiki/MacOS">macOS</a>.</p>
</div>
</div>
</div>
</div>
<h1 id="_gestiÃ³n_de_procesos_2" class="sect0">Parte III: GestiÃ³n de procesos</h1>
<div class="sect1">
<h2 id="_procesos">9. Procesos</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>39 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Los primeros sistemas informÃ¡ticos solo permitÃ­an que un programa se ejecutara cada vez.
Dicho programa tenÃ­a control completo sobre el sistema y acceso a todos los recursos del mismo.
Por el contrario, los sistemas <strong>multitarea</strong> actuales permiten que mÃºltiples programas sean cargados y ejecutados concurrentemente.</p>
</div>
<div class="paragraph">
<p>Obviamente esta evoluciÃ³n implica un control mÃ¡s fino y la compartimentaciÃ³n de los diversos programas, para que no interfieran unos con otros.
Esto, a su vez, conduce a la apariciÃ³n de la nociÃ³n de <strong>proceso</strong>, que no es sino la unidad de trabajo en un sistema operativo moderno de tiempo compartido.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Por simplicidad, en este capÃ­tulo utilizaremos los tÃ©rminos <strong>trabajo</strong> y <strong>proceso</strong> de forma indistinta.
A fin de cuentas tanto los <strong>trabajos</strong> en los antiguos <em>mainframes</em> como los <strong>procesos</strong> en los sistemas modernos son la unidad de trabajo en sus respectivos sistemas y el origen de toda actividad en la CPU.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Por Ãºltimo, antes de continuar, es importante seÃ±alar que en un sistema operativo hay varios tipos de procesos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Procesos del sistema</strong>.
Ejecutan el cÃ³digo del sistema operativo contenido en los <strong>programas del sistema</strong>, que generalmente sirven para hacer tareas del sistema operativo que es mejor mantener fuera del nÃºcleo.</p>
</li>
<li>
<p><strong>Procesos de usuario</strong>
Ejecutan el cÃ³digo contenido en los <em>programas de aplicaciÃ³n</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sin embargo, en lo que resta de capÃ­tulo, no estableceremos ninguna distinciÃ³n entre ellos.
En lo que respecta a la gestiÃ³n de estos procesos en el sistema, no hay ninguna diferencia.</p>
</div>
<div class="sect2">
<h3 id="_el_proceso">9.1. El proceso</h3>
<div class="paragraph">
<p>Como ya hemos comentado con anterioridad, un <strong>proceso</strong> es un programa en ejecuciÃ³n (vÃ©ase el <a href="#_gestiÃ³n_de_procesos">Apartado 4.1</a> para una definiciÃ³n mÃ¡s completa).
Sin embargo, los procesos no solo estÃ¡n compuestos por el cÃ³digo del programa, sino que tambiÃ©n son importantes otros elementos:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1">Segmento de cÃ³digo</dt>
<dd>
<p>Contiene las instrucciones ejecutables del programa.
TambiÃ©n es conocido como segmento <strong>text</strong> o <strong>.text</strong>.</p>
</dd>
<dt class="hdlist1">Segmento de datos</dt>
<dd>
<p>Contiene las variables globales y estÃ¡ticas del programa que se inicializan con un valor predefinido.
TambiÃ©n es conocido como segmento <strong>.data</strong>.</p>
</dd>
<dt class="hdlist1">Segmento BSS</dt>
<dd>
<p>Contiene las variables globales y estÃ¡ticas del programa inicializadas a 0 o sin inicializaciÃ³n explÃ­cita   .
TambiÃ©n es conocido como segmento <strong>.bss</strong>.</p>
</dd>
<dt class="hdlist1">Pila</dt>
<dd>
<p>Contiene datos temporales, como los parÃ¡metros y direcciones de retorno de las funciones y las variables locales.</p>
</dd>
<dt class="hdlist1">MontÃ³n</dt>
<dd>
<p>Contiene el espacio de la memoria que se asigna dinÃ¡micamente durante la ejecuciÃ³n del proceso.
TambiÃ©n es conocido como <strong>heap</strong>.</p>
</dd>
<dt class="hdlist1">InformaciÃ³n sobre el estado actual de ejecuciÃ³n</dt>
<dd>
<p>Como el <strong>contador de programa</strong>, los valores de los <strong>registros de la CPU</strong>, el <strong>estado</strong> del proceso y mÃ¡s (vÃ©ase el <a href="#_bloque_de_control_de_proceso">Apartado 9.3</a>).</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>Los <strong>segmentos de cÃ³digo</strong>, <strong>datos</strong> y <strong>BSS</strong> por lo general son secciones dentro del archivo ejecutable que contiene el programa.
El resto de elementos los crea el sistema operativo al cargar el programa y crear el proceso.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Como vimos en el <a href="#_gestiÃ³n_de_procesos">Apartado 4.1</a> varios procesos pueden estar asociados al mismo programa pero no por eso dejan de ser distintos procesos.
Todos tendrÃ¡ una copia del mismo segmento de cÃ³digo, pero diferente: contador de programas, valores en los registros de la CPU, pila, segmento de datos, montÃ³n y demÃ¡s propiedades.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En la <a href="#proceso_en_memoria">Figura 26</a> se puede observar la disposiciÃ³n de algunos de estos elementos de un proceso en la memoria.</p>
</div>
<div id="proceso_en_memoria" class="imageblock">
<div class="content">
<img src="C09-procesos/images/proceso_en_memoria.svg" alt="proceso en memoria">
</div>
<div class="title">Figura 26. AnatomÃ­a de un proceso en memoria.</div>
</div>
</div>
<div class="sect2">
<h3 id="_estados_de_los_procesos">9.2. Estados de los procesos</h3>
<div class="paragraph">
<p>Cada proceso tiene un <strong>estado</strong> que cambia a lo largo de su ejecuciÃ³n y que estÃ¡ definido, parcialmente, por la actividad que realiza actualmente el propio proceso.</p>
</div>
<div id="diagrama_estado_proceso" class="imageblock">
<div class="content">
<img src="C09-procesos/images/diagrama_estado_proceso.svg" alt="diagrama estado proceso">
</div>
<div class="title">Figura 27. Diagrama de estado de un proceso.</div>
</div>
<div class="paragraph">
<p>Los estados por los que puede pasar un procesos varÃ­an de un sistema operativo a otro, aunque los siguientes son comunes a todos ellos:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Nuevo</dt>
<dd>
<p>El proceso estÃ¡ en proceso de creaciÃ³n.
Este estado existe porque la creaciÃ³n de un proceso no es algo instantÃ¡neo.
Necesita de varias operaciones que pueden tarda tiempo en realizarse, como: reservar memoria libre, cargar el programa en la memoria, inicializar estructuras de datos y configurar el entorno de ejecuciÃ³n.</p>
</dd>
<dt class="hdlist1">Ejecutando</dt>
<dd>
<p>El proceso estÃ¡ siendo ejecutado en la CPU.
Para eso tiene que haber sido escogido por el planificador de la CPU de entre todos los procesos en estado <strong>preparado</strong>.
SÃ³lo puede haber un proceso en este estado por CPU en el sistema.</p>
</dd>
<dt class="hdlist1">Esperando</dt>
<dd>
<p>El proceso estÃ¡ esperando por algÃºn <strong>evento</strong> como, por ejemplo, que termine una operaciÃ³n de E/S solicitada previamente o que otro proceso termine su ejecuciÃ³n.
MÃºltiples procesos pueden estar en este estado de espera.</p>
</dd>
<dt class="hdlist1">Preparado</dt>
<dd>
<p>El proceso estÃ¡ esperando a poder usar la CPU.
MÃºltiples procesos pueden estar en este estado.</p>
</dd>
<dt class="hdlist1">Terminado</dt>
<dd>
<p>El proceso ha finalizado su ejecuciÃ³n y espera a que el sistema operativo recupere los recursos que le fueron asignados.
Como en el caso del estado <strong>nuevo</strong>, este estado existe porque terminar un proceso no es algo instantÃ¡neo.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>El diagrama de estados de los procesos, con las transiciones posibles entre ellos, se muestra en la <a href="#diagrama_estado_proceso">Figura 27</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bloque_de_control_de_proceso">9.3. Bloque de control de proceso</h3>
<div class="paragraph">
<p>El <strong>bloque de control de proceso</strong> o <strong>PCB</strong> (<em>Process Control Block</em>) es una estructura de datos que representa a cada proceso en el sistema operativo y que guarda informaciÃ³n sobre su estado de actividad actual.</p>
</div>
<div class="paragraph">
<p>En el sistema hay un PCB por proceso y sirve de almacÃ©n para cualquier informaciÃ³n que puede variar de un proceso a otro:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Estado del proceso</strong>.
El estado actual del proceso de la lista que hemos visto anteriormente.
Por ejemplo: nuevo, preparado, esperando, etc.</p>
</li>
<li>
<p><strong>Contador de programa</strong>.
Indica la direcciÃ³n de la prÃ³xima instrucciÃ³n del proceso que debe ser ejecutada por la CPU.
Obviamente, durante el estado <strong>ejecutando</strong> el contador de programa estÃ¡ en el registro correspondiente de la CPU.
Su valor se guarda en el PCB al salir el proceso de la CPU para que comience ejecutarse en ella otro proceso.</p>
</li>
<li>
<p><strong>Registros de la CPU</strong>.
El valor de los registros de la CPU tambiÃ©n forma parte del estado de actividad del proceso.
Como en el caso del <strong>contador de programa</strong>, durante el estado <strong>ejecutando</strong> los valores estÃ¡n en los registros de la CPU, pero se guardan en el PCB cuando el proceso sale de la CPU para que se ejecute otro proceso.</p>
</li>
<li>
<p><strong>InformaciÃ³n de planificaciÃ³n de la CPU</strong>.
Incluye la informaciÃ³n requerida por el planificador de la CPU.
Por ejemplo la prioridad del proceso, punteros a las colas de planificaciÃ³n donde estÃ¡ el proceso, punteros al PCB del proceso padre y de los procesos hijos, etc.</p>
</li>
<li>
<p><strong>InformaciÃ³n de gestiÃ³n de la memoria</strong>.
Incluye la informaciÃ³n requerida para la gestiÃ³n de la memoria.
Por ejemplo los valores de los registros base y lÃ­mite que definen el Ã¡rea de la memoria fÃ­sica que ocupa el proceso âen el caso de se use asignaciÃ³n de memoria contigua (vÃ©ase el <a href="#_asignaciÃ³n_de_memoria_contigua">Apartado 15.3</a> o la direcciÃ³n a la tabla de pÃ¡ginas âen el caso de que se use paginaciÃ³n (vÃ©ase el <a href="#_paginaciÃ³n">CapÃ­tulo 16</a>)â.</p>
</li>
<li>
<p><strong>InformaciÃ³n de registro</strong>.
AquÃ­ se incluye la cantidad de CPU usada, lÃ­mites de tiempo en el uso de la CPU, estadÃ­sticas de la cuenta del usuario al que pertenece el proceso, estadÃ­sticas de la ejecuciÃ³n del proceso, etc.</p>
</li>
<li>
<p><strong>InformaciÃ³n de estado de la E/S</strong>.
Incluye la lista de dispositivos de E/S reservados por el proceso, la lista de archivos abiertos, etc.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_colas_de_planificaciÃ³n">9.4. Colas de planificaciÃ³n</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>En los sistemas operativos hay diferentes <strong>colas de planificaciÃ³n</strong> para los procesos en distintos <strong>estados</strong>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Cola de trabajo</dt>
<dd>
<p>Contiene a todos los trabajos en el sistema, de manera que cuando entran en el sistema van a esta cola, a la espera de ser escogidos para ser cargados en la memoria y ejecutados.
Esta cola existÃ­a en los <strong>sistemas multiprogramados</strong> pero no existe en los sistemas operativos modernos.</p>
</dd>
<dt class="hdlist1">Cola de preparados</dt>
<dd>
<p>Contiene a los procesos que estÃ¡n en estado <strong>preparado</strong>.
Es decir, procesos cargados en la memoria principal que esperan para usar la CPU.
La cola de preparados es generalmente una lista enlazada de PCB, donde cada uno incluye un puntero al PCB del siguiente proceso en la cola.</p>
</dd>
<dt class="hdlist1">Colas de espera</dt>
<dd>
<p>Contienen a los procesos que estÃ¡n en estado <strong>*esperando</strong>.
Es decir, que esperan por un evento concreto, como por ejemplo la finalizaciÃ³n de una peticiÃ³n de E/S.
Estas colas tambiÃ©n suelen ser implementadas como listas enlazadas de PCB y suele haber una por evento, de manera que cuando ocurre algÃºn evento todos los procesos en la cola asociada pasan automÃ¡ticamente al estado <strong>preparado</strong> y a la <strong>cola de preparados</strong>.</p>
</dd>
<dt class="hdlist1">Colas de dispositivo</dt>
<dd>
<p>Son un caso particular de cola de espera.
Cada dispositivo de E/S tiene asociada una <strong>cola de dispositivo</strong> que contiene los procesos que estÃ¡n <strong>esperando</strong> por ese dispositivo en particular.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Una manera habitual de representar la planificaciÃ³n de procesos es a travÃ©s de un diagrama de colas como el de la <a href="#colas_de_planificaciÃ³n_procesos">Figura 28</a>.</p>
</div>
<div id="colas_de_planificaciÃ³n_procesos" class="imageblock">
<div class="content">
<img src="C09-procesos/images/colas_planificaciÃ³n_procesos.svg" alt="colas planificaciÃ³n procesos">
</div>
<div class="title">Figura 28. Diagrama de colas de la planificaciÃ³n de procesos.</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>AnalizÃ¡ndolo podemos tener una idea clara del flujo tÃ­pico de los procesos dentro del sistema:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Un nuevo proceso llega al sistema</strong>.
Una vez pasa del estado <strong>nuevo</strong> a <strong>preparado</strong> es colocado en la <strong>cola de preparados</strong>.
AllÃ­ espera hasta que es seleccionado por el <strong>planificado de la CPU</strong> para su ejecuciÃ³n y se le asigna la CPU.
Mientras se ejecuta pueden ocurrir varias cosas:</p>
<div class="ulist">
<ul>
<li>
<p><strong>El proceso solicita una operaciÃ³n de E/S</strong> por lo que abandona la CPU y es colocado en la <em>cola de dispositivo</em> correspondiente en estado <strong>esperando</strong>.
No debemos olvidar que aunque en nuestro diagrama no exista mÃ¡s que una de estas colas, en un sistema operativo real suele haber una para cada dispositivo.</p>
</li>
<li>
<p><strong>El proceso puede querer esperar por un evento</strong>.
Por ejemplo, puede crear otro proceso y esperar a que termine.
En ese caso el proceso hijo es creado, mientras el proceso padre abandona la CPU y es colocado en una <strong>cola de espera</strong> en estado <strong>esperando</strong> hasta que el proceso hijo termine.
La terminaciÃ³n del proceso hijo es el evento que espera el proceso padre para salir de la <strong>cola de espera</strong> y entrar en la <strong>cola de preparados</strong> para continuar su ejecuciÃ³n en la CPU cuando sea posible.</p>
</li>
<li>
<p><strong>El proceso puede ser sacado forzosamente de la CPU</strong>, como resultado de la interrupciÃ³n del temporizador, que permite determinar cuando un proceso lleva demasiado tiempo ejecutÃ¡ndose, asÃ­ que es colocado en la <strong>cola de preparados</strong> en estado <strong>preparado</strong>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Cuando las esperas concluyen, los procesos vuelven a la cola de preparado</strong>, pasando del estado de espera al de preparado.</p>
</li>
<li>
<p><strong>Los procesos repiten este ciclo hasta que terminan</strong>.
En ese momento son eliminados de todas las colas mientras el PCB y los recursos asignados son recuperados por parte del sistema operativo para poder usarlos con otros procesos.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n_de_procesos">9.5. PlanificaciÃ³n de procesos</h3>
<div class="paragraph">
<p>Durante su ejecuciÃ³n, los procesos se mueven entre las diversas colas de planificaciÃ³n a criterio del sistema operativo.
Este proceso de selecciÃ³n debe ser realizado por el <strong>planificador</strong> adecuado:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El <strong>planificador de largo plazo</strong> Do <strong>planificador de trabajos</strong>â selecciona los trabajos desde la cola de trabajos en el almacenamiento secundario âdÃ³nde estÃ¡n todos almacenadosâ y los carga en memoria.</p>
<div class="paragraph">
<p>Este planificador se usaba en los sistemas multiprogramados, donde habÃ­a cola de trabajo.
Los sistemas de tiempo compartido posteriores y los sistemas modernos, carecen de planificador de trabajos, porque los programas se cargan directamente en memoria para ser ejecutados, cuando el usuario lo solicita.</p>
</div>
</li>
<li>
<p>El <strong>planificador de corto plazo</strong> o <strong>planificador de CPU</strong> selecciona uno de los procesos en la cola de preparados y lo asigna a la CPU.
Obviamente este planificador es invocado cuando un proceso en ejecuciÃ³n abandona la CPU, dejÃ¡ndola disponible para otro proceso.</p>
</li>
<li>
<p>El <strong>planificador de medio plazo</strong>  era utilizado en algunos sistemas para sacar procesos de la memoria cuando escasea y reintroducirlos posteriormente cuando vuelve a haber suficiente memoria libre.
A este esquema se le denomina <strong>intercambio</strong> âo <strong><em>swapping</em></strong>.</p>
<div class="paragraph">
<p>Esto era Ãºtil en sistemas antiguos donde un proceso tenÃ­a que estar cargado completamente en la memoria para poder ejecutarse.
AsÃ­ que si faltaba memoria, se podÃ­a suspender un proceso completo, preservar el contenido de su memoria en disco y liberar la memoria ocupada para usarla con otros procesos.</p>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En los sistemas de propÃ³sito general modernos no se utiliza <strong>planificador de medio plazo</strong> porque utilizan tÃ©cnicas de <strong>memoria virtual</strong> (vÃ©ase el <a href="#_memoria_virtual">Apartado 17.1</a>), que permite mover parte de la memoria de los procesos al disco para liberar memoria, sin tener que suspender su ejecuciÃ³n.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_cambio_de_contexto">9.6. Cambio de contexto</h3>
<div class="paragraph">
<p>El <strong>cambio de contexto</strong> es la tarea de asignar la CPU un proceso distinto al que la tiene asignada en el momento actual.
Esto implica salvar el estado del viejo proceso en su PCB y cargar en la CPU el estado del nuevo.
Entre la informaciÃ³n que debe ser preservada en el PCB se incluyen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El <strong>contador de programa</strong>.</p>
</li>
<li>
<p>Los <strong>registros de la CPU</strong>.</p>
</li>
<li>
<p>El <strong>estado del proceso</strong>.</p>
</li>
<li>
<p>La <strong>informaciÃ³n de gestiÃ³n de la memoria</strong>.
Por ejemplo, la informaciÃ³n necesaria para configurar el espacio de direcciones del proceso.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El cambio de contexto es sobrecarga pura, puesto que no hace ningÃºn trabajo Ãºtil mientras se conmuta.
Su velocidad depende de aspectos tales como: el nÃºmero de registros, la velocidad de la memoria y la existencia de instrucciones especiales</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Algunas CPU disponen de instrucciones especiales para salvar y cargar todos los registros de manera eficiente.
Esto reduce el tiempo que la CPU estÃ¡ ocupada en los cambios de contexto.</p>
</div>
<div class="paragraph">
<p>Otra opciÃ³n es el uso de <a href="https://en.wikipedia.org/wiki/Register_file">juegos de registros</a>, como es el caso de los procesadores <a href="https://es.wikipedia.org/wiki/UltraSPARC">Sun UltraSPARC</a> e <a href="https://es.wikipedia.org/wiki/Intel_Itanium">Intel Itanium</a>.
Con ellos el juegos de registros actual de la CPU se mapea sobre un banco de registros mucho mÃ¡s extenso.
Al hacer cambio de contexto, se mapea el juego de registros a otros registros diferentes del banco.
Esto permite que la CPU almacene de forma eficiente el valor de los registros de mÃ¡s de un proceso, sin que en cada cambio de contexto sea necesario copiarlos al PCB del proceso en la memoria principal.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_operaciones_sobre_los_procesos">9.7. Operaciones sobre los procesos</h3>
<div class="paragraph">
<p>En general es necesario que los procesos pueden ser creados y eliminados dinÃ¡micamente, por lo que los sistemas operativos deben proporcionar servicios para la creaciÃ³n y terminaciÃ³n de los mismos.</p>
</div>
<div class="sect3">
<h4 id="_creaciÃ³n_de_procesos">9.7.1. CreaciÃ³n de procesos</h4>
<div class="paragraph">
<p>Un proceso âdenominado <strong>padre</strong>â puede crear mÃºltiples procesos âlos <strong>hijos</strong>â utilizando una llamada al sistema especÃ­fica para la creaciÃ³n de procesos.
Cada proceso creado se identifica de manera unÃ­voca mediante un <strong>identificador de proceso</strong> o <strong>PID</strong> (<em>Process Identifier</em>), que normalmente es un nÃºmero entero.</p>
</div>
<div class="paragraph">
<p>Por ejemplo en sistemas POSIX un programa puede crear otro proceso asÃ­:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>mientras que en Windows API es asÃ­:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">PROCESS_INFORMATION</span> <span class="n">pi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">CreateProcess</span><span class="p">(</span> <span class="s">"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">charmap.exe"</span><span class="p">,</span> <span class="cm">/* ... */</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span> <span class="p">))</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">pi</span><span class="p">.</span><span class="n">dwhProcessId</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">HANDLE</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">;</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> devuelve <code>TRUE</code> si el proceso se creÃ³ con Ã©xito.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> contiene el <strong>identificador de proceso</strong> del nuevo proceso, si <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> ha tenido Ã©xito.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> tambiÃ©n contiene el manejador del proceso âo <em>handle</em> en inglÃ©sâ que sirve para obtener y manipular el nuevo proceso.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En ambos casos <code>pid</code> identifica al nuevo proceso en el sistema.
Sin embargo, mientras que los sistemas POSIX ese identificador se puede usar en otras llamadas al sistema para indicar futuras operaciones sobre el proceso, en Windows lo que se utiliza es el manejador <code>hProcess</code> devuelto en <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a>.</p>
</div>
<div class="paragraph">
<p>Obviamente, cada proceso puede obtener del sistema su propio identificador de procesos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cm">/* POSIX API */</span>
<span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>

<span class="cm">/* Windows API */</span>
<span class="n">HANDE</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
<span class="n">DWORD</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">GetProcessId</span><span class="p">(</span> <span class="n">handle</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>o el de su padre:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cm">/* POSIX API */</span>
<span class="n">pid_t</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">getppid</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_Ã¡rbol_de_procesos">Ãrbol de procesos</h5>
<div class="paragraph">
<p>Puesto que cada nuevo proceso puede a su vez crear otros procesos, al final se acaba obteniendo un <strong>Ã¡rbol de procesos</strong>.
En los sistemas POSIX es muy sencillo de ver ejecutando el comando <a href="https://man7.org/linux/man-pages/man1/pstree.1.html">pstree</a>.</p>
</div>
<div class="paragraph">
<p>En estos sistemas el proceso <strong>init</strong> es el proceso padre raÃ­z de todos los procesos de usuario.
Su PID siempre es 1 ya que es el primer proceso creado por el sistema operativo al terminar la inicializaciÃ³n del nÃºcleo.
Por lo tanto, es el responsable de crear todos los otros procesos que son necesarios para el funcionamiento del sistema.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cÃ³mo_obtienen_los_procesos_hilos_los_recursos_que_necesitan">CÃ³mo obtienen los procesos hilos los recursos que necesitan</h5>
<div class="paragraph">
<p>Hay varios aspectos en la creaciÃ³n de los procesos que pueden variar de un sistema operativo a otro.
Uno de ellos es cÃ³mo obtienen los procesos hilos los recursos que necesitan para hacer su trabajo.</p>
</div>
<div class="paragraph">
<p>Fundamentalmente existen dos alternativas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Que cada proceso hijo puede solicitar y obtener los recursos directamente del sistema operativo, compitiendo por los recursos del sistema en las mismas condiciones que el resto de procesos en ejecuciÃ³n.
Esta es la opciÃ³n mÃ¡s comÃºn en los sistemas de propÃ³sito general actuales, como Microsoft Windows, Android, Linux, macOS, BSD y muchos otros.</p>
</li>
<li>
<p>Que los proceso hijo solo puedan aspirar a obtener un subconjunto de los recursos de su padre.
Esto es interesante en sistemas diseÃ±ados para ser muy robustos, ya que evita que un proceso pueda sobrecargar el sistema creando mÃºltiples procesos que consuman demasiada memoria o tiempo de CPU.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>En este Ãºltimo caso, el proceso padre puede estar obligado a repartir sus recursos entre los procesos hijo. O pueda que el sistema les permita compartir algunos de esos recursos âcomo memoria o archivosâ con algunos de sus hijos.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cÃ³mo_pasar_parÃ¡metros_de_inicializaciÃ³n_a_los_procesos_hijo">CÃ³mo pasar parÃ¡metros de inicializaciÃ³n a los procesos hijo</h5>
<div class="paragraph">
<p>Generalmente, el proceso padre suele disponer de algÃºn mecanismo para pasar parÃ¡metros de inicializaciÃ³n a sus procesos hijo.</p>
</div>
<div class="sect5">
<h6 id="_argumentos_de_lÃ­nea_de_comandos">Argumentos de lÃ­nea de comandos</h6>
<div class="paragraph">
<p>Por ejemplo, en Windows API un proceso puede usar el segundo argumento de <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> para indicar al proceso hijo opciones y argumentos de lÃ­nea de comandos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">HANDLE</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">CreateProcess</span><span class="p">(</span><span class="s">"C:</span><span class="se">\\</span><span class="s">holamundo.exe"</span><span class="p">,</span> <span class="s">"/v /s foo.txt bar.png"</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Si el proceso hijo estÃ¡ programado en C o C&#43;&#43;, podrÃ¡ acceder a los argumentos <code>/v</code>, <code>/s</code>, <code>foo.txt</code> y <code>bar.png</code> a travÃ©s de los argumentos <code>argc</code> y <code>argv</code> de la funciÃ³n <a href="https://en.cppreference.com/w/c/language/main_function">main()</a> del programa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cm">/* . . . */</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>de forma que <code>argv[0]</code> contendrÃ¡ <code>/v</code>, <code>argv[2]</code> contendrÃ¡ <code>/s</code> y asÃ­ sucesivamente.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Obviamente, en otros lenguajes de programaciÃ³n se accede de manera diferente a estos argumentos de lÃ­nea de comandos.</p>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_variables_de_entorno">Variables de entorno</h6>
<div class="paragraph">
<p>Otra forma de pasar parÃ¡metros a un proceso hijo es usando las <strong>variables de entorno</strong>, que no son sino variables dinÃ¡micas que se pueden crear, leer y modificar durante la ejecuciÃ³n del proceso.</p>
</div>
<div class="paragraph">
<p>Las <strong>variables de entorno</strong> se gestionan con funciones especÃ­ficas ofrecidas por la API del sistema operativo:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 1. Funciones de la API para gestionar variables de entorno.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POSIX API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Windows API</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Leer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/getenv.3.html">getenv()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getenvironmentvariable">GetEnvironmentVariable()</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Leer todos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man7/environ.7.html">environ</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getenvironmentstrings">GetEnvironmentStrings()</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Crear / modificar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/setenv.3.html">setenv()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setenvironmentvariable">SetEnvironmentVariable()</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>por ejemplo, en sistemas POSIX un programa leer la variable de entorno <code>PATH</code> asÃ­:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">char</span><span class="o">*</span> <span class="n">path</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">"PATH"</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>mientras que en Windows API es asÃ­:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">DWORD</span> <span class="n">buffSize</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
<span class="n">TCHAR</span> <span class="n">path</span><span class="p">[</span><span class="n">buffSize</span><span class="p">];</span>
<span class="n">GetEnvironmentVariable</span><span class="p">(</span><span class="s">"PATH"</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">buffSize</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>El valor de la variable de entorno <code>PATH</code> se copia en <code>path</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Usando <a href="https://man7.org/linux/man-pages/man3/setenv.3.html">setenv()</a> o <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setenvironmentvariable">SetEnvironmentVariable()</a> de forma similar, cualquier proceso puede crear variables de entorno que serÃ¡n accesibles a sus procesos hijos, porque por defecto los nuevos procesos heredan un duplicado de las variables de entorno de su proceso padre.
AsÃ­ se pueden pasar parÃ¡metros de configuraciÃ³n para alterar el comportamiento de los procesos hijo.</p>
</div>
<div class="paragraph">
<p>Todas las variantes de sistemas UNIX, asÃ­ como MS-DOS y todas las versiones de Microsoft Windows soportan variables de entorno.</p>
</div>
</div>
<div class="sect5">
<h6 id="_herencia_de_recursos">Herencia de recursos</h6>
<div class="paragraph">
<p>En algunos sistemas operativos los procesos hijos pueden heredar cierto tipo de recursos del proceso padre, lo que tambiÃ©n puede servir para inicializar y alterar el comportamiento del proceso hijo.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en los sistemas POSIX todos los archivos abiertos por un proceso son heredados en el mismo estado por sus hijos.
Lo interesante es que en estos sistemas muchos recursos se gestionan como archivos.
Algunos ejemplo podrÃ­an ser: dispositivos de E/S, memoria compartida, tuberÃ­as, <em>sockets</em> y otros mecanismos de comunicaciÃ³n.</p>
</div>
<div class="paragraph">
<p>En POSIX todo proceso tiene, por defecto, tres archivos abiertos que corresponden a tres dispositivos de E/S especiales:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Entrada estÃ¡ndar</strong>, de dÃ³nde los procesos leen la entrada del teclado de la terminal.</p>
</li>
<li>
<p><strong>Salida estÃ¡ndar</strong>, donde el proceso escribe para mostrar texto en la pantalla de la terminar.</p>
</li>
<li>
<p><strong>Salida de error</strong>, usada para mostrar errores en la pantalla de la terminal.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Debido a la herencia de los archivos abiertos del proceso padre, todo proceso hijo tiene acceso a estos tres mismos dispositivos.
Y a su vez tambiÃ©n la tendrÃ¡n sus hijos y los hijos de estos.
De esta manera, todo proceso tiene acceso a los dispositivos de E/S de la terminal donde se ejecuta.
Pero tambiÃ©n permite a un proceso controlar el destino de la E/S de un proceso hijo ây de los hijos de esteâ.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si antes de crear el proceso hijo sustituye el dispositivo de salida estÃ¡ndar por un archivo real, todo lo que el hijo intente mostrar por pantalla se guardarÃ¡ en dicho archivo, en lugar de mostrarse.
Mientras que si lo hace con el dispositivo de entrada estÃ¡ndar, todo lo que pretenda leer de teclado realmente lo leerÃ¡ de un archivo que el padre puede haber preparado, como si de algÃºn tipo de control remoto se tratara.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Esta misma idea se puede extender a procesos que ofrecen servicios, ya sea a otros procesos del mismo sistema o a redes de ordenadores, como Internet.</p>
</div>
<div class="paragraph">
<p>Cada conexiÃ³n con un cliente es como archivo abierto, por lo que los hijos del proceso heredan las conexiones.
AsÃ­ que es comÃºn la estrategia de crear un hijo por conexiÃ³n para que la atienda en nombre del padre, mientras este se encarga de recibir nuevas conexiones.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>En Microsoft Windows existe un mecanismo similar pero no por defecto.
La funciÃ³n <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> de Windows API permite indicar si se quiere que el nuevo proceso herede los recursos abiertos.
Y tambiÃ©n tiene ajustes especÃ­ficos para la entrada y salida estÃ¡ndar y la salida de error del nuevo proceso.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_quÃ©_ocurre_con_la_ejecuciÃ³n_del_padre">QuÃ© ocurre con la ejecuciÃ³n del padre</h5>
<div class="paragraph">
<p>Se suelen contemplar dos posibilidades en tÃ©rminos de la ejecuciÃ³n del padre:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Que el padre continÃºe ejecutÃ¡ndose al mismo tiempo que el hijo.
Es lo mÃ¡s comÃºn en los sistemas multitarea actuales.</p>
</li>
<li>
<p>Que le padre quede detenido a la espera que de algunos o todos sus hijos terminen.
Era lo mÃ¡s frecuente en sistemas monotarea, como <a href="https://es.wikipedia.org/wiki/MS-DOS">MS-DOS</a>.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_cÃ³mo_se_construye_el_espacio_de_direcciÃ³n_de_los_procesos_hijo">CÃ³mo se construye el espacio de direcciÃ³n de los procesos hijo</h5>
<div class="paragraph">
<p>En general hay dos posibilidades:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Que el espacio de direcciones del proceso hijo sea un duplicado del que tiene el padre.
Es decir, que inicialmente el hijo tenga el mismo cÃ³digo y datos que el padre.
Es lo que hace <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> en los sistemas POSIX.</p>
</li>
<li>
<p>Que el espacio de direcciones del proceso hijo se cree desde cero y se cargue en Ã©l un nuevo programa.
Es lo que hace <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> en Windows.
Por eso siempre hay que indicarle el nombre del programa que se quiere ejecutar en el nuevo proceso.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Esto lo veremos con mÃ¡s detalle en el <a href="#_ejemplos_de_operaciones_con_procesos">Apartado 9.7.3</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_terminaciÃ³n_de_procesos">9.7.2. TerminaciÃ³n de procesos</h4>
<div class="paragraph">
<p>Un proceso termina cuando se lo indica al sistema operativo con la llamada al sistema <strong>exit</strong>.
En ese momento puede devolver un valor de estado a su padre.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Esto ocurre en C y C&#43;&#43; incluso si el programa termina usando la sentencia <code>return</code> en <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.
Lo que ocurre es que es el cÃ³digo, introducido por el compilador, que llamÃ³ a <a href="https://en.cppreference.com/w/c/language/main_function">main()</a> es el que llama a <strong>exit</strong> usando el valor devuelto por <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El proceso padre puede esperar a que el hijo termine y recuperar ese valor a travÃ©s de la llamada al sistema <strong>wait</strong>.
Cuando un proceso termina, todos los recursos son liberados, incluyendo: la memoria fÃ­sica y virtual, archivos y dispositivos abiertos, bÃºferes de E/S, etc.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 2. Funciones de la API para salir, esperar y terminar procesos.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POSIX API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Windows API</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Salir</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.man7.org/linux/man-pages/man3/exit.3.html">exit()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess">ExitProcess()</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Esperar (un hijo concreto)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/waitpid.2.html">waitpid()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Esperar (mÃºltiples hijos)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/wait.2.html">wait()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObject()</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Terminar otro proceso</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/kill.2.html">kill()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess">TerminateProcess()</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>En todo caso un proceso puede provocar la terminaciÃ³n de otro proceso a travÃ©s de una llamada al sistema.
Por ejemplo, en sistemas POSIX se usa un mecanismo llamado <strong>seÃ±ales</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>mientras que en Windows API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">TerminateProcess</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Habitualmente el proceso que invoca estas funciones es el proceso padre, ya que puede que sea el Ãºnico con permisos para hacerlo.</p>
</div>
<div class="paragraph">
<p>Los motivos para terminar un procesos hijo pueden ser:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>El hijo ha excedido el uso de algunos de los recursos reservados</strong>.
Obviamente esto tiene sentido cuando los hijos utilizan un subconjunto de los recursos asignados al padre.</p>
</li>
<li>
<p><strong>La tarea asignada al hijo ya no es necesaria</strong>.
Por ejemplo, se creÃ³ para comprimir un archivo pero el usuario ha pedido cancelar la operaciÃ³n.</p>
</li>
<li>
<p><strong>El padre termina y el sistema operativo estÃ¡ diseÃ±ado para no permitir que el hijo pueda seguir ejecutÃ¡ndose si no tiene un padre</strong>.
En esos sistemas, la terminaciÃ³n de un proceso provoca que el sistema operativo inicie lo que se denomina una <strong>terminaciÃ³n en cascada</strong>, en la que termina todos los procesos que cuelgan de dicho proceso.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En sistemas UNIX y estilo UNIX, si un proceso muere a sus hijos no terminan sino que se les reasigna como padre el proceso <strong>init</strong>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplos_de_operaciones_con_procesos">9.7.3. Ejemplos de operaciones con procesos</h4>
<div class="paragraph">
<p>En C estÃ¡ndar la funciÃ³n <a href="https://en.cppreference.com/w/c/program/system">system()</a> de la librerÃ­a estÃ¡ndar permite ejecutar otro proceso, con sus argumentos, esperar a que termine y obtener el valor de estado con el que finalizÃ³ el proceso.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">system</span><span class="p">(</span><span class="s">"holamundo -v foo.txt"</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta funciÃ³n es portable.
EstÃ¡ disponible en cualquier sistema donde haya un compilador de C estÃ¡ndar, pero sus funcionalidades son bastante limitadas.
Por ejemplo, no permite que el programa padre continÃºe su ejecuciÃ³n mientras se ejecuta el hijo, aunque el sistema sea multitarea y ese sea el comportamiento por defecto.
Tampoco facilita el control de los recursos que son heredados por el proceso hijo o hacer redirecciones de los dispositivos de E/S estÃ¡ndar.</p>
</div>
<div class="paragraph">
<p>Como hemos comentado anteriormente, para acceder a todas las funcionalidades ofrecidas por los sistemas operativos, muchas veces es necesario utilizar directamente la librerÃ­a del sistema.</p>
</div>
<div class="sect4">
<h5 id="_windows_api_2">Windows API</h5>
<div class="paragraph">
<p>En Windows la librerÃ­a del sistema ofrece la funciÃ³n <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a>.
A diferencia de <a href="https://en.cppreference.com/w/c/program/system">system()</a>, recibe muchÃ­simos argumentos, ya que permite configurar bastantes aspectos de la creaciÃ³n de un nuevo proceso.</p>
</div>
<div class="paragraph">
<p>En el <a href="#ejemplo_createprocess">Ejemplo 2</a> se puede ver como se usa <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> para ejecutar un programa y esperar a que termine, de forma similar a como lo hace <a href="https://en.cppreference.com/w/c/program/system">system()</a>.</p>
</div>
<div id="ejemplo_createprocess" class="exampleblock">
<div class="title">Ejemplo 2. Crear un proceso usando Windows API</div>
<div class="content">
<div class="paragraph">
<p>El cÃ³digo fuente completo de este ejemplo estÃ¡ disponible en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap09/createprocess.c">createprocess.c</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">STARTUPINFO</span> <span class="n">si</span> <span class="o">=</span> <span class="p">{</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">STARTUPINFO</span><span class="p">)</span> <span class="p">};</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">PROCESS_INFORMATION</span> <span class="n">pi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <i class="conum" data-value="2"></i><b>(2)</b>

<span class="c1">// Crear procesos hijo y comprobar si no se creÃ³ con Ã©xito.</span>
<span class="k">if</span><span class="p">(</span> <span class="o">!</span> <span class="n">CreateProcess</span><span class="p">(</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="nb">NULL</span><span class="p">,</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="s">"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">charmap.exe"</span><span class="p">,</span>  <i class="conum" data-value="4"></i><b>(4)</b> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">FALSE</span><span class="p">,</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="mi">0</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>  <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="nb">NULL</span><span class="p">,</span>  <i class="conum" data-value="8"></i><b>(8)</b>
    <span class="o">&amp;</span><span class="n">si</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">pi</span> <span class="p">))</span>
<span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"Error (%d) al crear el proceso.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="p">);</span> <i class="conum" data-value="9"></i><b>(9)</b>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El PID del nuevo proceso hijo es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pi</span><span class="p">.</span><span class="n">dwProcessId</span> <span class="p">);</span>

<span class="c1">// Esperar hasta que el hijo termine.</span>
<span class="n">WaitForSingleObject</span><span class="p">(</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">INFINITE</span> <span class="p">);</span> <i class="conum" data-value="10"></i><b>(10)</b>

<span class="n">DWORD</span> <span class="n">dwExitCode</span><span class="p">;</span>
<span class="n">GetExitCodeProcess</span><span class="p">(</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwExitCode</span> <span class="p">);</span> <i class="conum" data-value="11"></i><b>(11)</b>
<span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El valor de salida del proceso hijo es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dwExitCode</span> <span class="p">);</span>

<span class="c1">// Cerrar los manejadores del proceso y del hilo principal del proceso.</span>
<span class="n">CloseHandle</span><span class="p">(</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span> <span class="p">);</span> <i class="conum" data-value="12"></i><b>(12)</b>
<span class="n">CloseHandle</span><span class="p">(</span> <span class="n">pi</span><span class="p">.</span><span class="n">hThread</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a> sirve para pasar a <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> parÃ¡metros adicionales sobre el inicio de la aplicaciÃ³n, como configurar la redirecciÃ³n de la E/S estÃ¡ndar o caracterÃ­sticas de la primera ventana creada por la aplicaciÃ³n âen aplicaciones con interfaz grÃ¡ficaâ.
Si no se va a usar, debe inicializarse a 0, excepto el primer campo que debe contener el tamaÃ±o de la estructura.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> sirve para devuelve el manejador y el <strong>identificador de proceso</strong> del nuevo proceso.
Es comÃºn inicializar la estructura a 0.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> devuelve <code>TRUE</code> o <code>FALSE</code>, en funciÃ³n de si ha tenido Ã©xito o no, respectivamente.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>El primer argumento â<code>lpApplicationName</code>â se usa para pasar la ruta del ejecutable, mientras que los argumentos de lÃ­nea de comando generalmente se pasan por el segundo â<code>lpCommandLine</code>â.
Si en <code>lpApplicationName</code> se indica NULL, se puede pasar todo junto por <code>lpCommandLine</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>En <code>lpCommandLine</code> indicamos la ruta al ejecutable y los argumentos de la lÃ­nea de comandos, si hicieran falta.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Con <code>bInheritHandles</code> a <code>FALSE</code> seÃ±alamos que no queremos que el proceso hijo herede ningÃºn manejador abierto del proceso padre.
Estos manejadores son recursos a los que el padre tiene acceso y, si fuera necesario, el hijo tambiÃ©n podrÃ­a tenerlo.
Los manejadores pueden representar, por ejemplo, archivos abiertos, tuberÃ­as, <em>sockets</em> u otros mecanismos de comunicaciÃ³n, procesos o archivos mapeados en memoria, entre muchos otros tipos de recursos.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Con <code>NULL</code> en <code>lpEnvironment</code> indicamos que el hijo herede el conjunto de variables de entorno directamente del padre.
La otra opciÃ³n es indicar un nuevo conjunto de variables de entorno.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><code>lpCurrentDirectory</code> sirve para indicar el directorio del trabajo del proceso hijo.
Es decir, el directorio respecto al que se resolverÃ¡n las rutas de archivo relativas.
Con <code>NULL</code> indicamos que utilice las misma ruta que el proceso padre.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Si <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> falla, devuelve <code>FALSE</code>.
Llamando a <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError()</a> obtiene el cÃ³digo que identifica el motivo del error de la Ãºltima funciÃ³n utilizada de Windows API.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Usando <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject()</a> hacemos que el proceso padre se quede en estado <strong>esperando</strong> âsin que pueda seguir ejecutÃ¡ndoseâ hasta que el proceso hijo termine.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Cuando el proceso a terminado, el padre puede conocer su valor de salida.
Es decir, el valor usado para terminar en la sentencia <code>return</code> de <a href="https://en.cppreference.com/w/c/language/main_function">main()</a> o al llamar a  <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess">ExitProcess()</a> en el programa del proceso hijo.
Como convenciÃ³n, el hijo indica con un 0 que terminÃ³ con Ã©xito, mientras que con un valor distinto indica que tuvo algÃºn tipo de problema.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>Cuando ya no hace falta obtener informaciÃ³n del procesos hijo o manipularlo, es necesario cerrar los manejadores devueltos por <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a>.
AsÃ­ el sistema operativo sabe que las estructuras de datos relacionadas con el proceso hijo ya no son necesarias, por lo que pueden liberarse.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess()</a> siempre necesita la ruta a un ejecutable âsea en el primer o en el segundo argumento de la funciÃ³nâ porque se utiliza para crear un proceso completamente limpio y ejecutar en Ã©l un nuevo programa.</p>
</div>
</div>
<div class="sect4">
<h5 id="procesos_posix_api">POSIX API</h5>
<div class="paragraph">
<p>Por el contrario, en los sistemas POSIX se utiliza una estrategia muy diferente.
Los nuevos procesos se crean con la llamada <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>, que se encargar de crearlo como una copia del proceso padre.</p>
</div>
<div class="exampleblock">
<div class="title">Ejemplo 3. Crear un proceso en sistemas POSIX</div>
<div class="content">
<div class="paragraph">
<p>El cÃ³digo fuente completo de este ejemplo estÃ¡ disponible en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap09/fork.c">fork.c</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span> <i class="conum" data-value="7"></i><b>(7)</b>

<span class="c1">// Crear un proceso hijo</span>
<span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span> <i class="conum" data-value="1"></i><b>(1)</b>

<span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">{</span>
    <span class="c1">// AquÃ­ solo entra el proceso hijo</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[HIJO] Â¡Soy el proceso hijo!"</span> <span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[HIJO] El valor de mi variable 'child' es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">child</span> <span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[HIJO] Este es mi PID: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">()</span> <span class="p">);</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[HIJO] El valor de mi variable 'pid' es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pid</span> <span class="p">);</span> <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[HIJO] El PID de mi padre es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getppid</span><span class="p">()</span> <span class="p">);</span> <i class="conum" data-value="7"></i><b>(7)</b>

    <span class="n">puts</span><span class="p">(</span> <span class="s">"[HIJO] Durmiendo 10 segundos..."</span> <span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[HIJO] Salgo con %d Â¡Adios!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">status</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">status</span><span class="p">;</span> <i class="conum" data-value="9"></i><b>(9)</b>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  <i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">{</span>
    <span class="c1">// AquÃ­ solo entra el proceso padre</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] Â¡Soy el proceso padre!"</span> <span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El valor de mi variable 'child' es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">child</span> <span class="p">);</span>  <i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] Este es mi PID: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">()</span> <span class="p">);</span> <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El valor de mi variable 'pid' es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pid</span> <span class="p">);</span> <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El PID de mi padre es: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getppid</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] Voy a esperar a que mi hijo termine..."</span> <span class="p">);</span>

    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">status</span> <span class="p">);</span>  <i class="conum" data-value="8"></i><b>(8)</b> <i class="conum" data-value="9"></i><b>(9)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El valor de salida de mi hijo fue: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">);</span> <i class="conum" data-value="9"></i><b>(9)</b>

    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] Â¡Adios!"</span> <span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="c1">// AquÃ­ solo entra el padre si no pudo crear el hijo</span>
    <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"Error (%d) al crear el procesos: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">);</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>El proceso llama a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> pero al retornar de la llamada vuelven dos procesos: el proceso padre, que es el que llamÃ³ originalmente a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>, y el proceso hijo.
Como el proceso hijo es una copia del padre, tiene el mismo cÃ³digo, las mismas variables y los mismos recursos que tenÃ­a el padre en el momento de llamar a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.
La Ãºnica diferencia es el valor devuelto por <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>, que guardamos en <code>child</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Los dos procesos ejecutan el mismo programa, asÃ­ que ambos llegan a la lÃ­nea detrÃ¡s del <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.
Como queremos que cada proceso haga cosas diferentes, necesitamos que cada uno vaya a ramas distintas del cÃ³digo.
Eso se hace comprobando el valor de <code>child</code>, porque si vale 0 es que el proceso que actualmente ejecuta el programa es el hijo.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Si, por el contrario, el valor de <code>child</code> es mayor de 0, el proceso que ejecuta el programa es el padre y el valor de <code>child</code> es el PID del proceso hijo creado.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>AsÃ­ que el valor de <code>child</code> en el padre coincide con el devuelto por <a href="https://man7.org/linux/man-pages/man2/getpid.2.html">getpid()</a> en el hijo.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Finalmente, si el valor devuelto por <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> es negativo, es que ocurriÃ³ un error y el proceso hijo no llegÃ³ a crearse.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>En los sistemas POSIX es comÃºn que las llamadas al sistema devuelvan un valor negativo para indicar un error.
El motivo del error se puede conocer a travÃ©s de la variable global <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>, que siempre guarda el cÃ³digo de identificaciÃ³n del error en la Ãºltima funciÃ³n invocada de la API POSIX.
La funciÃ³n <a href="https://man7.org/linux/man-pages/man3/strerror.3.html">strerror()</a> permite obtener un texto descriptivo de cualquier valor de <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>, lo que siempre resulta Ãºtil para crear mensajes de error que ayuden a determinar dÃ³nde estuvo el problema.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>A modo de ejemplo hemos guardado el PID del proceso en la variable <code>pid</code>, antes de la llamada a <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.
Como el proceso hijo es una copia del proceso padre, la variable existe en ambos pero en el proceso hijo su valor coincide con lo devuelto por <a href="https://man7.org/linux/man-pages/man2/getppid.2.html">getppid()</a> mientras que en el proceso padre con lo devuelto por <a href="https://man7.org/linux/man-pages/man2/getpid.2.html">getpid()</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><a href="https://man7.org/linux/man-pages/man2/wait.2.html">wait()</a> hace que el proceso padre interrumpa su ejecuciÃ³n hasta que algÃºn hijo termine y devuelve el estado de salida en <code>status</code>.
<div class="paragraph">
<p>Debemos asegurarnos de llamar a <a href="https://man7.org/linux/man-pages/man2/wait.2.html">wait()</a> o <a href="https://man7.org/linux/man-pages/man2/waitpid.2.html">waitpid()</a> una vez por cada proceso hijo, en algÃºn momento, porque asÃ­ es como el sistema sabe que el padre ya no tiene mÃ¡s interÃ©s en el proceso y puede liberar su PCB, dÃ³nde se guarda el estado de salida.
No hacerlo genera <strong>procesos zombi</strong>(proceso, zombi o <em>defunct</em>.</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>El valor de salida de proceso hijo lo obtiene el proceso a travÃ©s del estado de salida devuelto por <a href="https://man7.org/linux/man-pages/man2/wait.2.html">wait()</a>.
Pero ese estado contienen mÃ¡s informaciÃ³n sobre la causa por la que el proceso terminÃ³.
Para recuperar el valor de salida se usa la macro <code>WEXITSTATUS</code> sobre el estado de salida.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Lo siguiente es un posible resultado de ejecutar el programa anterior en una terminal de Linux,
numerado con las anotaciones realizadas al cÃ³digo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./fork
[PADRE] Â¡Soy el proceso padre!
[PADRE] El valor de mi variable 'child' es: 2360 <i class="conum" data-value="4"></i><b>(4)</b>
[PADRE] Este es mi PID: 2359 <i class="conum" data-value="7"></i><b>(7)</b>
[PADRE] El valor de mi variable 'pid' es: 2359 <i class="conum" data-value="7"></i><b>(7)</b>
[HIJO] Â¡Soy el proceso hijo!
[PADRE] El PID de mi padre es: 1857
[PADRE] Voy a esperar a que mi hijo termine...
[HIJO] El valor de mi variable 'child' es: 0 <i class="conum" data-value="2"></i><b>(2)</b>
[HIJO] Este es mi PID: 2360
[HIJO] El valor de mi variable 'pid' es: 2359 <i class="conum" data-value="7"></i><b>(7)</b>
[HIJO] El PID de mi padre es: 2359 <i class="conum" data-value="7"></i><b>(7)</b>
[HIJO] Durmiendo 10 segundos...
[HIJO] Salgo con 42 Â¡Adios! <i class="conum" data-value="9"></i><b>(9)</b>
[PADRE] El valor de salida de mi hijo fue: 42 <i class="conum" data-value="9"></i><b>(9)</b>
[PADRE] Â¡Adios!</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Aunque pueda parecer algo complejo, esta estrategia facilita la comunicaciÃ³n entre procesos.
Es muy sencillo lanzar otro proceso para hacer una tarea en paralelo que tendrÃ¡ automÃ¡ticamente una copia de los datos del proceso original.</p>
</div>
<div class="paragraph">
<p>Como se trata de una copia, las nuevas variables o la modificaciÃ³n de variables existentes que realice cualquiera de los procesos, no serÃ¡n visibles para el otro.
Es decir, despuÃ©s del <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> ambos procesos son complemente independientes.
Pero como el proceso hijo hereda el acceso a todo tipo de recursos abiertos por el proceso padre, como: archivos, tuberÃ­as, <em>sockets</em> o regiones de memoria compartida, entre muchos otros recursos; es muy sencillo crear un canal de comunicaciÃ³n entre ambos procesos, si fuera necesario.</p>
</div>
<div class="paragraph">
<p>Sin embargo, <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> no proporciona una funcionalidad similar a la de <a href="https://en.cppreference.com/w/c/program/system">system()</a>.
No sirve para crear otro proceso con un programa diferente.
Para eso necesitamos <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a>, una familia de funciones cuyo propÃ³sito es cagar un nuevo programa en el proceso que la invoca.</p>
</div>
<div class="exampleblock">
<div class="title">Ejemplo 4. Ejecutar otro programa en un proceso nuevo en sistemas POSIX</div>
<div class="content">
<div class="paragraph">
<p>El cÃ³digo fuente completo de este ejemplo estÃ¡ disponible en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap09/fork-exec.c">fork-exec.c</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="c1">// Crear un proceso hijo</span>
<span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span> <i class="conum" data-value="1"></i><b>(1)</b>

<span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// AquÃ­ solo entra el proceso hijo</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[HIJO] Â¡Soy el proceso hijo!"</span> <span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[HIJO] Voy a ejecutar el comando 'ls'"</span> <span class="p">);</span>

    <span class="cm">/* Hacer otras cosas necesarias antes de ejecutar el programa... */</span> <i class="conum" data-value="4"></i><b>(4)</b>

    <span class="n">execl</span><span class="p">(</span> <span class="s">"/bin/ls"</span><span class="p">,</span> <span class="s">"ls"</span><span class="p">,</span> <span class="s">"-l"</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>   <i class="conum" data-value="2"></i><b>(2)</b> <i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="5"></i><b>(5)</b>

    <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"Error (%d) al ejecuta el programa: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">);</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <i class="conum" data-value="7"></i><b>(7)</b>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// AquÃ­ solo entra el proceso padre</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] Â¡Soy el proceso padre!"</span> <span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] Voy a esperar a que mi hijo termine..."</span> <span class="p">);</span>

    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">status</span> <span class="p">);</span> <i class="conum" data-value="8"></i><b>(8)</b>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"[PADRE] El valor de salida de mi hijo fue: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">);</span>

    <span class="n">puts</span><span class="p">(</span> <span class="s">"[PADRE] Â¡Adios!"</span> <span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="c1">// AquÃ­ solo entra el padre si no pudo crear el hijo</span>
    <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"Error (%d) al crear el procesos: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">);</span>
    <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Primero creamos un proceso hijo, donde ejecutaremos el nuevo programa.
Si nos diera por llamar directamente a una funciÃ³n de la familia <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a>, nuestro programa serÃ­a sustituido y no tendrÃ­amos ningÃºn control sobre lo que pase despuÃ©s.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>En la rama de cÃ³digo que se va a ejecutar en el hijo âgracias a la comprobaciÃ³n del valor devuelto por <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>â ejecutamos al funciÃ³n de la familia <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> que mÃ¡s nos interese.
Esta funciÃ³n no crea otro proceso, sino que carga el programa indicado en el proceso hijo, sustituyendo asÃ­ a nuestro programa.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Todas las funciones de la familia <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> reciben como primer argumento la ruta al ejecutable, pero en <code>execlp()</code> en particular, a continuaciÃ³n se indican los argumentos de lÃ­nea de comandos, tal y como queremos que los reciba el programa en el argumento <code>argv</code> de su <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.
Es decir, que el programa del comando <code>/bin/ls</code> recibirÃ¡ <code>ls</code> y <code>-l</code> en <code>argv[0]</code> y <code>argv[1]</code>, respectivamente.
El <code>NULL</code> del final indica cuando no hay mÃ¡s argumentos de lÃ­nea de comandos para pasar.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Antes de ejecutar la funciÃ³n <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> se pueden hacer cosas para configurar adecuadamente el proceso donde se ejecutarÃ¡ el nuevo programa.
Por ejemplo, cambiar las variables de entorno, redirigir la E/S estÃ¡ndar, cambiar el usuario al que pertenece el proceso âsi originalmente se ejecuta con un usuario con ese privilegioâ o cerrar archivos abiertos del procesos padre que ha heredado el proceso hijo y que, obviamente, no queremos que se queden abiertos para programas diferentes al nuestro.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Las funciones <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> no retornan si tienen Ã©xito, porque el programa actual es sustituido por el indicado, que comenzarÃ¡ a ejecutarse de su <a href="https://en.cppreference.com/w/c/language/main_function">main()</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Si la funciÃ³n <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> retorna es porque fallÃ³ y, como es comÃºn, el motivo del error estÃ¡ disponible en <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>.
Un motivo de fallo muy tÃ­pico es que el ejecutable indicado no exista.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Si la funciÃ³n <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> la ejecuciÃ³n del proceso hijo continuarÃ¡, hasta salir de <a href="https://en.cppreference.com/w/c/language/main_function">main()</a> pero, generalmente, el proceso ya no es Ãºtil si no puede ejecutar el programa que le hemos indicado.
Por eso es importante asegurarnos de que el proceso hijo termina, si <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> falla.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Mientras todo lo anterior ocurre en el proceso hijo, el proceso padre espera.
Cuando el proceso hijo termine, el padre podrÃ¡ obtener su estado de salir para saber si tuvo Ã©xito o no.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Lo siguiente es un posible resultado de ejecutar el programa anterior en una terminal de Linux,
numerado con las anotaciones realizadas al cÃ³digo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./fork-exec
[PADRE] Â¡Soy el proceso padre!
[PADRE] Voy a esperar a que mi hijo termine...
[HIJO] Â¡Soy el proceso hijo!
[HIJO] Voy a ejecutar el comando 'ls'
total 628 <i class="conum" data-value="2"></i><b>(2)</b>
-rwxr--r-- 1 jesus jesus 72640 Sep 16 13:41 fifo-client
-rwxr--r-- 1 jesus jesus 72784 Sep 16 13:41 fifo-server
-rwxr--r-- 1 jesus jesus 20056 Sep 16 13:41 fork
-rwxr-xr-x 1 jesus jesus 19896 Sep 18 13:24 fork-exec
-rwxr--r-- 1 jesus jesus 80744 Sep 16 13:41 mmap
-rwxr--r-- 1 jesus jesus 45712 Sep 16 13:41 pipe
-rwxr--r-- 1 jesus jesus 87024 Sep 16 13:41 shared-memory
-rwxr--r-- 1 jesus jesus 77696 Sep 16 13:41 shared-memory-sync
-rwxr--r-- 1 jesus jesus 19608 Sep 16 13:41 softstack-c
-rwxr--r-- 1 jesus jesus 39328 Sep 16 13:41 softstack-cpp
-rwxr--r-- 1 jesus jesus  9920 Sep 16 13:41 syscall
-rwxr--r-- 1 jesus jesus 40712 Sep 16 13:41 threads-mutex-pthread
-rwxr--r-- 1 jesus jesus 39944 Sep 16 13:41 threads-pthread
[PADRE] El valor de salida de mi hijo fue: 0 <i class="conum" data-value="8"></i><b>(8)</b>
[PADRE] Â¡Adios!</pre>
</div>
</div>
<div class="paragraph">
<p>Veamos quÃ© ocurre si lÃ­nea de la funciÃ³n <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> fuera:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">execl</span><span class="p">(</span> <span class="s">"/bin/ls"</span><span class="p">,</span> <span class="s">"ls"</span><span class="p">,</span> <span class="s">"-l"</span><span class="p">,</span> <span class="s">"/foo"</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>para intentar ver el contenido del directorio <code>/foo</code>, que no existe:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./fork-exec
[PADRE] Â¡Soy el proceso padre!
[PADRE] Voy a esperar a que mi hijo termine...
[HIJO] Â¡Soy el proceso hijo!
[HIJO] Voy a ejecutar el comando 'ls'
ls: cannot access '/foo': No such file or directory <i class="conum" data-value="1"></i><b>(1)</b>
[PADRE] El valor de salida de mi hijo fue: 2 <i class="conum" data-value="2"></i><b>(2)</b>
[PADRE] Â¡Adios!</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>El comando <code>ls</code> se ejecuta pero falla porque el directorio indicado no existe.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Por eso el programa, al terminar el proceso, no devuelve 0 sino 2 y es ese el valor que recibe el proceso padre.
Esto le permite saber al proceso padre que el comando <code>ls</code> no tuvo Ã©xito.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Y finalmente cambiemos la lÃ­nea de la funciÃ³n <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> asÃ­:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">execl</span><span class="p">(</span> <span class="s">"/noexists"</span><span class="p">,</span> <span class="s">"ls"</span><span class="p">,</span> <span class="s">"-l"</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>para que intente ejecutar un programa que no existe:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./fork-exec
[PADRE] Â¡Soy el proceso padre!
[PADRE] Voy a esperar a que mi hijo termine...
[HIJO] Â¡Soy el proceso hijo!
[HIJO] Voy a ejecutar el comando 'ls'
Error (2) al ejecuta el programa: No such file or directory <i class="conum" data-value="1"></i><b>(1)</b>
[PADRE] El valor de salida de mi hijo fue: 255 <i class="conum" data-value="2"></i><b>(2)</b>
[PADRE] Â¡Adios!</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> falla y se muestra el mensaje de error con el motivo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>El proceso hijo termina con -1 y asÃ­ llega ese valor al proceso padre.
Al utilizar un valor de salida diferente a los que usa el programa que intenta ejecutar, el padre distingue las terminaciones causadas por errores al llamar a <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> de los errores del propio programa.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Todas las funciones <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> hacen lo mismo.
Primero liberan la memoria reservada en el proceso, despuÃ©s cargan el nuevo programa y finalmente inicia la ejecuciÃ³n del programa desde su punto de entrada.
La diferencia entre las distintas funciones estÃ¡ en los argumentos que aceptan.
Esa diferencia se puede conocer fijÃ¡ndonos en las letras al final del nombre de cada funciÃ³n:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Sin 'p'</strong>, como <code>execl()</code> o <code>execv()</code>, el primer argumento de la funciÃ³n es la ruta hasta el ejecutable del programa que se quiere ejecutar.</p>
</li>
<li>
<p><strong>Con 'p'</strong>, como <code>execlp()</code> o <code>execvp()</code>, la funciÃ³n busca el ejecutable como lo hace la <em>shell</em>.
Es decir, si el primer argumento no contiene ninguna '/' se toma como el nombre del ejecutable y se busca en los directorios listados en la variable de entorno <code>PATH</code>.
Si el primero argumento contienen alguna '/', se considera una ruta y se busca directamente el ejecutable en ella.</p>
</li>
<li>
<p><strong>Con 'l'</strong>, como <code>execl()</code> o <code>execlp()</code>, los argumentos de lÃ­nea de comandos para pasar al programa se indican directamente como argumentos diferentes de la funciÃ³n âpor ejemplo <code>execl("/bin/ls", "ls", "-l", "-a" NULL)</code>â lo que es ideal cuando el nÃºmero de argumentos es fijo.
La lista de argumentos debe terminar en <code>NULL</code>.</p>
</li>
<li>
<p><strong>Con 'v'</strong>, como <code>execv()</code> o <code>execvp()</code>, los argumentos de la lÃ­nea de comandos para pasar al programa se indican en un <em>array</em> de punteros a cadenas terminadas en '\0', lo que resulta muy prÃ¡ctico si el nÃºmero de argumentos es desconocido en el momento de compilar.
El Ãºltimo elemento del <em>array</em> debe apuntar a <code>NULL</code>.
Por ejemplo:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"ls"</span><span class="p">,</span> <span class="s">"-l"</span><span class="p">,</span> <span class="s">"-a"</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
<span class="n">execv</span><span class="p">(</span><span class="s">"/bin/ls"</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p><strong>Con 'e'</strong>, como <code>execvpe()</code> o <code>execle()</code>, la funciÃ³n admite un argumento adicional para indicar el conjunto de variables de entorno con el que se ejecutarÃ¡ el nuevo programa.
Con las otras funciones <a href="https://man7.org/linux/man-pages/man3/exec.3.html">exec()</a> se conservan las variables de entorno actuales en el proceso que llama a la funciÃ³n.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_procesos_cooperativos">9.8. Procesos cooperativos</h3>
<div class="paragraph">
<p>Desde el punto de vista de la cooperaciÃ³n podemos clasificar los procesos en dos grupos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los <strong>procesos independientes</strong>, que no afectan o pueden ser afectados por otros procesos del sistema. Cualquier proceso que no comparte datos âtemporales o persistentesâ con otros procesos es independiente.</p>
</li>
<li>
<p>Los <strong>procesos cooperativos</strong>, que pueden afectar o ser afectados por otros procesos ejecutados en el sistema.
Los procesos que comparten datos, sea cual sea la forma en la que lo hacen, siempre son cooperativos.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_motivaciones_para_la_colaboraciÃ³n_entre_procesos">9.8.1. Motivaciones para la colaboraciÃ³n entre procesos</h4>
<div class="paragraph">
<p>Hay diversos motivos para proporcionar un entorno que permita la cooperaciÃ³n de los procesos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>ComparticiÃ³n de informaciÃ³n</strong>.
Dado que varios usuarios pueden estar interesados en los mismos bloques de informaciÃ³n âpor ejemplo, en un archivo compartidoâ el sistema operativo debe proporcionar un entorno que permita el acceso concurrente a este tipo de recursos.</p>
</li>
<li>
<p><strong>Velocidad de cÃ³mputo</strong>.
Para que una tarea se ejecute mÃ¡s rÃ¡pido se puede partir en subtareas que se ejecuten en paralelo.
Es importante destacar que la mejora en la velocidad sÃ³lo es posible si el sistema tiene varios componentes de procesamiento como procesadores âsi se quiere acelerar la ejecuciÃ³n en la CPUâ o canales E/S âsi se quieren acelerar las operaciones de E/S â.</p>
</li>
<li>
<p><strong>Modularidad</strong>.
Podemos querer crear nuestro software de forma modular, dividiendo las funciones del programa en procesos separados que se comunican entre sÃ­.</p>
</li>
<li>
<p><strong>Conveniencia</strong>.
Incluso un usuario individual puede querer hacer varias tareas al mismo tiempo.
Por ejemplo, editar, imprimir y compilar al mismo tiempo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Las ejecuciÃ³n simultÃ¡nea de procesos cooperativos requiere mecanismos tanto para comunicar unos con otros como para sincronizar sus acciones (vÃ©ase el <a href="#_sincronizaciÃ³n">CapÃ­tulo 13</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_comunicaciÃ³n_entre_procesos">9.8.2. ComunicaciÃ³n entre procesos</h4>
<div class="paragraph">
<p>Para comunicar procesos cooperativos existen diversas aproximaciones, que en general se pueden encajar en alguna de las siguientes estrategias:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Memoria compartida</dt>
<dd>
<p>MÃ©todo de comunicaciÃ³n en el que los procesos utilizan regiones compartidas de la memoria principal para compartir informaciÃ³n.</p>
</dd>
<dt class="hdlist1">Paso de mensajes</dt>
<dd>
<p>MÃ©todo en el que los procesos utilizan funciones del sistema operativo para enviarse mensajes entre ellos, compartiendo informaciÃ³n y sincronizando acciones, sin necesidad de compartir memoria.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>En la <a href="#modelos_de_comunicaciÃ³n">Figura 29</a> se puede un esquema comparativo entre ambos modelos de comunicaciÃ³n.
Veremos cada uno en detalle en el <a href="#_memoria_compartida">CapÃ­tulo 11</a> y el <a href="#_comunicaciÃ³n_mediante_de_paso_de_mensajes">CapÃ­tulo 10</a>, respectivamente.</p>
</div>
<div id="modelos_de_comunicaciÃ³n" class="imageblock">
<div class="content">
<img src="C09-procesos/images/modelos_comunicaciÃ³n.svg" alt="modelos comunicaciÃ³n">
</div>
<div class="title">Figura 29. Modelos de comunicaciÃ³n.</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comunicaciÃ³n_mediante_de_paso_de_mensajes">10. ComunicaciÃ³n mediante de paso de mensajes</h2>
<div class="sectionbody">
<div class="exampleblock right">
<div class="content">
<div class="paragraph">
<div class="title">Tiempo estimado de lectura</div>
<p>32 minutos</p>
</div>
</div>
</div>
<div class="paragraph">
<p>El <strong>paso de mensajes</strong> es un mecanismo que permite a los procesos compartir informaciÃ³n y sincronizar sus acciones sin necesidad de compartir recursos âcompartir memoria, archivos, etc.â</p>
</div>
<div class="paragraph">
<p>Esto lo hace especialmente Ãºtil en entornos distribuidos, dÃ³nde los procesos a comunicar residen en ordenadores diferentes conectados a una red, por lo que tiene muy difÃ­cil âo incluso imposibleâ compartir memoria u otros recursos para comunicarse.
En este caso, el sistema operativo es el encargado de codificar los mensajes y enviarlos a travÃ©s de la red para hacerlos llegar a su destinatario.
La web âdonde un navegador se conecta a un servidor web para obtener contenidoâ y el resto de servicios de Internet son ejemplos de sistemas de paso de mensajes.</p>
</div>
<div class="paragraph">
<p>El sistema de paso de mensajes debe ser proporcionado por el sistema operativo que, a diferencia de cuando se usa memoria compartida, se encarga de la sincronizaciÃ³n âya que no existen riesgos en el envÃ­o y recepciÃ³n de mensajes al mismo tiempoâ y de establecer el formato que deben tener los datos del mensaje.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En alguna fuentes se sigue haciendo referencia al tÃ©rmino <strong>IPC</strong> (<em>Interprocess Communication</em>) âo <strong>comunicaciÃ³n entre procesos</strong>â para identificarlo exclusivamente con <strong>sistemas de paso de mensajes</strong>.
Sin embargo, la <strong>memoria compartida</strong> y otras tÃ©cnicas tambiÃ©n sirven para Â«comunicar procesosÂ», por lo que es mÃ¡s adecuado usar el tÃ©rmino <strong>IPC</strong> para englobar todas las tÃ©cnicas conocidas de comunicaciÃ³n entre procesos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los sistemas de paso de mensaje de cualquier sistema operativo debe proporcionar al menos dos llamadas al sistema similares a:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>send( message )</strong> para mandar mensajes a otro proceso.</p>
</li>
<li>
<p><strong>receive( &amp;message )</strong> para recibir mensajes de otro proceso y copiarlo en <em>message</em>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Vamos a hablar de funciones de un sistema de paso de mensajes hipotÃ©tico.
Meros ejemplos para ilustrar la diferentes alternativas.
Esto no significa que en los sistemas operativos reales las funciones se llamen asÃ­ y tengan esos mismos argumentos.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Para que estas llamadas puede enviar y recibir mensajes entre dos procesos es necesario que haya un <strong>enlace de comunicaciones</strong> entre ambos.
No trataremos aquÃ­ la implementaciÃ³n fÃ­sica del enlace âque por ejemplo puede ser mediante memoria compartida, un bus hardware o una red de ordenadoresâ sino de su implementaciÃ³n lÃ³gica, es decir, las caracterÃ­sticas de la interfaz que usan las aplicaciones para comunicarse con sus correspondientes operaciones de envÃ­o y recepciÃ³n.</p>
</div>
<div class="sect2">
<h3 id="_tamaÃ±o_del_mensaje">10.1. TamaÃ±o del mensaje</h3>
<div class="paragraph">
<p>Los diseÃ±adores del sistema operativo deben escoger entre implementar un sistema de paso de mensajes con mensajes de tamaÃ±o fijo o mensajes de tamaÃ±o variable:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Mensajes de tamaÃ±o fijo</strong>.
La implementaciÃ³n del sistema operativo es muy sencilla pero el uso de la interfaz por parte de las aplicaciones es mucho mÃ¡s compleja.</p>
<div class="paragraph">
<p>Por ejemplo, para comunicar procesos en un mismo ordenador cada enlace puede tener un bÃºfer de tamaÃ±o fijo donde se copia el mensaje enviado y de donde se extrae el mensaje al recibirlo.
Esto es muy sencillo de implementar en el sistema operativo.
Sin embargo, si el desarrollador de la aplicaciÃ³n quiere enviar algo de mayor tamaÃ±o que el tamaÃ±o del mensaje, debe trocearlo en varios mensajes para enviarlo y reconstruirlo al recibirlo.</p>
</div>
</li>
<li>
<p><strong>Mensajes de tamaÃ±o variable</strong>.
La implementaciÃ³n del sistema operativo es mÃ¡s compleja, ya que ahora tiene que gestionar la memoria para almacenar mensajes de tamaÃ±o variable hasta que son recibidos.
Sin embargo, la programaciÃ³n de aplicaciones es mÃ¡s simple puesto que el programador puede mandar mensajes de cualquier tamaÃ±o sin ninguna preocupaciÃ³n</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_comunicaciÃ³n_orientada_a_flujos">10.1.1. ComunicaciÃ³n orientada a flujos</h4>
<div class="paragraph">
<p>En algunos sistemas con <strong>mensajes de tamaÃ±o variable</strong> no se preserva la separaciÃ³n entre mensajes al recibirlos.
Es decir, que los procesos leen un nÃºmero arbitrario de bytes, donde puede haber parte de un mensaje o varios mensajes al mismo tiempo.
Por ejemplo, en esos sistemas el transmisor puede mandar tres mensajes de 16000, 3200 y 100 bytes, pero el receptor leer la secuencia de bytes en bloques de 512 bytes.</p>
</div>
<div class="paragraph">
<p>A esto se lo denomina <strong>comunicaciÃ³n orientada a flujos</strong> o <strong><em>(streams)</em></strong>
Si usamos este tipo de sistema pero es importante conservar la separaciÃ³n entre los mensajes recibido, serÃ¡ nuestra responsabilidad escoger un formato de mensaje adecuado que permita al receptor recuperar dÃ³nde comienza y termina un mensaje dentro de la secuencia de bytes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_referenciaciÃ³n">10.2. ReferenciaciÃ³n</h3>
<div class="paragraph">
<p>Los procesos que se quiera comunicar debe tener una forma de seÃ±alarse el uno al otro.
Para ello el diseÃ±ador del sistema puede elegir que el sistema de paso de mensajes se con comunicaciÃ³n directa o la indirecta.</p>
</div>
<div class="sect3">
<h4 id="_comunicaciÃ³n_directa">10.2.1. ComunicaciÃ³n directa</h4>
<div class="paragraph">
<p>En la <strong>comunicaciÃ³n directa</strong> cada proceso debe nombrar explÃ­citamente al proceso destinatario o receptor de la informaciÃ³n.
Por ejemplo, ahora las llamadas al sistema bÃ¡sicas podrÃ­an ser asÃ­:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>send( A, message )</strong> para mandar un mensaje al proceso identificado como Â«AÂ».</p>
</li>
<li>
<p><strong>receive( A, &amp;message )</strong> para recibir un mensaje del proceso identificado como Â«AÂ», copiÃ¡ndolo en Â«<em>message</em>Â».</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>De hecho el ejemplo anterior corresponde a un caso de <strong>comunicaciÃ³n directa</strong> con <strong>direccionamiento simÃ©trico</strong> pero existe una variante de ese mismo esquema denominado <strong>direccionamiento asimÃ©trico</strong> donde el receptor puede recibir mensajes de cualquier proceso, de forma que al volver de la llamada recibe el mensaje y la identidad del remitente.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>send( A, message )</strong> para mandar un mensaje al proceso identificado como Â«AÂ»</p>
</li>
<li>
<p><strong>receive( &amp;pid, &amp;message )</strong> para recibir un mensaje de cualquier proceso, recibiendo en Â«<em>message</em>Â» la una copia del <em>message</em> y en Â«pidÂ» la identidad del remitente.</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>En resumen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En el <strong>direccionamiento simÃ©trico</strong> tanto el proceso que envÃ­a como el que reciben tienen que identificar al otro para comunicarse.</p>
</li>
<li>
<p>En el <strong>direccionamiento asimÃ©trico</strong> sÃ³lo el proceso que envÃ­a identifica a que recibe, mientras que este Ãºltimo no tiene que nombrar al remitente.
Es el sistema operativo el que informa de quiÃ©n es el remitente del mensaje que se ha recibido.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Un <strong>enlace de comunicaciones</strong> segÃºn este esquema tiene las siguientes caracterÃ­sticas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un enlace se establece automÃ¡ticamente entre cada par de procesos que quieren comunicarse.
Por tanto, los procesos sÃ³lo necesitan conocer a la identidad de los otros para comunicarse.</p>
</li>
<li>
<p>Cada enlace se asocia exactamente a dos procesos.</p>
</li>
<li>
<p>Entre cada par de procesos sÃ³lo hay un enlace.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La principal desventaja de este tipo de comunicaciÃ³n es que si cambia el identificador de un proceso hay que actualizar todas las referencias en todos los procesos que se comunican con el.
En general cualquier tÃ©cnica que requiera que los identificadores de los procesos sean establecidos explÃ­citamente en el cÃ³digo de los programas no es deseable, puesto que en muchos sistemas los identificadores de los procesos cambian de una ejecuciÃ³n a otra.
Por lo tanto, lo mejor serÃ­a disponer de una soluciÃ³n con un nivel adicional de indirecciÃ³n que evite que los procesos usen sus identificadores para comunicarse.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Colas de mensajes en Windows API</div>
<div class="paragraph">
<p>En Windows API un hilo puede enviar mensajes a otro hilo usando <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postthreadmessagea">PostThreadMessage()</a>.
Como aun no hemos visto el concepto de hilo, podemos asumir que es equivalente al de proceso.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">BOOL</span> <span class="nf">PostThreadMessage</span><span class="p">(</span>
    <span class="n">DWORD</span>  <span class="n">idThread</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">UINT</span>   <span class="n">Msg</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">WPARAM</span> <span class="n">wParam</span><span class="p">,</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="n">LPARAM</span> <span class="n">lParam</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Identificador del hilo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Un nÃºmero entero que identifica el mensaje</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>ParÃ¡metros del mensaje de tipo entero.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como se puede observar, en las colas de mensajes de Windows API el <strong>tamaÃ±o del mensaje es fijo</strong> y con un estructura muy bien definida: un identificador del mensaje y dos enteros que sirven de parÃ¡metros opcionales del mensaje.</p>
</div>
<div class="paragraph">
<p>Para recibir el mensaje el proceso llama a <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagea">GetMessage()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">BOOL</span> <span class="nf">GetMessage</span><span class="p">(</span>
    <span class="n">LPMSG</span> <span class="n">lpMsg</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">HWND</span>  <span class="n">hWnd</span><span class="p">,</span>
    <span class="n">UINT</span>  <span class="n">wMsgFilterMin</span><span class="p">,</span>
    <span class="n">UINT</span>  <span class="n">wMsgFilterMax</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Puntero a una estructura <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-msg">MSG</a> que a la vuelta contendrÃ¡ el identificador y los parÃ¡metros del mensaje recibido, entre otra informaciÃ³n.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como se puede observar, no se indica de quÃ© hilo o proceso se quiere recibir el mensaje, por lo que se trata de un caso de <strong>comunicaciÃ³n directa asimÃ©trica</strong>.
De hecho, si se quiere conocer la identidad del remitente, este tendrÃ­a que poner su identificador en alguno de los parÃ¡metros del mensaje.</p>
</div>
<div class="paragraph">
<p>El sistema de colas de mensajes de Windows API es una pieza fundamental del entorno grÃ¡fico de Microsoft Windows.
Sin embargo, podemos definir nuestros propios mensaje privados para comunicar unos hilos o procesos con otros.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_comunicaciÃ³n_indirecta">10.2.2. ComunicaciÃ³n indirecta</h4>
<div class="paragraph">
<p>En la <strong>comunicaciÃ³n indirecta</strong> los mensajes son enviados a <strong>buzones</strong>, <strong><em>maillox</em></strong> o <strong>puertos</strong> que son objetos dÃ³nde los procesos pueden dejar y recoger mensajes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>send( P, message )</strong> para mandar un mensaje al puerto Â«PÂ»</p>
</li>
<li>
<p><strong>receive( P, &amp;message )</strong> para recibir un mensaje del puerto Â«PÂ».</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Un <strong>enlace de comunicaciones</strong> segÃºn este esquema tiene las siguientes caracterÃ­sticas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un enlace se establece entre un par de procesos solo si ambos comparten un mismo puerto, dado que cada enlace corresponde con un puerto.</p>
</li>
<li>
<p>Un enlace puede estar asociado a mÃ¡s de dos procesos, puesto que mÃºltiples procesos pueden compartir el mismo puerto</p>
</li>
<li>
<p>Entre cada par de procesos en comunicaciÃ³n pueden haber varios enlaces, cada uno de los
cuales corresponde a un puerto.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Colas de mensajes en sistemas POSIX</div>
<div class="paragraph">
<p>El estÃ¡ndar POSIX tambiÃ©n define un <a href="https://www.man7.org/linux/man-pages/man7/mq_overview.7.html">sistema de colas de mensajes</a> pero es bastante diferente a la soluciÃ³n en Windows API.</p>
</div>
<div class="paragraph">
<p>Para usarlo, lo primero es abrir o crear âsi aun no existeâ la cola de mensajes llamando a <a href="https://man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">mqd_t</span> <span class="n">mqueue</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span>
    <span class="s">"/foo-mqueue"</span><span class="p">,</span>      <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_RDWR</span><span class="p">,</span>   <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="mo">0644</span><span class="p">,</span>               <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="nb">NULL</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre que identifica la cola de mensajes.
Como con los archivos, para que varios procesos puedan acceder a la misma cola, deben indicar el mismo nombre.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Valores que indican diferentes opciones a la hora de abrir la cola de mensajes.
Por ejemplo, usando <code>O_RDWR</code> se indica abrir para enviar o recibir y con <code>O_CREAT</code> se indica que la cola debe crearse si no existe previamente.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Indica los permisos de la cola de mensajes al crearla nueva, de forma similar a los permisos que se aplican a los archivos.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El valor devuelto por <a href="https://man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a> es el descriptor de la cola de mensajes.
Como otros descriptores, se hereda de padres a hijos al usar <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a>.</p>
</div>
<div class="paragraph">
<p>Este descriptor se utiliza como primer argumento en funciones posteriores para indicar sobre quÃ© cola queremos realizar la correspondiente operaciÃ³n.
Por ejemplo, para enviar un mensaje se utiliza <a href="https://man7.org/linux/man-pages/man3/mq_send.3.html">mq_send()</a> asÃ­:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="nf">mq_send</span><span class="p">(</span>
    <span class="n">mqueue</span><span class="p">,</span>                 <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">message</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">),</span>        <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="mi">0</span>                       <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Descriptor de la cola a la que enviar el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Puntero a la direcciÃ³n de memoria donde estÃ¡ el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>TamaÃ±o del mensaje en bytes.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Prioridad del mensaje.
Los mensaje con mayor prioridad se entregarÃ¡n antes.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Mientras que para recibir un mensaje se utiliza <a href="https://man7.org/linux/man-pages/man3/mq_receive.3.html">mq_receive()</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msg_prio</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">mq_receive</span><span class="p">(</span>
    <span class="n">mqueue</span><span class="p">,</span>                 <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">message</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">),</span>        <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="o">&amp;</span><span class="n">msg_prio</span>               <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Descriptor de la cola de la que recibir el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Puntero a la direcciÃ³n de memoria donde guardar el mensaje al recibirlo.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>TamaÃ±o mÃ¡ximo de espacio reservado en <code>message</code> para guardar el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Puntero a variable entera dÃ³nde devolver la prioridad del mensaje recibido.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como los mensajes no se dirigen directamente a los procesos sino a estas entidades llamadas colas de mensajes, se trata de un caso de <strong>comunicaciÃ³n indirecta</strong>.
AdemÃ¡s, el <strong>tamaÃ±o de los mensajes es variable</strong>, aunque limitado por defecto a 8 KiB si no se configura de otra manera.</p>
</div>
<div class="paragraph">
<p>Si varios procesos intentan recibir de una misma cola de mensajes al mismo tiempo, queda en manos del sistema operativo decidir cuÃ¡l recibirÃ¡ el siguiente mensaje que llegue.
Por lo general es el primero en ser escogido por el planificador de la CPU para seguir ejecutÃ¡ndose.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_recepciÃ³n_concurrente">RecepciÃ³n concurrente</h5>
<div class="paragraph">
<p>Este tipo de comunicaciÃ³n da lugar a algunas situaciones que deben ser resueltas durante el diseÃ±o.</p>
</div>
<div class="paragraph">
<p>Â¿QuÃ© ocurre, por ejemplo, si los procesos A, B y C comparten el puerto P; A manda un mensaje y B y C invocan <code>receive()</code> en el puerto P al mismo tiempo?.
La respuesta correcta dependerÃ¡ de la elecciÃ³n de los los diseÃ±adores del sistema:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No permitir que cada enlace de comunicaciÃ³n ây por tanto cada puertoâ estÃ© asociado a mÃ¡s de dos procesos.</p>
</li>
<li>
<p>No permitir que mÃ¡s de un proceso puedan ejecutar <code>receive()</code> al mismo tiempo.
Por ejemplo, en algunos sistemas solo el proceso que crea el puerto tiene permisos para recibir de Ã©l.
Los sistemas que optan por esta soluciÃ³n suelen disponer de algÃºn mecanismo para que un proceso pueda transferir el permiso de recibir a otros procesos.</p>
</li>
<li>
<p>Permitir que el sistema operativo escoja arbitrariamente quiÃ©n recibe el mensaje si dos o mÃ¡s procesos ejecutan <code>receive()</code> al mismo tiempo.
La elecciÃ³n puede ser aleatoria, mediante algÃºn algoritmo, por ejemplo, por turnos o el siguiente proceso en obtener la CPU, a criterio del planificador de la CPU.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_buffering_2">10.3. Buffering</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los mensajes intercambiados por enlace de comunicaciÃ³n se almacenan en una cola temporal, a la espera de ser enviados o, tras recibirlos, a la espera de que los reclame el proceso.</p>
</div>
<div class="paragraph">
<p>BÃ¡sicamente hay tres formas de implementar dicha cola:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Con <strong>capacidad cero</strong> o <strong>sin buffering</strong> la cola tiene una capacidad mÃ¡xima de 0 mensajes, por lo que no puede haber ningÃºn mensaje esperando en el enlace.
En este caso el proceso transmisor se bloquea en espera hasta que el receptor recibe el mensaje.</p>
</li>
<li>
<p>Con <strong>buffering automÃ¡tico</strong>, dÃ³nde existe dos opciones:</p>
<div class="ulist">
<ul>
<li>
<p>Con <strong>capacidad limitada</strong> la cola tiene una capacidad mÃ¡xima de \$N\$ mensaje, por lo que si la cola se llena el proceso transmisor se bloquea a la espera de que haya espacio en la cola.
Obviamente, mientras la cola no se llene en transmisor puede seguir metiendo mensajes sin bloquearse.</p>
</li>
<li>
<p>Con <strong>capacidad ilimitada</strong> la cola es de longitud potencialmente infinita, lo que permite que el transmisor nunca espere.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Las colas de longitud infinita son imposibles, puesto que los recursos son limitados.
En realidad este tÃ©rmino hace referencia a colas de longitud variable cuyo mÃ¡ximo viene determinado por la memoria principal disponible, que suele ser lo suficientemente grande como para que podamos considerar que las colas son infinitas.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Buffering en las colas de mensajes POSIX</div>
<div class="paragraph">
<p>Las colas de mensajes en sistemas POSIX tienen capacidad limitada.
Los lÃ­mites se configuran al crear la cola, a travÃ©s del Ãºltimo argumento de <a href="https://man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span>  <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">.</span><span class="n">mq_maxmsg</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>      <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="p">.</span><span class="n">mq_msgsize</span> <span class="o">=</span> <span class="mi">2049</span>   <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">};</span>

<span class="n">mqd_t</span> <span class="n">mqueue</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span>
    <span class="s">"/foo-queue"</span><span class="p">,</span>
    <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_RDWR</span><span class="p">,</span>
    <span class="mo">0644</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">attr</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Estructura con propiedades para la cola cuando Ã©sta se crea nueva.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Una de las propiedades es el nÃºmero mÃ¡ximo de mensajes en la cola al mismo tiempo.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Otra de las propiedades es el tamaÃ±o mÃ¡ximo de cada mensaje.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Estos limites tienen unos valores por defecto por si en el lugar de <code>attr</code> en <a href="https://man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a> se indica <code>NULL</code>.
El estÃ¡ndar POSIX indica que esos valores por defecto dependen de cada sistema operativo, por lo que es necesario ir a la documentaciÃ³n para desarrolladores de cada sistema para conocer los detalles en cada caso concreto.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en Linux los valores por defecto son 10 mensajes y 8 KiB por mensaje, siendo estos, ademÃ¡s, los valores mÃ¡ximos que admiten esas propiedades.
Estos valores mÃ¡ximos y por defecto se pueden cambiar de forma global para todo el sistema, por si tuviÃ©ramos interÃ©s en valores mÃ¡s altos.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_operaciones_sÃ­ncronas_y_asÃ­ncronas">10.4. Operaciones sÃ­ncronas y asÃ­ncronas</h3>
<div class="paragraph">
<p>La comunicaciÃ³n entre dos procesos tiene lugar por medio de las llamadas <code>send()</code> y <code>receive()</code>; de tal forma que generalmente la primera se bloquea cuando la cola de transmisiÃ³n se llena âen funciÃ³n del tipo de <em>buffering</em>â mientras que la segunda lo hace cuando la cola de recepciÃ³n estÃ¡ vacÃ­a.</p>
</div>
<div class="paragraph">
<p>Sin embargo, en lugar de bloquearse, puede que aun proceso le interese ejecutar otras tareas en la CPU.
A fin de cuentas las comunicaciones son bastante lentas, por lo que en caso de bloquearse podrÃ­a estar dejando de aprovechar bastante tiempo de CPU.
Incluso puede darse el caso que tengan conexiÃ³n con otros procesos y que quiera aprovecha para intentar comunicarse con alguno de ellos.</p>
</div>
<div class="paragraph">
<p>Por eso existen diferentes opciones de diseÃ±o a la hora de implementar las llamadas anteriores en funciÃ³n de si se pueden bloquear o no.
Concretamente, el paso de mensajes puede ser <strong>sÃ­ncrono</strong> âcon bloqueoâ o <strong>asÃ­ncrono</strong> âsin bloqueoâ.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Cuando el envÃ­o es asÃ­ncrono</strong>, el proceso transmisor nunca se bloquea.
Si se llamada a <code>send()</code> cuando la cola de mensajes estÃ© llena, lo mÃ¡s comÃºn es que retorne con un cÃ³digo de retorno que indique que el proceso debe volver a intentar el envÃ­o mÃ¡s tarde.</p>
</li>
<li>
<p><strong>Cuando el envÃ­o es sÃ­ncrono</strong>, el proceso transmisor se bloquea cuando no queda espacio en la cola de mensajes y hasta que pueda depositar el mensaje en la misma.</p>
</li>
<li>
<p><strong>Cuando la recepciÃ³n es asÃ­ncrona</strong>, el proceso receptor nunca se bloquea.
En caso de que la cola de mensajes estÃ© vacÃ­a, el sistema operativo puede indicar al proceso que lo intente mÃ¡s tarde a travÃ©s de un cÃ³digo de retorno o devolviendo un mensaje vacÃ­o.</p>
</li>
<li>
<p><strong>Cuando la recepciÃ³n es con bloqueo</strong>, el receptor se bloquea cuando no hay mensajes en la cola y hasta que llegue alguno.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Algunos sistemas de paso de mensajes son claramente sÃ­ncronos o asÃ­ncronos.
Mientras que otros permiten activar un modo u otro segÃºn las necesidades del aplicaciÃ³n.
E incluso los hay que soportan que transmisiÃ³n y recepciÃ³n sean sÃ­ncronas o asÃ­ncronas de manera totalmente independiente.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Comunicaciones asÃ­ncronas con colas de mensajes POSIX</div>
<div class="paragraph">
<p>Por defecto las colas de mensajes son sÃ­ncronas, tanto en envÃ­o como en recepciÃ³n.
Es decir, si al enviar un mensaje la cola estÃ¡ llena, el proceso transmisor quedarÃ¡ bloqueado en estado <strong>esperando</strong> hasta que haya un hueco libre para depositar el nuevo mensaje.
Si al recibir un mensaje la cola estÃ¡ vacÃ­a, el proceso receptor quedarÃ¡ bloqueado hasta que otro proceso deposite un mensaje.</p>
</div>
<div class="paragraph">
<p>Sin embargo, si en el argumento <code>oflag</code> de <a href="https://man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a> un proceso indica la opciÃ³n <code>O_NONBLOCK</code> estas operaciones para ese proceso en esa cola serÃ¡n asÃ­ncronas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">mqd_t</span> <span class="n">mqueue</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span>
    <span class="s">"foo-mqueue"</span><span class="p">,</span>
    <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="mo">0644</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">attr</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Abrir la cola de mensajes para solo lectura âcon <code>O_RDONLY</code>â y para comunicaciones asÃ­ncronas âcon <code>O_NONBLOCK</code>â.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Eso quiere decir que las funciones <a href="https://man7.org/linux/man-pages/man3/mq_send.3.html">mq_send()</a> y <a href="https://man7.org/linux/man-pages/man3/mq_receive.3.html">mq_receive()</a>, en lugar de bloquear el proceso en estado de esperando, devolverÃ¡n -1 y el valor de <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a> serÃ¡ <code>EAGAIN</code>.
AsÃ­ el proceso puede aprovechar el tiempo de CPU del que dispone para realizar otras tareas mientras tanto y volver a intentarlo mÃ¡s tarde.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">mq_receive</span><span class="p">(</span><span class="n">mqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">msg_prio</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">return_code</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">{</span>
    <span class="c1">// AquÃ­ va cÃ³digo para usar el mensaje recibido...</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">return_code</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">{</span>
    <span class="c1">// AquÃ­ va cÃ³digo para manejar el error de mq_receive()...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Si todo va bien, <a href="https://man7.org/linux/man-pages/man3/mq_receive.3.html">mq_receive()</a> devuelve el tamaÃ±o en bytes del mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Si devuelve -1, es que ha ocurrido un error. Pero solo serÃ¡ un error eal si el cÃ³digo de error en <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a> no es <code>EAGAIN</code>.
Si es <code>EAGAIN</code>, se pueden ejecutar otras partes del programa y volver a intentar la recepciÃ³n mÃ¡s adelante.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Si un proceso debe comunicarse mediante varias colas de mensajes, la comunicaciÃ³n asÃ­ncrona tambiÃ©n sirve para intentar recibir y enviar de varias colas sin bloquearse en ninguna.
Para este caso algunos sistemas ofrece una alternativa mÃ¡s sencilla y eficiente, que veremos en el <a href="#_colas_de_mensajes_posix">Apartado 10.5.1</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ejemplos_de_sistemas_de_paso_de_mensajes">10.5. Ejemplos de sistemas de paso de mensajes</h3>
<div class="sect3">
<h4 id="_colas_de_mensajes_posix">10.5.1. Colas de mensajes POSIX</h4>
<div class="paragraph">
<p>Como hemos comentado a lo largo de capÃ­tulo, las colas de mensajes POSIX son un caso de <strong>comunicaciÃ³n indirecta</strong>, con <strong>tamaÃ±o de mensaje variable</strong>, <em>buffering</em> con <strong>capacidad limitad</strong> y que soporta operaciones <strong>asÃ­ncronas</strong>.</p>
</div>
<div class="paragraph">
<p>Las colas de mensajes son Ãºtiles para enviar mensajes de pequeÃ±o tamaÃ±o entre procesos que se ejecutan en el mismos sistema.
AdemÃ¡s tienen la posibilidad de asociar a cada mensaje una prioridad, de tal forma que se reciban primero los mensajes de prioridad mÃ¡s alta.
Su uso es relativamente comÃºn en sistemas de tiempo real, aunque lo mÃ¡s frecuente en los sistemas de propÃ³sito general es usar <em>sockets</em>.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/message_queue.hpp">message_queue.hpp</a> se puede ver un ejemplo de una clase desarrollada en C++ para utilizar colas de mensajes POSIX.
En los distintos mÃ©todos se puede ver como se utilizan las funciones de la librerÃ­a del sistema para crear la cola y enviar y recibir mensajes.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/mqueue-client.cpp">mqueue-server.cpp</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/mqueue-client.cpp">mqueue-client.cpp</a> se puede ver un ejemplo de cÃ³mo se utiliza la clase en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/message_queue.hpp">message_queue.hpp</a>.
El primero es un programa que muestra la hora del sistema periÃ³dicamente.
El segundo se puede comunicar con el primero a travÃ©s de una cola de mensajes para controlarlo.
En ejemplo es muy sencillo, asÃ­ que, por el momento, lo Ãºnico que puede hacer <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/mqueue-client.cpp">mqueue-client.cpp</a> es pedirle a <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/mqueue-client.cpp">mqueue-server.cpp</a> que termine.
Aunque no costarÃ­a nada aÃ±adir otras Ã³rdenes, como pedir que cambie la hora del sistema o la periodicidad con la que la muestra.</p>
</div>
<div class="paragraph">
<p>En Linux los descriptores de colas de mensajes son descriptores de archivo âcomo tambiÃ©n lo son los descriptores de <em>sockets</em>, tuberÃ­as y los de archivos abiertos con <a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>, entre otrosâ. Esta particularidad implica que en Linux, mediante las funciones <a href="https://man7.org/linux/man-pages/man2/select.2.html">select()</a>, <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> o <a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll()</a>, se pueden monitorizar al mismo tiempo varios descriptores de colas de mensajes, para asÃ­ saber cuÃ¡ndo se puede enviar o recibir por ellas sin que el proceso se bloquee.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Este comportamiento es especÃ­fico de Linux.
No estÃ¡ contemplado en el estÃ¡ndar POSIX, por lo que otros sistemas POSIX no tienen por quÃ© soportarlo.
AsÃ­ que no es portable.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A continuaciÃ³n se puede ver un ejemplo especÃ­fico con <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a>, aunque las tres funciones se utilizan empleando un patrÃ³n similar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">mqd_t</span> <span class="n">mqueue1</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span> <span class="s">"/foo-queue"</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">mqd_t</span> <span class="n">mqueue2</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span> <span class="s">"/bar-queue"</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span>

<span class="k">struct</span> <span class="n">pollfd</span> <span class="n">fds</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">mqueue1</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="p">,</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="p">.</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">},</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">mqueue2</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLOUT</span><span class="p">,</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="p">.</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">quit_app</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">poll</span><span class="p">(</span> <span class="n">fds</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="k">if</span> <span class="p">(</span><span class="n">return_code</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLIN</span><span class="p">)</span> <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="p">{</span>
            <span class="n">mq_receive</span><span class="p">(</span> <span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fd</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span>

            <span class="c1">// AquÃ­ va cÃ³digo para usar el mensaje recibido...</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLIN</span><span class="p">)</span> <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="p">{</span>
            <span class="n">mq_receive</span><span class="p">(</span> <span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">fd</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span>

            <span class="c1">// AquÃ­ va cÃ³digo para usar el mensaje recibido...</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLOUT</span><span class="p">)</span> <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="p">{</span>
            <span class="c1">// AquÃ­ va cÃ³digo para preparar el mensaje a enviar...</span>

            <span class="n">mq_send</span><span class="p">(</span> <span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">fd</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">return_code</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="p">{</span>
        <span class="c1">// Error en poll().</span>
        <span class="c1">// AquÃ­ va cÃ³digo para leer errno y manejar el error...</span>

        <span class="n">quit_app</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Abrimos o creamos las colas que vamos a utilizar.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Creamos un <em>array</em> de la estructura <code>pollfd</code> con un elemento por cola que vamos a monitorizar con <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a>.
En cada estructura, en el campo <code>fd</code>, se indica el descriptor de cada una de las cola de mensajes.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Para cada cola hay que utilizar el campo <code>events</code> para indicar quÃ© queremos que monitorice <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a>.
<code>events</code> es una mÃ¡scara de bit donde a cada evento monitorizable le corresponde un bit.
Si queremos monitorizar un evento, debemos poner su bit a 1.
<div class="paragraph">
<p>Para eso nos podemos ayudar de macros como <code>POLLIN</code> y <code>POLLOUT</code>.
Por ejemplo, para <code>mqueue1</code> se quiere monitorizar cuÃ¡ndo hay mensajes para recibir, por lo que se activa <code>POLLIN</code>.
Mientras que para <code>mqueue2</code> se quiere saber tanto cuÃ¡ndo hay mensajes para recibir como cuÃ¡ndo hay un hueco en la cola para enviar sin bloqueos, por lo que se activan <code>POLLIN</code> y <code>POLLOUT</code>.</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Iterativamente se llama a <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> âmientras no queramos que termine la aplicaciÃ³nâ que pondrÃ¡ el proceso en estado <strong>esperando</strong> hasta que ocurra alguno de los eventos que nos interesan.
<a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> necesita <code>fds</code> âel <em>array</em> de la estructura <code>pollfd</code> que hemos inicializado previamenteâ el nÃºmero de elementos en el <em>array</em> y el tiempo mÃ¡ximo que debe mantener bloqueado el proceso esperando a que ocurra alguno de los eventos.
Con un nÃºmero negativo en este Ãºltimo campo, se indica que queremos que espere indefinidamente.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Si <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> tiene Ã©xito, devuelve un numero positivo que indica en cuÃ¡ntos descriptores se ha detectado un evento.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Si <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> devuelve un valor negativo, es que ha ocurrido algÃºn error.
El motivo del error se puede conocer comprobando el valor de la variable global <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>El campo <code>revents</code> es una mÃ¡scara de bits similar a <code>events</code>, pero al retornar de <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> indica quÃ© eventos se han detectado, para cada cola de mensajes en <code>fds</code>.
<div class="paragraph">
<p>Por ejemplo, en ambas colas se comprueba si <code>POLLIN</code> estÃ¡ activo.
En caso afirmativo, sabemos que podemos leer un mensaje sin que <a href="https://man7.org/linux/man-pages/man3/mq_receive.3.html">mq_receive()</a> se bloquee.
Igualmente, sabemos si <code>mqueue2</code> tiene hueco para enviar un mensaje comprobando si <code>POLLOUT</code> estÃ¡ activo.
En caso afirmativo, podemos enviar un mensaje con <a href="https://man7.org/linux/man-pages/man3/mq_send.3.html">mq_send()</a> sabiendo que no se bloquearÃ¡.</p>
</div></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_seÃ±ales_en_sistemas_operativos_posix">10.5.2. SeÃ±ales en sistemas operativos POSIX</h4>
<div class="paragraph">
<p>En los sistemas POSIX, una forma mÃ¡s sencilla de comunicar dos procesos del mismo sistema es mediante el envÃ­o de una <strong>seÃ±al</strong> de uno al otro.</p>
</div>
<div class="paragraph">
<p>Los procesos pueden mandar seÃ±ales utilizando la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/kill.2.html">kill()</a>, que sÃ³lo requiere el identificador del proceso de destino y el nÃºmero que identifica la seÃ±al.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Como se usa el identificado del proceso, estamos hablando de un mecanismo de <strong>comunicaciÃ³n directa</strong>.</p>
</div>
<div class="paragraph">
<p>El <strong>tamaÃ±o y formato del mensaje es fijo</strong>.
Las seÃ±ales solo pueden portar la informaciÃ³n de que ha ocurrido un evento, indicado quÃ© evento es a travÃ©s del nÃºmero que identifica la seÃ±al.</p>
</div>
<div class="paragraph">
<p>Cada seÃ±al tiene un efecto particular por defecto âque por lo general es matar al procesoâ en el proceso que las recibe.
Sin embargo, cada proceso puede declarar un <strong>manejador de seÃ±al</strong>.
Una funciÃ³n del programa que serÃ¡ invocada por el sistema operativo para tratar una seÃ±al determinada, interrumpiendo lo que estÃ© haciendo el proceso en ese momento.
En ese sentido las seÃ±ales en POSIX puede interpretarse como una forma de interrupciÃ³n por software.</p>
</div>
<div class="paragraph">
<p>El <strong>manejador de seÃ±al</strong> se puede configurar usando la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/signal.2.html">signal()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">signal</span><span class="p">(</span>
    <span class="n">SIGTERM</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">&amp;</span><span class="n">mi_manejador_de_sigterm</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Identificador de la seÃ±al a recibir.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Puntero al manejador de seÃ±al.
Es decir, la del programa que serÃ¡ llamada por el sistema operativo cuando llegue la seÃ±al <code>SIGTERM</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El problema de <a href="https://man7.org/linux/man-pages/man2/signal.2.html">signal()</a> es que el estÃ¡ndar POSIX permite diferencias que hacen que se pueda comportar de forma distinta en diferentes sistemas operativos.
Para resolverlo, el estÃ¡ndar recomienda usar <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html">sigaction</a> en su lugar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">sigaction</span> <span class="n">act</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi_manejador_de_sigterm</span><span class="p">,</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="p">.</span><span class="n">sa_sigaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>   <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="p">.</span><span class="n">sa_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>           <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="n">SA_RESTART</span><span class="p">,</span> <i class="conum" data-value="7"></i><b>(7)</b>
<span class="p">}</span>

<span class="n">sigaction</span><span class="p">(</span>
    <span class="n">SIGTERM</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">&amp;</span><span class="n">act</span><span class="p">,</span>    <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="nb">NULL</span>     <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Identificador de la seÃ±al a recibir.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Puntero a una estructura de tipo <code>sigaction</code> que describe los detalles de como tratar la seÃ±al cuando llega al proceso.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Puntero a una estructura de tipo <code>sigaction</code> donde <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html">sigaction</a> guarda la configuraciÃ³n anterior sobre como tratar la seÃ±al indicada.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Puntero al manejador de seÃ±al para la seÃ±al indicada.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Puntero a un manejador de seÃ±al alternativo al de <code>sa_handler</code>.
Este manejador recibe mÃ¡s informaciÃ³n sobre la seÃ±al cuando es llamado.
Para activar es necesario indicar <code>SA_SIGINFO</code> en el campo <code>sa_flags</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>MÃ¡scara de bits de seÃ±ales a bloquear durante el manejo de la seÃ±al.
Cada bit de la mÃ¡scara identifica a una seÃ±al.
Deben ponerse a 1 aquellas seÃ±ales que queremos que estÃ©n bloqueadas âes decir, que no se puedan recibirâ mientras se ejecuta el manejador de seÃ±al porque ha llegado una.
Es especialmente Ãºtil si se va a usar el mismo manejador para varias seÃ±ales.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Opciones de configuraciÃ³n.
Por ejemplo, <code>SA_RESTART</code> indica que si la seÃ±al llega durante una llamada al sistema, la llamada debe continuar una vez se haya salido del manejador de seÃ±al.
El comportamiento por defecto, sin esta opciÃ³n, es que la llamada al sistema interrumpida falle con el error <code>EINTR</code> en <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Las seÃ±ales fueron diseÃ±adas originalmente como un mecanismo para que el sistema operativo notificara a los programas ciertos errores y sucesos crÃ­ticos.
Por ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La seÃ±al <code>HUP</code> o <code>SIGHUP</code> es enviada a cada proceso iniciado desde una sesiÃ³n de terminal cuando dicha sesiÃ³n termina âo cuando se usa la combinaciÃ³n de teclas <span class="keyseq"><kbd>CTRL</kbd>+<kbd>D</kbd></span>, que tiene el mismo efectoâ.</p>
<div class="paragraph">
<p>En el caso de los servicios del sistema âque, como no son interactivos, no estÃ¡n conectados a ninguna terminarâ esta seÃ±al suele usarse para indicarles que deben reiniciarse, volviendo a leer sus archivos de configuraciÃ³n, o para que guarden su estado interno en algÃºn sitio conocido del almacenamiento.</p>
</div>
</li>
<li>
<p>La seÃ±al <code>INT</code> o <code>SIGINT</code> es enviada al proceso que estÃ¡ enganchado a la consola cuando el usuario pulsa el carÃ¡cter de interrupciÃ³n âfrecuentemente la combinaciÃ³n de teclas <span class="keyseq"><kbd>CTRL</kbd>+<kbd>C</kbd></span>â.</p>
</li>
<li>
<p>La seÃ±al <code>TERM</code> o <code>SIGTERM</code> es enviada al proceso cuando debe terminar.
Por ejemplo, el sistema operativo envÃ­a esta seÃ±al a todos los procesos cuando se estÃ¡ apagando el sistema.</p>
</li>
<li>
<p>La seÃ±al <code>SEGV</code> o <code>SIGSEGV</code> es enviada a un proceso cuando intenta acceder a una zona de memoria a la que no tiene permiso.
Si no se maneja esta seÃ±al, el programa termina con el conocido mensaje de <strong>violaciÃ³n de segmento</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Obviamente hay muchas mÃ¡s seÃ±ales.
Entre todas, el estÃ¡ndar POSIX incluye dos seÃ±ales â<code>USR1</code> y <code>USR2</code>â especialmente indicadas para usarlas con el significado que nosotros queramos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Se puede consultar una lista de las seÃ±ales del estÃ¡ndar POSIX en <a href="https://es.wikipedia.org/wiki/Se%C3%B1al_(inform%C3%A1tica)">Â«SeÃ±ales (informÃ¡tica)&#8201;&#8212;&#8201;WikipediaÂ»</a>.
Mientras que la lista completa de seÃ±ales soportadas en Linux se puede consultar en el <a href="https://man7.org/linux/man-pages/man7/signal.7.html">manual</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El ejemplo en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/mqueue-client.cpp">mqueue-server.cpp</a> y en otros ejemplos de este capÃ­tulo, utiliza seÃ±ales para manejar <code>SIGINT</code>, <code>SIGTERM</code> y para mostrar la hora periÃ³dicamente.
El cÃ³digo dedicado a eso estÃ¡ en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/common/timeserver.c">timeserver.c</a> y se comparte entre todos los ejemplos.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/signals.c">signals.c</a> hay un programa de ejemplo que muestra cÃ³mo manejar las seÃ±ales del sistema y que sirve para ver como funcionan.
Solo hay que ejecutarlo y luego enviarle seÃ±ales con el comando <code>kill</code> desde otra terminal.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tuberÃ­as">10.5.3. TuberÃ­as</h4>
<div class="paragraph">
<p>Las <strong>tuberÃ­as</strong> son un mecanismo de paso de mensajes de <strong>comunicaciÃ³n indirecta</strong>, <strong>orientada a flujos</strong>, <strong>capacidad limitada</strong> y, generalmente, <strong>comunicaciÃ³n sÃ­ncrona</strong> âaunque en algunos sistema operativos tambiÃ©n puede soportar asÃ­ncronaâ.</p>
</div>
<div class="paragraph">
<p>Conceptualmente cada tuberÃ­a tiene dos extremos en los que se puede leer y escribir mediante las operaciones bÃ¡sicas de lectura y escritura de archivos <code>read()</code> y <code>write()</code>.
Un extremo permite los procesos en ese extremo escribir en la tuberÃ­a, mientras el otro extremo permite a los procesos leer de la tuberÃ­a los datos escritos desde el otro extremo.</p>
</div>
<div class="paragraph">
<p>Existen dos tipos de tuberÃ­as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Las <strong>tuberÃ­as anÃ³nimas</strong> sÃ³lo existen en el espacio de direcciones del proceso que las crea, de tal forma que debe heredarse de padres a hijos para que otros procesos puedan tener acceso.</p>
</li>
<li>
<p>Las <strong>tuberÃ­as con nombre</strong> son pÃºblicas al resto del sistema, por lo que teÃ³ricamente cualquier proceso con permisos puede abrir una para comunicarse con otros procesos.
Por eso se suele utilizar en aplicaciones cliente-servidor, dÃ³nde un proceso servidor ofrece algÃºn servicio a otros procesos cliente a travÃ©s de la tuberÃ­a.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En los sistemas POSIX las <strong>tuberÃ­as con nombre</strong> se denominan <em>FIFO</em> y tienen presencia en el sistema de archivos como archivos especiales.</p>
</div>
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabla 3. Funciones de la API para manipular tuberÃ­as.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POSIX API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Windows API</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Crear tuberÃ­a anÃ³nima</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/pipe.2.html">pipe()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe">CreatePipe()</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Crear tuberÃ­a con nombre</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man3/mkfifo.3.html">mkfifo()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe()</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Abrir tuberÃ­a con nombre</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile()</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Leer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile">ReadFile()</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Escribir</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile">WriteFile()</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cerrar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle()</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Con <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> es muy sencillo lanzar otros procesos para que ejecuten tareas en paralelo.
El proceso hijo tiene acceso a los datos del padre por la forma en la que funciona <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> y gracias a las tuberÃ­as anÃ³nimas puede comunicar los resultados al padre.
En {forkpipe_cpp} se puede observar un ejemplo de esto.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, el hecho de que cada extremo se comporte como un archivo âuno en modo solo lectura y el otro en modo solo escrituraâ hace posible redirigir la E/S estÃ¡ndar del proceso hijo.
Es decir, conectar la entrada, la salida estÃ¡ndar o la salida de error a una tuberÃ­a, desde la que leer lo que el proceso intenta imprimir por la pantalla de la terminal o proporcionarle lo que debe leer, como si fuera desde el teclado.
En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/fork-redir.c">fork-redir.c</a> se puede ver un ejemplo de como ejecutar el comando <code>ls</code> y redirigir su salida al proceso padre para contar el nÃºmero de lÃ­neas en lo que eÃ± comando querÃ­a mostrar por pantalla.</p>
</div>
<div class="paragraph">
<p>Por otro lado, las tuberÃ­as con nombre permiten que un proceso se comunique con cualquier otro, solo con conocer la ruta de la tuberÃ­a.
En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/fifo-client.c">fifo-server.c</a> tenemos un ejemplo de un programa que muestra la hora del sistema de forma periÃ³dica, mientras espera Ã³rdenes de una tuberÃ­a que sirve de canal de control remoto.
Los programas en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/fifo-client.c">fifo-client.c</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/fifo-client.cpp">fifo-client.cpp</a> pueden conectarse a esa tuberÃ­a y mandar el comando que hace terminar <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/fifo-client.c">fifo-server.c</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sockets">10.5.4. Sockets</h4>
<div class="paragraph">
<p>Mientras que las tuberÃ­as son conceptualmente un enlace de comunicaciÃ³n unidireccional que tiene dos extremos, un <strong><em>socket</em></strong> representa un solo extremo en un enlace de comunicaciÃ³n bidireccional.
Para que una pareja de procesos se pueda comunicar son necesarios dos <em>sockets</em> âuno en cada procesoâ de manera que cada uno de ellos es el medio por el que el proceso accede al enlace de comunicaciÃ³n.</p>
</div>
<div class="paragraph">
<p>La API de <em>sockets</em> fue creada por la Universidad de Berkeley para abstraer el acceso a la familia de protocolos de Internet en el UNIX desarrollado por esa misma universidad.
Sin embargo, rÃ¡pidamente se convirtiÃ³ en el estÃ¡ndar de facto para la comunicaciÃ³n en red, por lo que todos los sistemas operativos modernos âincluidos los sistemas POSIX y Microsoft Windowsâ tienen una implementaciÃ³n de la misma.</p>
</div>
<div class="paragraph">
<p>Pese a sus orÃ­genes en Internet, los <em>sockets</em> se diseÃ±aron para ser independientes de la tecnologÃ­a de red subyacente con la que se implementa el enlace de comunicaciÃ³n.
En Linux, por ejemplo, se puede utilizar como interfaz de programaciÃ³n para utilizar dos decenas de familias de protocolos y tecnologÃ­as diferentes.</p>
</div>
<div class="paragraph">
<p>Para crear un <em>socket</em> te utiliza la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/socket.2.html">socket()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">AF_UNIX</span><span class="p">,</span>         <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">SOCK_DGRAM</span><span class="p">,</span>      <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="mi">0</span>
<span class="p">)</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>En sistemas POSIX la funciÃ³n devuelve un <code>int`con el descriptor del socket mientras que en Microsoft Windows devuelve un `HANDLE</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>En el primer argumento se especifica la familia de protocolos.
<code>AF_UNIX</code> son un tipo de <em>socket</em> que solo sirve para comunicar procesos en el mismo sistema, denominado <strong>socket de dominio UNIX</strong>.
Otras familias muy comunes son <code>AF_INET</code>, que corresponde a la la familia de protocolos TCP/IP y <code>AF_INET6</code> para los protocolos IPv6.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>En el segundo argumento se especifica el tipo del <em>socket</em>.
Cada tipo suele corresponde con un protocolo concreto de la familia elegida.
Por ejemplo, los <em>sockets</em> <code>SOCK_DGRAM</code> son Â«no orientados a conexiÃ³nÂ», no fiables y de longitud mÃ¡xima fija, asÃ­ que en la familia <code>AF_INET</code> estos <em>sockets</em> utiliza UDP.
Mientras que los <em>sockets</em> <code>SOCK_STREAM</code> son orientados a conexiÃ³n, fiables, bidireccionales y orientados a flujo, por lo que en la familia <code>AF_INET</code> utilizan TCP.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Un <em>socket</em> reciÃ©n creado no tiene un nombre que otro proceso pueda usar para identificarlo y comunicarse con Ã©l.
Para asignar ese nombre o direcciÃ³n se utiliza <a href="https://man7.org/linux/man-pages/man2/bind.2.html">bind()</a>.
La dificultad es que cada familia de protocolos tiene un formato de direcciones diferente, asÃ­ que hay que tener cuidado de usar le adecuado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">sun_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">,</span>        <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="p">.</span><span class="n">sun_path</span> <span class="o">=</span> <span class="s">"/tmp/foo-socket"</span> <i class="conum" data-value="6"></i><b>(6)</b>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">result_code</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">sockfd</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">)</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Como en el esto de llamadas al sistema, en caso de error se devuelve un nÃºmero negativo y <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a> contendrÃ¡ el cÃ³digo del error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>El descriptor del <em>socket</em> al que se le quiere cambiar la direcciÃ³n.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>La nueva direcciÃ³n del <em>socket</em> especificada como una estructura adecuada para la familia del <em>socket</em>.
En <em>socket</em> de tipo <code>AF_UNIX</code> la estructura debe ser de tipo <code>sockaddr_un</code> mientras que en los de tipo <code>AF_INET</code> es del tipo <code>sockaddr_in</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>El tamaÃ±o en bytes de la estructura con la nueva direcciÃ³n.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>En la estructura con la direcciÃ³n, el primero campo siempre es para indicar la familia.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>En los <em>sockets</em> de dominio UNIX la direcciÃ³n es una ruta en el sistema de archivos.
Para otras familias, la direcciones se indica de otra manera, por lo que es necesario consultar la documentaciÃ³n.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>La API de <em>sockets</em> incluye muchas otras funciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/listen.2.html">listen()</a>, para poner <em>sockets</em> tipo <code>SOCK_STREAM</code> a la espera de conexiones.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/connect.2.html">connect()</a>, para conectar un <em>socket</em> tipo <code>SOCK_STREAM</code> con otro que estÃ© a la espera de conexiones.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/accept.2.html">accept()</a> para que un <em>socket</em> tipo <code>SOCK_STEAM</code> a la espera de conexiones acepte una solicitud de conexiÃ³n.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/shutdown.2.html">shutdown()</a> para cerrar uno de los sentidos de una conexiÃ³n.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/close.2.html">close()</a> para destruir un <em>socket</em></p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/send.2.html">send()</a>, <a href="https://man7.org/linux/man-pages/man2/send.2.html">sendto()</a> y <a href="https://man7.org/linux/man-pages/man2/send.2.html">sendmsg()</a> para enviar mensajes.
<a href="https://man7.org/linux/man-pages/man2/send.2.html">sendto()</a> sÃ³lo se puede utilizar con <em>sockets</em> conectados.
Mientras que <a href="https://man7.org/linux/man-pages/man2/send.2.html">sendto()</a> permiten indicar la direcciÃ³n del <em>socket</em> de destino, por lo que es Ãºtil en <em>sockets</em> no orientados a conexiÃ³n <code>SOCK_DGRAM</code>.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/recv.2.html">recv()</a>, <a href="https://man7.org/linux/man-pages/man2/recvfrom.2.html">recvfrom()</a> y <a href="https://man7.org/linux/man-pages/man2/recvmsg.2.html">recvmsg()</a> para recibir mensajes.
<a href="https://man7.org/linux/man-pages/man2/recvfrom.2.html">recvfrom()</a> permite obtener la direcciÃ³n del <em>socket</em> del que llegÃ³ el mensaje.
Por eso es Ãºtil en <em>sockets</em> no orientados a conexiÃ³n <code>SOCK_DGRAM</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="n">addr</span><span class="p">;</span>
<span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">result_code</span> <span class="o">=</span> <span class="n">recvfrom</span><span class="p">(</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">sockfd</span><span class="p">,</span>          <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="o">&amp;</span><span class="n">message</span><span class="p">,</span>        <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">),</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="mi">0</span><span class="p">,</span>               <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="o">&amp;</span><span class="n">addrlen</span>         <i class="conum" data-value="7"></i><b>(7)</b>
<span class="p">)</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>En caso de Ã©xito devuelve nÃºmero de bytes del mensaje recibido.
En caso de error, un -1 y <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno</a> contiene el cÃ³digo del error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>El descriptor del <em>socket</em> al que se le quiere cambiar la direcciÃ³n.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Puntero a la direcciÃ³n de memoria donde estÃ¡ el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>TamaÃ±o del mensaje en bytes.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Opciones adicionales de configuraciÃ³n.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Estructura de direcciÃ³n vacÃ­a donde se copiarÃ¡ la direcciÃ³n del <em>socket</em> que remite el mensaje.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Puntero donde la llamada al sistema copiarÃ¡ el tamaÃ±o de la estructura copiada en <code>addr</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Las operaciones con <em>sockets</em> son sÃ­ncronas por defecto.
Sin embargo, es posible configurarlos en modo asÃ­ncrono, para que asÃ­ cualquiera de estas funciones falle, retornando -1 y cÃ³digo de error <code>EAGAIN</code> o <code>EWOULDBLOCK</code>, antes de poner el proceso en estado <strong>esperando</strong>.</p>
</div>
<div class="paragraph">
<p>TambiÃ©n se pueden utilizar las funciones <a href="https://man7.org/linux/man-pages/man2/select.2.html">select()</a> y <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll()</a> para monitorizar varios <em>sockets</em> al mismo tiempo, de forma similar a como se hace para colas de mensajes POSIX (vÃ©ase el <a href="#_colas_de_mensajes_posix">Apartado 10.5.1</a>).</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/socket-client.cpp">socket-server.cpp</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/socket-client.cpp">socket-client.cpp</a> se puede observar un ejemplo similar al que usamos con las tuberÃ­as y las colas de mensajes, pero empleando <em>sockets</em> de dominio UNIX.
Ambos programas utilizan la cabecera <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap10/socket.hpp">socket.hpp</a> que incluye un ejemplo de clase en C++ para comunicaciones mediante <em>sockets</em>.
En los distintos mÃ©todos se puede ver como se utilizan las funciones de la librerÃ­a del sistema para crear <em>sockets</em>, asignarles direcciÃ³n y usarlos para enviar y recibir mensajes.</p>
</div>
<div class="paragraph">
<p>En resumen, los <strong><em>sockets</em></strong> son un mecanismo de paso de mensajes de <strong>comunicaciÃ³n indirecta</strong>, que admite tanto comunicaciÃ³n <strong>orientada a flujos</strong> como <strong>mensajes de tamaÃ±o variable</strong>, <em>buffering</em> de <strong>capacidad limitada</strong> y tanto <strong>comunicaciÃ³n sÃ­ncrona</strong> como <strong>asÃ­ncrona</strong>, aunque el comportamiento real final de la interfaz depende de la tecnologÃ­a de red utilizada.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_memoria_compartida">11. Memoria compartida</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La <strong>memoria compartida</strong> es una estrategia para comunicar procesos dÃ³nde uno de ellos gana acceso a regiones de la memoria del otro; algo que por lo general el sistema operativo siempre intenta evitar.
Por eso, para que pueda haber memoria compartida es necesario que los dos procesos estÃ©n de acuerdo en eliminar dicha restricciÃ³n.</p>
</div>
<div class="paragraph">
<p>Dos procesos que comparten una regiÃ³n de la memoria pueden intercambiar informaciÃ³n simplemente leyendo y escribiendo datos en la misma.
Sin embargo debemos tener en cuenta que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La estructura de los datos y su localizaciÃ³n dentro de la regiÃ³n compartida la determinan los procesos en comunicaciÃ³n y no el sistema operativo, a diferencia de lo que ocurre en los sistemas de paso de mensajes.</p>
</li>
<li>
<p>Los procesos son responsables de sincronizarse para no escribir y leer en el mismo sitio de la memoria al mismo tiempo, pues esto puede generar inconsistencias (vÃ©ase el <a href="#_sincronizaciÃ³n">CapÃ­tulo 13</a>) .</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Las principales ventajas de la memoria compartida frente a otros mecanismos de comunicaciÃ³n son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Eficiencia</strong>.
Puesto que la comunicaciÃ³n tiene lugar a la velocidad de la memoria principal, se trata de un mecanismo tremendamente rÃ¡pido.</p>
</li>
<li>
<p><strong>Conveniencia</strong>.
Puesto que el mecanismo de comunicaciÃ³n sÃ³lo requiere leer y escribir de la memoria, se trata de un sistema muy sencillo y fÃ¡cil de utilizar.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como ocurre con las tuberÃ­as (vÃ©ase el <a href="#_tuberÃ­as">Apartado 10.5.3</a>) la memoria compartida puede ser anÃ³nima o con nombre.</p>
</div>
<div class="sect2">
<h3 id="_memoria_compartida_anÃ³nima">11.1. Memoria compartida anÃ³nima</h3>
<div class="paragraph">
<p>La <strong>memoria compartida anÃ³nima</strong> solo existe para el proceso que la crea y para sus procesos hijos, que heredan el acceso.
Es por tanto, una forma eficiente de comunicar procesos padres e hijos.</p>
</div>
<div class="paragraph">
<p>En lo sistemas POSIX, las funciones y operadores de reserva de memoria como <a href="https://en.cppreference.com/w/c/memory/malloc">malloc()</a> y <a href="https://en.cppreference.com/w/cpp/language/new">new</a>, utilizan internamente la llamada al sistema <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>.
Esta funciÃ³n se puede llamar de la siguiente manera para reservar <code>length</code> bytes de memoria.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>     <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>      <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">0</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Si todo va bien, <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> devuelve un puntero al primer byte de la memoria reservada.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Cantidad de memoria a reservar en bytes.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Permisos de acceso para la memoria reservada.
En este caso, se solicita permitir la lectura y la escritura de la memoria.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>MAP_ANONYMOUS</code> indica que la memoria no estÃ¡ respaldada por ningÃºn archivo, por lo que su contenido inicial serÃ¡ cero.
Mientras que <code>MAP_PRIVATE</code> establece que la regiÃ³n de memoria es privada.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Lo interesante es que si se cambia <code>MAP_PRIVATE</code> por <code>MAP_SHARED</code> la regiÃ³n de memoria reservada es memoria compartida:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>
    <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
    <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">0</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Memoria anÃ³nima y compartida.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Es decir, que al crear un hijo con <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork()</a> este tendrÃ¡ una copia de toda la memoria del proceso padre, excepto esta regiÃ³n en particular, que serÃ¡ la misma que la del padre.
Por lo tanto, escribiendo y leyendo en esa regiÃ³n, ambos procesos pueden comunicarse.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap11/anom-shared-memory.cpp">anom-shared-memory.cpp</a> se puede ver un ejemplo muy simple, similar a {forkpipe_cpp} pero utilizando memoria compartida para comunicar ambos procesos.
Como se puede apreciar, la versiÃ³n que usa memoria compartida es bastante mÃ¡s sencilla que la que utiliza tuberÃ­as.</p>
</div>
<div class="paragraph">
<p>En Microsoft Windows se puede hacer algo similar con <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">HANDLE</span> <span class="n">hMapFile</span> <span class="o">=</span> <span class="n">CreateFileMapping</span><span class="p">(</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="n">INVALID_HANDLE_VALUE</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">PAGE_READWRITE</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="mi">0</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>         <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="nb">NULL</span>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Permisos de acceso para la memoria reservada.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Cantidad de memoria a reservar en bytes.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A diferencia de <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>, <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a> crea un objeto de memoria compartida pero no hace visible esa memoria para nuestro proceso.
Para eso hay que llamar a <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile()</a> pasÃ¡ndole el manejador <code>hMapFile</code> devuelto por <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a>.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_memoria_compartida_con_nombre">11.2. Memoria compartida con nombre</h3>
<div class="paragraph">
<p>La <strong>memoria compartida con nombre</strong> es pÃºblica para el resto del sistema, por lo que teÃ³ricamente cualquier proceso con permisos puede acceder a ella para comunicarse con otros procesos.</p>
</div>
<div class="paragraph">
<p>Como ocurre en las tuberÃ­as con nombre, los <strong>objetos de memoria compartida con nombre</strong> hay que crearlos antes de comenzar a utilizarlos.
Para eso los sistemas POSIX ofrecen la funciÃ³n <a href="https://www.man7.org/linux/man-pages/man3/shm_open.3.html">shm_open()</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">shmfd</span> <span class="o">=</span> <span class="n">shm_open</span><span class="p">(</span>   <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="s">"/foo-shm"</span><span class="p">,</span>         <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">,</span>   <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="mi">666</span>                 <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre que identifica al objeto de memoria compartida.
Como ocurre con los archivos, varios procesos pueden acceder al mismo objeto indicando el mismo nombre.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Valores que indican diferentes opciones a la hora de abrir el objeto.
Por ejemplo, usando <code>O_RDWR</code> indicamos que se abra para lectura y escritura.
Mientras que con <code>O_CREAT</code> se indica que el objeto debe crearse si no existÃ­a previamente.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Indica los permisos del objeto de memoria compartida al crearlo nuevo, de forma similar a los permisos que se aplican a los archivos en el sistema de archivos.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El valor devuelto por <a href="https://www.man7.org/linux/man-pages/man3/shm_open.3.html">shm_open()</a> es el descriptor del objeto de memoria compartida, que utilizaremos posteriormente con <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a> al reservar una regiÃ³n de la memoria de nuestro proceso donde ese objeto de memoria compartida serÃ¡ visible:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>                 <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
    <span class="n">MAP_SHARED</span><span class="p">,</span>             <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">shmfd</span><span class="p">,</span>                  <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="mi">0</span>                       <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Al pasar el descriptor del objeto de memoria compartida, ya no se puede indicar <code>MAP_ANONYMOUS</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Se puede hacer visible para el proceso todo el objeto de memoria compartida o solo una parte.
Para esto Ãºltimo se indica el tamaÃ±o de la regiÃ³n y el desplazamiento dentro del objeto, que es el Ãºltimo argumento de <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Un objeto de memoria compartida reciÃ©n creado tiene tamaÃ±o 0.
Para redimensionarlo se utiliza <a href="https://linux.die.net/man/2/ftruncate">ftruncate()</a>, que lo que necesita es el descriptor del objeto y el nuevo tamaÃ±o.</p>
</div>
<div class="paragraph">
<p>En <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap11/shared-memory-server.c">shared-memory-server.c</a> y <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap11/shared-memory-client.cpp">shared-memory-client.cpp</a> se puede ver el ejemplo de un programa que muestra periÃ³dicamente la hora del sistema.
En este caso controlado por otro mediante memoria compartida.
Ambos programas usan la clase definida en <a href="https://github.com/ull-esit-sistemas-operativos/ssoo-ejemplos/blob/master/src/cap11/shared_memory.hpp">shared_memory.hpp</a> para gestionar el objeto de memoria compartida.
Sus mÃ©todos muestran de forma prÃ¡ctica cÃ³mo utilizar las llamadas al sistema comentadas.</p>
</div>
<div class="paragraph">
<p>En Microsoft Windows tambiÃ©n se utiliza <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping()</a> para crear el objeto de memoria compartida con nombre.
Simplemente hay que indicar el nombre en el Ãºltimo argumento de la funciÃ³n.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">HANDLE</span> <span class="n">hMapFile</span> <span class="o">=</span> <span class="n">CreateFileMapping</span><span class="p">(</span>
    <span class="n">INVALID_HANDLE_VALUE</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">PAGE_READWRITE</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="n">length</span><span class="p">,</span>
    <span class="s">"Global</span><span class="se">\\</span><span class="s">FooMemoriaCompartida"</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre del nuevo objeto de memoria compartida.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hilos">12. Hilos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hasta el momento el modelo de proceso que hemos descrito asume que tenemos un sÃ³lo <strong>hilo</strong> de ejecuciÃ³n, es decir, que se ejecuta en la CPU una Ãºnica secuencia de instrucciones.
Un proceso con un hilo de ejecuciÃ³n sÃ³lo puede realizar una tarea a la vez.
Por ejemplo, en un procesador de textos con un sÃ³lo hilo de ejecuciÃ³n el usuario nunca podrÃ­a escribir al mismo tiempo que se comprueba la ortografÃ­a.
Por eso muchos sistemas operativos modernos han extendido el concepto de proceso para permitir mÃºltiples hilos de ejecuciÃ³n en cada uno.
Los procesos con varios hilos pueden realizar varias tareas a la vez.</p>
</div>
<div class="sect2">
<h3 id="_introducciÃ³n_2">12.1. IntroducciÃ³n</h3>
<div class="paragraph">
<p><em>El hilo es la unidad bÃ¡sica de uso de la CPU en los sistemas operativos multihilo</em>.
De los recursos de un proceso es privado a cada hilo (vÃ©ase la ):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>El identificador del hilo</strong> lo identifica en el sistema de la misma manera que lo hace el identificador de proceso con el proceso.</p>
</li>
<li>
<p><strong>El contador de programa</strong> indica la direcciÃ³n de la prÃ³xima instrucciÃ³n del proceso que debe ser ejecutada por la CPU.</p>
</li>
<li>
<p><strong>Los registros de la CPU</strong>.</p>
</li>
<li>
<p><strong>La pila</strong> contiene datos temporales como parÃ¡metros y direcciones de retorno de las funciones y variables locales.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sin embargo todos los hilos de un mismo proceso comparten (vÃ©ase la ):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>El cÃ³digo del programa</strong>.</p>
</li>
<li>
<p><strong>Otras secciones de datos</strong>, como el montÃ³n.</p>
</li>
<li>
<p>Y <strong>otros recursos del proceso</strong> como archivos abiertos y seÃ±ales.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_beneficios">12.1.1. Beneficios</h4>
<div class="paragraph">
<p>Muchos son los beneficios que aporta la programaciÃ³n multihilo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Respuesta</strong>.
Una aplicaciÃ³n multihilo interactiva puede continuar ejecutÃ¡ndose aunque parte de la misma estÃ© bloqueada o realizando una operaciÃ³n lenta, mejorando la <em>respuesta al usuario</em> de la misma.
Por ejemplo, un navegador Web multihilo puede gestionar la interacciÃ³n del usuario a travÃ©s de un hilo mientras el contenido solicitado se descarga en otro hilo.</p>
</li>
<li>
<p><strong>ComparticiÃ³n de recursos</strong>.
Por defecto los hilos comparten la memoria y los recursos del proceso al que pertenecen.
El compartir el cÃ³digo es lo que permite a una aplicaciÃ³n tener varios hilos que realizan diferentes actividades dentro del mismo espacio de direcciones.</p>
</li>
<li>
<p><strong>EconomÃ­a</strong>.
Reservar memoria y otros recursos para la creaciÃ³n de un proceso es costoso.
Puesto que los hilos comparten los recursos de los procesos a los que pertenecen es mÃ¡s econÃ³mico crearlos.
TambiÃ©n es mÃ¡s econÃ³mico el cambio de contexto entre ellos ya que hay que guardar y recuperar menos informaciÃ³n.
Por ejemplo en Oracle/Sun Microsystems Solaris crear un proceso es 30 veces mÃ¡s lento que crear un hilo; y el cambio de contexto es 5 veces mÃ¡s lento.</p>
</li>
</ul>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Aprovechamiento de las arquitecturas multiprocesador</strong>.
En esas arquitecturas diferentes hilos pueden ejecutarse en paralelo en distintos procesadores.
Por el contrario un proceso monohilo sÃ³lo se puede ejecutar en una CPU a la vez, independientemente de cuantas estÃ©n disponibles para ejecutarlo.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_soporte_multihilo">12.1.2. Soporte multihilo</h4>
<div class="paragraph">
<p><em>Las <strong>librerÃ­as de hilos</strong> proporcionan al programador la API para crear y gestionar los hilos de su proceso</em>.
Hay dos formas fundamentales de implementar una librerÃ­a de hilos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La primera forma es <em>implementar la librerÃ­a enteramente en el espacio de usuario, sin requerir el soporte del nÃºcleo</em>:</p>
<div class="ulist">
<ul>
<li>
<p>Los hilos asÃ­ gestionados no existen para el nÃºcleo.
SÃ³lo existen en el espacio de usuario dentro del proceso que los ha creado.
Por ese motivo se los denomina <strong>hilos de usuario</strong>.</p>
</li>
<li>
<p>El cÃ³digo y los datos de la librerÃ­a residen en el espacio de usuario, por lo que invocar una funciÃ³n de la misma se reduce a una simple llamada a una funciÃ³n, evitando el coste de hacer llamadas al sistema.</p>
</li>
</ul>
</div>
</li>
<li>
<p>La segunda forma es <em>implementar la librerÃ­a en el nÃºcleo</em>.</p>
<div class="ulist">
<ul>
<li>
<p>Los hilos asÃ­ gestionados son soportados y gestionados por el nÃºcleo, quien se encarga de planificarlos en la CPU.
Por ese motivo se los denomina <strong>hilos de nÃºcleo</strong>.</p>
</li>
<li>
<p>El cÃ³digo y los datos de la librerÃ­a residen en el espacio del nÃºcleo, por lo que invocar una funciÃ³n de la misma requiere frecuentemente hacer una llamada al sistema.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>En la actualidad en los diferentes sistemas operativos se pueden encontrar librerÃ­as de ambos tipos.
Por ejemplo, la librerÃ­a de hilos del API Win32 es del segundo tipo mientras que la librerÃ­a de hilos POSIX Threads âfrecuentemente utilizada en los sistemas POSIXâ puede ser de ambos tipos, dependiendo solamente del sistema donde se implemente<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_modelos_multihilo">12.2. Modelos multihilo</h3>
<div class="paragraph">
<p>Las distintas formas de implementar los hilos comentadas anteriormente âen espacio de usuario o en el nÃºcleoâ no son excluyentes ya que en un sistema operativo concreto se pueden implementar ambas, una de las dos o ninguna âesto Ãºltimo en el caso de los sistemas operativos que no soportan de ninguna forma mÃºltiples hilos de ejecuciÃ³nâ.
AsÃ­ que en general debe existir una relaciÃ³n entre los hilos de usuario y los del nÃºcleo.
A continuaciÃ³n veremos tres formas de establecer dicha relaciÃ³n.</p>
</div>
<div class="sect3">
<h4 id="_muchos_a_uno">12.2.1. Muchos a uno</h4>
<div class="paragraph">
<p><em>En un sistema operativo cuyo nÃºcleo no soporta mÃºltiples hilos de ejecuciÃ³n la Ãºnica posibilidad es utilizar una librerÃ­a de hilos implementada en el espacio de usuario.
El planificador de dicha librerÃ­a se encarga de determinar que hilo de usuario se ejecuta en cada momento en el proceso, mientras este es planificado en la CPU por el nÃºcleo, obviamente elegido cuando le corresponda de entre todos los procesos del sistema.</em></p>
</div>
<div class="paragraph">
<p>A efectos prÃ¡cticos un proceso Â«sin hilosÂ» se puede interpretar como un proceso con Â«un Ãºnico hiloÂ» de ejecuciÃ³n en el nÃºcleo.
Por eso se dice que <em>en el modelo <strong>muchos a uno</strong> se mapean los mÃºltiples hilos de usuario de un proceso en el Ãºnico hilo de nÃºcleo del mismo</em> (vÃ©ase la ).</p>
</div>
<div class="paragraph">
<p>Las principales caracterÃ­sticas de este modelo son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>La gestiÃ³n de hilos se hace con una librerÃ­a en el espacio de usuario</em>, por lo que puede ser muy eficiente.
Como hemos visto anteriormente la invocaciÃ³n de las funciones de la librerÃ­a se hace por medio de simples llamadas a funciones.</p>
</li>
<li>
<p><em>El proceso entero se bloquea si un hilo hace una llamada al sistema que deba ser bloqueada</em>.
Por ejemplo operaciones de E/S a archivos, esperar a que suceda un evento, etc.</p>
</li>
<li>
<p>Como sÃ³lo un hilo de usuario puede ser asignado al hilo de nÃºcleo, <em>los hilos de un mismo proceso no se pueden ejecutar en paralelo en sistemas multiprocesador</em>.
El planificador de la librerÃ­a de hilos es el encargado de determinar que hilo de usuario es asignado al Ãºnico hilo de nÃºcleo del proceso y este sÃ³lo puede ejecutarse en una Ãºnica CPU al mismo tiempo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El problema del bloqueo de procesos puede ser evitado sustituyendo las funciones de la librerÃ­a del sistema, de manera que las llamadas al sistema que se pueden bloquear sean sustituidas por versiones con llamadas equivalentes pero no bloqueantes.
Por ejemplo, las llamadas al sistema de E/S se pueden reemplazar por llamadas de E/S asÃ­ncrona, que retornan inmediatamente aunque la operaciÃ³n no haya sido completada.
DespuÃ©s de cada una de estas llamadas asÃ­ncronas al sistema, la librerÃ­a del sistema invoca al planificador de la librerÃ­a de hilos para que bloquee el hilo que ha realizado la llamada y asigne el hilo de nÃºcleo a un nuevo hilo de usuario.
Obviamente el planificador de la librerÃ­a de hilos debe estar al tanto de cuando las operaciones asÃ­ncronas son completadas para poder volver a planificar los hilos de usuario bloqueados.
Este procedimiento es a todas luces bastante complejo y requiere versiones no bloqueantes de todas las llamadas al sistema, asÃ­ como modificar las funciones bloqueantes de la librerÃ­a del sistema para implementar el comportamiento descrito.</p>
</div>
<div class="paragraph">
<p>Ejemplos de implementaciones este modelo de hilos son la Green Threads, una de las implementaciones de hilos para Solaris y Java, Stackless Python<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup> y GNU Portable Threads<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>.
Estas implementaciones son muy Ãºtiles en los sistemas monohilo, de cara a poder ofrecer cierto soporte de hilos a las aplicaciones, pero tambiÃ©n en los sistemas multihilo, ya que debido a su bajo coste en recursos y a su alta eficiencia son ideales cuando la cantidad de hilos a crear âel nivel de concurrenciaâ va a ser previsiblemente muy alta .</p>
</div>
</div>
<div class="sect3">
<h4 id="_uno_a_uno">12.2.2. Uno a uno</h4>
<div class="paragraph">
<p><em>Si el nÃºcleo del sistema operativo soporta hilos de ejecuciÃ³n, lo mÃ¡s comÃºn es que estos sean visibles directamente en el espacio de usuario.
Por lo tanto se dice que _en el modelo <strong>uno a uno</strong> se mapea cada hilo de usuario en exactamente un hilo de nÃºcleo</em> (vÃ©ase la ).</p>
</div>
<div class="paragraph">
<p>Las principales caracterÃ­sticas de este modelo son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Permite a otro hilo del mismo proceso ejecutarse aun cuando un hilo hace una llamada al sistema que debe bloquearse</em>, ya que el nÃºcleo se encarga de ponerlo en espera y planificar en la CPU a otro de los hilos preparados para ejecutarse de entre todos los existentes en el sistema.</p>
</li>
<li>
<p><em>Permite paralelismo en sistemas multiprocesador</em>, ya que diferentes hilos pueden ser planificados por el nÃºcleo en distintos procesadores.</p>
</li>
<li>
<p>Crear un hilo de usuario requiere crear el correspondiente hilo de nÃºcleo.
Debido a que la cantidad de memoria disponible para el nÃºcleo suele estar limitada, <em>muchos sistemas restringen la cantidad mÃ¡xima de hilos soportados</em>.</p>
</li>
<li>
<p><em>Las gestiÃ³n de los hilos se hace con una librerÃ­a en el espacio de nÃºcleo</em>, lo que requiere utilizar llamadas al sistema.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este modelo se utilizar en la mayor parte de los sistemas operativos multihilo modernos.
Linux, Microsoft Windows 95/98/NT/2000/XP y superiores, y Solaris 9 y superiores, son ejemplos de sistemas operativos que los utilizan.</p>
</div>
</div>
<div class="sect3">
<h4 id="_muchos_a_muchos">12.2.3. Muchos a muchos</h4>
<div class="paragraph">
<p><em>En teorÃ­a deberÃ­a ser posible aprovechar lo mejor de los dos modelos anteriores.
Por eso _en el modelo <strong>muchos a muchos</strong> se mapean los hilos de usuario en un menor o igual nÃºmero de hilos de nÃºcleo del proceso</em> (vÃ©ase la ).
AsÃ­ los desarrolladores pueden utilizar la librerÃ­a de hilos en el espacio de usuario para crear tantos hilos como quieran.
El planificador de la librerÃ­a de hilos se encarga de determinar que hilo de usuario es asignado a que hilo de nÃºcleo.
Mientras que el planificador de la CPU asigna la CPU a alguno de los hilos de nÃºcleo del sistema.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Los hilos de nÃºcleo pueden ser ejecutados en paralelo en sistemas multiprocesador</em>.</p>
</li>
<li>
<p><em>Permite a otro hilo del mismo proceso ejecutarse cuando un hilo hace una llamada al sistema que debe ser bloqueada</em>, puesto que si un hilo de usuario realiza una llamada al sistema que debe ser bloqueada, el correspondiente hilo de nÃºcleo quedarÃ¡ bloqueado.
Sin embargo, el resto de los hilos de usuario pueden seguir ejecutÃ¡ndose en los otros hilos de nÃºcleo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Existe una variaciÃ³n del modelo muchos a muchos donde, ademÃ¡s de hacer lo comentado anteriormente, se permite que un hilo de usuario quede ligado a un Ãºnico hilo de nÃºcleo.
Esta variaciÃ³n se denomina en ocasiones modelo de <strong>dos niveles</strong> (vÃ©ase la ) y es soportada en sistemas operativos como Solaris 8 y anteriores, IRIX, HPUX y Tru64 UNIX.</p>
</div>
<div class="paragraph">
<p>Tanto en el modelo <em>muchos a muchos</em> como en el de <em>dos niveles</em> es necesario cierto grado de coordinaciÃ³n entre el nÃºcleo y la librerÃ­a de hilos del espacio de usuario.
Dicha comunicaciÃ³n tiene como objetivo ajustar dinÃ¡micamente el nÃºmero de hilos del nÃºcleo para garantizar la mÃ¡xima eficiencia.
Uno de los esquemas de comunicaciÃ³n se denomina <strong>activaciÃ³n del planificador</strong> y consiste en que el nÃºcleo informa a la librerÃ­a de hilos en espacio de usuario del bloqueo de un hilo de un proceso.
Antes de dicha notificaciÃ³n el nÃºcleo se encarga de crear un nuevo hilo de nÃºcleo en el proceso, de manera que el planificador de la librerÃ­a pueda encargarse de asignarle alguno de los otros hilos de usuario.
AsÃ­ es como se ajusta el nÃºmero de hilos dinÃ¡micamente de manera que el proceso nunca quede bloqueado.</p>
</div>
<div class="paragraph">
<p>Debido a la complejidad del mecanismo descrito anteriormente y a la dificultad de coordinar el planificador de la librarÃ­a de hilos con el de la CPU para obtener un rendimiento Ã³ptimo, sistemas como Linux y Solaris âa partir de la versiÃ³n 9â han optado por el modelo uno a uno.
Con el objetivo de evitar las penalizaciones de dicho modelo, los desarrolladores de Linux han preferido concentrar sus esfuerzos en conseguir un planificador de CPU mÃ¡s eficiente, asÃ­ como en reducir los costes de la creaciÃ³n de hilos de nÃºcleo.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_otras_consideraciones_sobre_los_hilos">12.3. Otras consideraciones sobre los hilos</h3>
<div class="sect3">
<h4 id="_datos_especÃ­ficos_de_hilo">12.3.1. Datos especÃ­ficos de hilo</h4>
<div class="paragraph">
<p>Los hilos de un mismo proceso comparten los datos del mismo, siendo este uno de los principales beneficios de la programaciÃ³n multihilo.
Por ejemplo todas las variables globales del programa son compartidas por todos los hilos.
Sin embargo en algunas ocasiones puede interesar definir ciertos datos como privados a cada hilo.
A esos datos se los denomina <strong>TSD</strong> o <em>thread-specific data</em> y son soportados por muchas librerÃ­as de hilos, incluyendo el API Win32 y Pthreads, aunque no es comÃºn que sean soportados directamente por los distintos lenguajes de programaciÃ³n.</p>
</div>
</div>
<div class="sect3">
<h4 id="_cancelaciÃ³n_de_hilos">12.3.2. CancelaciÃ³n de hilos</h4>
<div class="paragraph">
<p><em>La <strong>cancelaciÃ³n</strong> es la operaciÃ³n de terminar un hilo antes de que termine su trabajo</em>.
Por ejemplo, en un navegador web un hilo se puede encargar de la interfaz de usuario mientras otros hilos se encargan de descargar las pÃ¡ginas y las imÃ¡genes de la misma.
Si el usuario pulsa el botÃ³n <em>cancelar</em> es necesario que todos los hilos que intervienen en la descarga sean cancelados.
Esto puede ocurrir de dos maneras:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>En la <strong>cancelaciÃ³n asÃ­ncrona</strong> un hilo puede terminar inmediatamente la ejecuciÃ³n de otro</em>.
Esto puede causar problemas al no liberarse los recursos reservados al proceso por parte del hilo âno se cierran los archivos abiertos, no se libera la memoria, etc.â.
AdemÃ¡s si el hilo que termina estaba modificando estructuras de datos que compartÃ­a con otros hilos, estas podrÃ­an quedar inconsistentes.</p>
</li>
<li>
<p><em>En la <strong>cancelaciÃ³n en diferido</strong> el hilo comprueba periÃ³dicamente cuando debe terminar</em>.
Esto da al hilo una oportunidad de terminarse asÃ­ mismo de forma ordenada y en un punto dÃ³nde es seguro hacerlo.
En la terminologÃ­a de Pthreads a estos puntos se los denomina <strong>puntos de cancelaciÃ³n</strong> âo <em>cancellation points</em>â y muchas llamadas al sistema lo son por si mismas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_funciones_reentrantes_y_seguras_en_hilos">12.3.3. Funciones reentrantes y seguras en hilos</h4>
<div class="paragraph">
<p>A la hora de utilizar una librerÃ­a en un programa multihilo es necesario que tengamos en cuenta los conceptos de reentrante y de seguridad de hilos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Una funciÃ³n<sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup> es <strong>reentrante</strong> si puede ser interrumpida en medio de su ejecuciÃ³n y mientras espera puede volver a ser llamada con total seguridad</em>.
Obviamente las funciones recursivas deben ser reentrantes para poder llamarse a sÃ­ mismas una y otra vez con total seguridad.
+ En el contexto de la programaciÃ³n multihilo ocurre una reentrada cuando, durante la ejecuciÃ³n de una funciÃ³n por parte de un hilo, este es interrumpido por el sistema operativo para planificar posteriormente a otro del mismo proceso que invoca la misma funciÃ³n.
En general una funciÃ³n es reentrante si:</p>
<div class="ulist">
<ul>
<li>
<p>No modifica variables estÃ¡ticas o globales.
Si lo hiciera sÃ³lo puede hacerlo mediante operaciones <em>leer-modificar-escribir</em> que sean ininterrumpibles âes decir, atÃ³micasâ.</p>
</li>
<li>
<p>No modifica su propio cÃ³digo y no llama a otras funciones que no sean reentrantes.</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>Una funciÃ³n es <strong>segura en hilos</strong> o <strong>thread-safe</strong> si al manipular estructuras compartidas de datos lo hace de tal manera que se garantiza la ejecuciÃ³n segura de la misma por mÃºltiples hilos al mismo tiempo</em>.
Obviamente estamos hablando de un problema de secciones crÃ­ticas, por lo que se resuelven sincronizando el acceso a estos datos mediante el uso de semÃ¡foros, <em>mutex</em> u otros recursos similares ofrecidos por el sistema operativo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En ocasiones ambos conceptos se confunden porque es bastante comÃºn que el cÃ³digo reentrante tambiÃ©n sea seguro en hilos.
Sin embargo es posible crear cÃ³digo reentrante que no sea seguro en hilos y viceversa.
Por ejemplo, una funciÃ³n que manipule <em>datos especÃ­ficos de hilo</em> seguramente no serÃ¡ reentrante aunque si segura en hilos.
Mientras que una funciÃ³n que sÃ³lo utilice variables locales y que no invoque a otras funciones seguramente serÃ¡ reentrante y segura en hilos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_las_llamadas_al_sistema_fork_y_exec_en_procesos_multihilo">12.3.4. Las llamadas al sistema fork() y exec() en procesos multihilo</h4>
<div class="paragraph">
<p>Â¿QuÃ© debe ocurrir si un hilo de un proceso multihilo ejecuta la llamada <code>fork()</code>?:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Â¿El nuevo proceso debe duplicar todos los hilos?.</p>
</li>
<li>
<p>Â¿O el nuevo proceso debe tener un Ãºnico hilo copia del que invocÃ³ a <code>fork()</code>?.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como hemos comentado anteriormente la llamada al sistema <code>exec()</code> sustituye el programa en ejecuciÃ³n con el programa indicado y este inicia su ejecuciÃ³n en <code>main()</code>.
Esto incluye liberar toda la memoria reservada y la destrucciÃ³n de todos los hilos del programa original, por lo que duplicar los hilos en el proceso hijo creado por <code>fork()</code> parece algo innecesario.</p>
</div>
<div class="paragraph">
<p>El estÃ¡ndar POSIX establece que si se utiliza <code>fork()</code> en un programa multihilo, el nuevo proceso debe ser creado con un sÃ³lo hilo, que serÃ¡ una rÃ©plica del que hizo la llamada, asÃ­ como un duplicado completo del espacio de direcciones del proceso.
Sin embargo algunos sistemas UNIX tienen una segunda llamada no estÃ¡ndar, denominada <code>forkall()</code>, capaz de duplicar todos los hilos del proceso padre.
Obviamente sÃ³lo resulta conveniente emplearla si no se va a utilizar la llamada <code>exec()</code> a continuaciÃ³n.</p>
</div>
</div>
<div class="sect3">
<h4 id="_manejo_de_seÃ±ales_en_procesos_multihilo">12.3.5. Manejo de seÃ±ales en procesos multihilo</h4>
<div class="paragraph">
<p>Una seÃ±al se utiliza en UNIX para informar a un proceso cuando un evento a ocurrido.
Existen dos tipos de seÃ±ales:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Las <em><strong>seÃ±ales sÃ­ncronas</strong> se deben a alguna acciÃ³n del propio proceso</em>.
Ejemplos de seÃ±ales de este tipo son las originadas por accesos ilegales a memoria o divisiones por 0.
Las seÃ±ales sÃ­ncronas son enviadas al mismo proceso que las origina.</p>
</li>
<li>
<p>Las <em><strong>seÃ±ales asÃ­ncronas</strong> son debidas a procesos externos</em>.
Un ejemplo de este tipo de seÃ±ales es la terminaciÃ³n de procesos con teclas especiales como <span class="keyseq"><kbd>CTRL</kbd>+<kbd>C</kbd></span> o <kbd>CTRL-D</kbd></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Las seÃ±ales que llegan a un proceso pueden ser interceptadas por una funciÃ³n definida por el programador âque se denominada <em>manejador de seÃ±al</em>-.
En caso de que esta funciÃ³n no haya sido definido, se utiliza un manejador por defecto cuya acciÃ³n depende del tipo de evento.</p>
</div>
<div class="paragraph">
<p>La pregunta entonces es: Â¿cuÃ¡ndo se tienen mÃºltiples hilos cuÃ¡l de ellos debe ser interrumpido para que ejecute el manejador de seÃ±ales?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Obviamente las seÃ±ales sÃ­ncronas, por su propia naturaleza, deben ser enviadas al hilo que las genera.</p>
</li>
<li>
<p>Con las seÃ±ales asÃ­ncronas âlas que vienen de fuentes externasâ la cosa no estÃ¡ tan clara.
Dependiendo del caso algunas deben ser capturadas por un sÃ³lo hilo, mientras que otras âcomo aquellas que ordenan terminar el procesoâ deberÃ­an ser enviadas a todos para que sepan lo que va a ocurrir.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La mayor parte de los UNIX multihilo permiten especificar quÃ© seÃ±ales acepta cada hilo y cuÃ¡les no.
Por lo tanto una seÃ±al asÃ­ncrona sÃ³lo serÃ¡ entregada a aquellos hilos que no la bloquean.
Puesto que generalmente las seÃ±ales necesitan ser manejadas una sola vez, normalmente sÃ³lo llegan al primer hilo al que se le asigna la CPU y que no las estÃ© bloqueando.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sincronizaciÃ³n">13. SincronizaciÃ³n</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hemos comentado anteriormente que los hilos comparten el espacio de direcciones del proceso al que pertenecen.
Al mismo tiempo distintos procesos pueden compartir regiones de la memoria con el objeto de cooperar en las tareas que deben desempeÃ±ar.
Ambas posibilidades introducen algunos riesgos, puesto que el acceso concurrente a los datos compartidos puede ocasionar inconsistencias.
En este apartado vamos a discutir <em>cÃ³mo se puede asegurar la ejecuciÃ³n ordenada de hilos o procesos cooperativos que comparten regiones de la memoria, con el fin de mantener la consistencia de los datos</em>.</p>
</div>
<div class="sect2">
<h3 id="_el_problema_de_las_secciones_crÃ­ticas">13.1. El problema de las secciones crÃ­ticas</h3>
<div class="paragraph">
<p><em>Llamamos <strong>condiciÃ³n de carrera</strong> a la situaciÃ³n donde varios procesos o hilos pueden acceder y manipular los mismos datos concurrentemente, y donde el resultado de la ejecuciÃ³n depende del orden particular en el que tienen lugar dichos accesos</em>.
Estas situaciones ocurren frecuentemente en los sistemas operativos puesto que diferentes componentes del mismo manipulan los mismos recursos interfiriendo unos con otros.</p>
</div>
<div class="paragraph">
<p>Para ilustrarlo, supongamos que dos hilos comparten una regiÃ³n de la memoria que contiene un vector de elementos y un contador con el nÃºmero de elementos del vector:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El primer hilo realiza varias tareas que no entraremos a describir.
Sin embargo, como resultado de esas tareas en ocasiones aÃ±ade un elemento al vector e incrementa el contador que indica el nÃºmero de elementos en el vector.
Es decir, el primer hilo actÃºa como un <strong>productor</strong> de elementos del vector.
A continuaciÃ³n mostramos una porciÃ³n de la funciÃ³n del productor:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">VECTOR_SIZE</span><span class="p">);</span>

<span class="c1">// aÃ±adir un elemento al vector</span>
<span class="n">vector</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
<span class="o">++</span><span class="n">count</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>El segundo hilo tambiÃ©n realiza varias tareas que no describiremos.
Pero para realizar esas tareas en ocasiones debe tomar un elemento del vector compartido y decrementar el contador, porque ahora habrÃ¡ un elemento menos en el vector.
Es decir, el segundo hilo actÃºa como un <strong>consumidor</strong> de elementos del vector.
A continuaciÃ³n mostramos una porciÃ³n de la funciÃ³n del consumidor:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// quitar un elemento del vector</span>
<span class="o">--</span><span class="n">count</span><span class="p">;</span>
<span class="n">item</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="n">count</span><span class="p">];</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Aunque las funciones del productor y del consumidor son correctas cuando no coinciden en el tiempo, no funcionan adecuadamente cuando si lo hacen.
El motivo es que los distintos hilos comparten la variable <code>count</code> y las sentencias <code>count` y `--count` no tiene porque tener una instrucciÃ³n en lenguaje mÃ¡quina equivalente.
Por ejemplo, `count</code> podrÃ­a ser traducida de la siguiente manera por el compilador:</p>
</div>
<div class="listingblock">
<div class="title">++count</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">registro1</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
<span class="n">registro1</span> <span class="o">=</span> <span class="n">registro1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">registro1</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Donde <code>registro1</code> representa un registro de la CPU.
De forma parecida la sentencia <code>--count</code> puede ser implementada de la siguiente manera:</p>
</div>
<div class="listingblock">
<div class="title">--count</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">registro2</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
<span class="n">registro2</span> <span class="o">=</span> <span class="n">registro2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">registro2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Donde nuevamente <code>registro2</code> representa un registro de la CPU.
Realmente, aunque <code>registro1</code> y <code>registro2</code> pueden ser el mismo registro fÃ­sico, el contenido de los registros se guarda y se recupera durante los cambios de contexto de un hilo al otro, por lo que cada uno ve sus propios valores y no los del otro.</p>
</div>
<div class="paragraph">
<p>La ejecuciÃ³n concurrente de las sentencias <code>++count</code> y <code>--count</code> es similar a la ejecuciÃ³n secuencial, pero las instrucciones de lenguaje mÃ¡quina de ambas sentencias en ambos hilos o procesos pueden ser entrelazadas en algÃºn orden aleatorio.
No olvidemos que la ejecuciÃ³n concurrente se puede dar bien porque:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tenemos un sistema multiprocesador, donde ambos hilos se ejecutan a la vez en procesadores diferentes.</p>
</li>
<li>
<p>O bien porque tenemos un sistema monoprocesador, donde uno de los hilos puede ser interrumpido por el sistema operativo en cualquier momento (vÃ©ase el <a href="#_planificaciÃ³n_expropiativa">Apartado 14.1</a>) para asignar la CPU al otro.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Un posible entrelazado de las instrucciones en lenguaje mÃ¡quina entre hilos, suponiendo que inicialmente <code>count = 5</code>, podrÃ­a ser el siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="c1">// Entra ++count</span>
<span class="n">registro1</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>          <span class="c1">// registro1 = 5</span>
<span class="n">registro1</span> <span class="o">=</span> <span class="n">registro1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// registro1 = 6</span>
<span class="c1">// Sale ++count y entra --count</span>
<span class="n">registro2</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>          <span class="c1">// registro2 = 5</span>
<span class="n">registro2</span> <span class="o">=</span> <span class="n">registro2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// registro2 = 4</span>
<span class="c1">// Sale --count y entra ++count</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">registro1</span><span class="p">;</span>          <span class="c1">// count = 6 </span><i class="conum" data-value="2"></i><b>(2)</b>
<span class="c1">// Entra --count</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">registro2</span><span class="p">;</span>          <span class="c1">// count = 4 </span><i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Llegamos al resultado incorrecto <code>count = 4</code>, indicando que hay 4 elementos en el vector cuando realmente hay 5.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Si invertimos el orden de las sentencias obtendrÃ­amos el resultado, tambiÃ©n incorrecto, <code>count = 6</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como se puede apreciar, hemos llegado a estos valores incorrectos porque hemos permitido la manipulaciÃ³n concurrente de la variable <code>count</code>.
SegÃºn como se entrelacen las instrucciones de <code>++count</code> y <code>--count</code> en la CPU, el resultado final podrÃ­a ser: 4, 5 o 6.
Pero el Ãºnico resultado correcto es 5, que es el que obtendrÃ­amos si ejecutamos las sentencias secuencialmente.</p>
</div>
<div class="paragraph">
<p>Para evitar que estas situaciones lleven a la corrupciÃ³n de los datos y a caÃ­das de servicios y sistemas debemos asegurarnos que sÃ³lo un hilo en cada momento puede manipular recursos y variables compartidas.
Por tanto, necesitamos algÃºn tipo de mecanismo de sincronizaciÃ³n para que mientras se ejecuta <code>++count</code> no se pueda ejecutar <code>--count</code> ni viceversa.</p>
</div>
<div class="paragraph">
<p>Una forma de controlar el acceso a los recursos compartidos es definiendo en nuestro cÃ³digo <em>secciones crÃ­ticas</em>.
Una <strong>secciÃ³n crÃ­tica</strong> es una porciÃ³n del cÃ³digo dÃ³nde se accede a variables, tablas, listas, archivos y otros recursos compartidos que no deben ser accedidos al mismo tiempo por otros hilos de ejecuciÃ³n.
El acceso a las secciones crÃ­ticas es controlado de manera que <em>cuando un hilo se estÃ© ejecutando en una secciÃ³n de este tipo ningÃºn otro pueda hacerlo en la suya correspondiente para manipular los mismos recursos</em>.
En estos casos se dice que la ejecuciÃ³n es <em>mutuamente exclusiva</em> en el tiempo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_semÃ¡foros_mutex_y_spinlocks">13.2. SemÃ¡foros, <em>mutex</em> y <em>spinlocks</em></h3>
<div class="paragraph">
<p>La exclusiÃ³n mutua en las secciones crÃ­ticas se asegura utilizando adecuadamente una serie de recursos que para ese fin proporciona el sistema operativo.
Estos recursos utilizan internamente instrucciones y otras caracterÃ­sticas de la CPU incluidas por los diseÃ±adores para resolver este tipo de problemas.
Ese es el caso de los <em>semÃ¡foros</em>.</p>
</div>
<div class="paragraph">
<p><em>Los <strong>semÃ¡foros</strong> son un tipo de objetos del sistema operativo que nos permite controlar el acceso a una secciÃ³n crÃ­tica</em>, por medio de dos primitivas: <code>wait()</code> y <code>signal()</code> âo <code>acquire()</code> y <code>release()</code>, segÃºn el libro de textoâ.
A continuaciÃ³n describimos el mecanismo de funcionamiento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">semaphore</span> <span class="nf">S</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>    <i class="conum" data-value="1"></i><b>(1)</b>

<span class="n">S</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>            <i class="conum" data-value="2"></i><b>(2)</b>

 <span class="p">...</span>                <i class="conum" data-value="3"></i><b>(3)</b>

<span class="n">S</span><span class="p">.</span><span class="n">signal</span><span class="p">();</span>         <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Crear el semÃ¡foro <code>S</code> inicializado a 10. Un semÃ¡foro contiene fundamentalmente un contador con el nÃºmero mÃ¡ximo de hilos que pueden estar ejecutando el cÃ³digo de la secciÃ³n crÃ­tica al mismo tiempo. Los semÃ¡foros con contadores inicializados a 1 se denominan <strong>mutex</strong> o <strong>semÃ¡foros binarios</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Intentar entrar en la secciÃ³n crÃ­tica:
<div class="ulist">
<ul>
<li>
<p>Si el contador interno del semÃ¡foro es mayor que 0, <code>wait()</code> lo decrementa y retorna para que la ejecuciÃ³n continue.</p>
</li>
<li>
<p>Si el contador interno del semÃ¡foro es igual a 0, <code>wait()</code> saca al hilo de la CPU y lo pone en una cola de espera, suspendiendo asÃ­ su ejecuciÃ³n. BÃ¡sicamente, hay demasiados hilos dentro de la secciÃ³n crÃ­tica.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>CÃ³digo protegido con el semÃ¡foro. AquÃ­ irÃ­a el cÃ³digo de la secciÃ³n crÃ­tica en sÃ­.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Salir de la secciÃ³n crÃ­tica:
<div class="ulist">
<ul>
<li>
<p>Si el contador interno del semÃ¡foro es mayor que 0, <code>signal()</code> lo incrementa y retorna para que la ejecuciÃ³n continue.</p>
</li>
<li>
<p>Si el contador interno del semÃ¡foro es igual a 0, <code>signal()</code> lo incrementa y saca a uno de los hilos en la cola de espera, donde los puso <code>wait()</code>, para meterlo en la cola de preparados, dejÃ¡ndolo listo para entrar en la CPU. Cuando ocurra, ese hilo decrementarÃ¡ el contador interno del semÃ¡foro y saldrÃ¡ de <code>wait()</code>, donde hasta a hora estaba atrapado. Mientras tanto <code>signal()</code> retorna y la ejecuciÃ³n del hilo que sale del secciÃ³n crÃ­tica continua.</p>
</li>
</ul>
</div></td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Para que funcione correctamente, el semÃ¡foro S debe ser el mismo para todos los hilos que tengan secciones crÃ­ticas cuya ejecuciÃ³n deber ser <em>mutuamente exclusiva</em>. Es decir, el semÃ¡foro S debe estar compartido entre los hilos de la misma manera que las estructuras de datos, variables y otros recursos que protege.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como hemos comentado anteriormente la implementaciÃ³n del <code>wait()</code> y el <code>signal()</code> del semÃ¡foro debe realizarse utilizando las caracterÃ­sticas proporcionadas por el hardware, de forma que el incremento, decremento y comparaciÃ³n del contador interno se pueda realizar de forma atÃ³mica<sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup>.</p>
</div>
<div class="paragraph">
<p>Por otro lado existen dos alternativas desde el punto de vista de la forma en la que se implementa la espera de los hilos dentro de <code>wait()</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>El hilo puede cambiar su estado a esperado y moverse a una cola de espera asociada al semÃ¡foro</em>, tal y como explicamos antes.
Entonces el planificador de la CPU escogerÃ¡ a otro proceso para ser ejecutado.</p>
</li>
<li>
<p><em>El hilo puede iterar comprobado constantemente el contador, esperando a que sea incrementado</em>.
Este tipo de <strong>espera ocupada</strong> sÃ³lo se utiliza en el caso de esperas previsiblemente cortas, puesto que se desperdician ciclos de CPU que otro hilo podrÃ­a utilizar de forma mÃ¡s productiva.
Por eso, para evitar que las esperas ocupadas sean demasiado largas, los sistema operativos nunca expulsan de la CPU (vÃ©ase el <a href="#_planificaciÃ³n_expropiativa">Apartado 14.1</a>) a hilos que se estÃ©n ejecutando dentro de secciones crÃ­ticas controladas por semÃ¡foros con este tipo de espera.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A estos semÃ¡foros con <strong>espera ocupada</strong> tambiÃ©n se los denomina <strong>spinlocks</strong>.
Los <strong>spinlocks</strong> son utilizados frecuentemente para proteger las estructuras del nÃºcleo en los sistemas multiprocesador, cuando la tarea a realizar dentro de la secciÃ³n crÃ­tica en el nÃºcleo requiere poco tiempo y es mayor el tiempo de CPU que se pierde si se saca al hilo en espera para ejecutar otro en su lugar.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_planificaciÃ³n_de_la_cpu">14. PlanificaciÃ³n de la CPU</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>El <strong>planificador de la CPU</strong> o <strong>planificador de corto plazo</strong> selecciona de la cola de preparados el siguiente proceso o hilo del nÃºcleo a ejecutar</em>.
En dicha cola suelen estar los PCB de todos los procesos que esperan una oportunidad para usar la CPU.
Aunque se suelen pensar en la cola de preparados como una cola FIFO, como veremos mÃ¡s adelante, no tiene por quÃ© ser asÃ­.
En cualquier caso, sea cual sea el algoritmo de planificaciÃ³n utilizado, Ã©ste no debe ser excesivamente lento ya que es ejecutado con mucha frecuencia; aproximadamente una vez cada 100 milisegundos.</p>
</div>
<div class="paragraph">
<p><strong>Aunque a lo largo de este tema hablaremos de planificar procesos en la CPU, en los sistemas operativos multihilo se planifican los hilos de nÃºcleo y no los procesos</strong>.
Por ello todo lo que comentemos a partir de ahora se aplica de la misma manera a los hilos de nÃºcleo, en aquellos sistemas operativos que los soportan.</p>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n_expropiativa">14.1. PlanificaciÃ³n expropiativa</h3>
<div class="paragraph">
<p>Las decisiones de planificaciÃ³n <em>se deben tomar necesariamente</em> en los siguientes casos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Cuando un proceso pasa de <strong>ejecutando</strong> a <strong>esperando</strong></em>.
Por ejemplo, por solicitar una operaciÃ³n de E/S, esperar a que un hijo termine, etc.</p>
</li>
<li>
<p><em>Cuando un proceso termina</em>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando el planificador es invocado en alguno de los casos anteriores decimos que tenemos un sistema operativo con <strong>planificaciÃ³n cooperativa</strong> o <strong>no expropiativa</strong>.</p>
</div>
<div class="paragraph">
<p>En la planificaciÃ³n cooperativa cuando la CPU es asignada a un proceso, dicho proceso la acapara hasta terminar o pasar al estado de <em>esperando</em>.
La planificaciÃ³n cooperativa no requiere de ningÃºn hardware especial, por lo que en algunas plataformas puede ser la Ãºnica opciÃ³n.
Por ello estaba presente en los sistemas operativos mÃ¡s antiguos, como Microsoft Windows 3.1 y Mac OS.</p>
</div>
<div class="paragraph">
<p>Sin embargo, las decisiones de planificaciÃ³n <em>tambiÃ©n pueden ser tomadas en otros casos</em>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Cuando ocurre una interrupciÃ³n del temporizador</em>.</p>
</li>
<li>
<p><em>Cuando un proceso pasa de <strong>esperando</strong> a <strong>preparado</strong></em>.
Por ejemplo porque para un proceso ha terminado la operaciÃ³n de E/S por la que estaba esperando.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando el planificador es invocado en los cuatro casos decimos que tenemos planificaciÃ³n <strong>expropiativa</strong> o <strong>apropiativa</strong>.
La planificaciÃ³n expropiativa si requiere de un soporte adecuado por parte del hardware, por lo que se utiliza en la mayor parte de los sistemas operativos modernos.
Ejemplos de estos sistemas son Microsoft Windows 9x/NT/2000/XP, macOS, GNU/Linux y los UNIX modernos.</p>
</div>
<div class="paragraph">
<p>La utilizaciÃ³n de un planificador expropiativo introduce algunas dificultades adicionales:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Puesto que un proceso puede ser expropiado en cualquier momento, el sistema operativo debe proporcionar <em>mecanismos de sincronizaciÃ³n</em> (vÃ©ase el <a href="#_sincronizaciÃ³n">CapÃ­tulo 13</a>) para coordinar el acceso a datos compartidos que podrÃ­an estar siendo modificados por el proceso que abandona la CPU.</p>
</li>
<li>
<p>Â¿QuÃ© pasa si un proceso va a ser expropiado cuando se estÃ¡ ejecutando una llamada al sistema? No debemos olvidar que generalmente dentro del nÃºcleo se manipulan datos importantes que deben permanecer consistentes en todo momento.
Para resolver esta cuestiÃ³n los diseÃ±adores pueden optar por <em>impedir la expropiaciÃ³n dentro del nÃºcleo</em>.
Es decir, antes de hacer el cambio de contexto, que sacarÃ­a al proceso de la CPU, se espera a que la llamada se complete o se bloquee pasando el proceso al estado de <em>esperando</em>.
Esto permite nÃºcleos simples y garantiza que las estructuras del mismo permanezcan consistentes, pero es un modelo pobre en sistemas de tiempo real o multiprocesador.
Exploraremos otras soluciones mÃ¡s adelante (vÃ©ase el <a href="#_planificaciÃ³n_de_tiempo_real">Apartado 14.6</a>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_el_asignador">14.2. El asignador</h3>
<div class="paragraph">
<p><em>El <strong>asignador</strong> es el componente que da el control de la CPU al proceso seleccionado por el planificador de corto plazo</em>.
Esta tarea implica realizar las siguientes funciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cambiar el contexto.</p>
</li>
<li>
<p>Cambiar al modo usuario.</p>
</li>
<li>
<p>Saltar al punto adecuado del programa para continuar con el proceso.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Puesto que el <em>asignador</em> es invocado para cada conmutaciÃ³n entre procesos, es necesario que el tiempo que tarda en detener un proceso e iniciar otro sea lo mÃ¡s corto posible.
<em>Al tiempo que transcurre desde que un proceso es escogido para ser planificado en la CPU hasta que es asignado a la misma se lo denomina <strong>latencia de asignaciÃ³n</strong></em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_criterios_de_planificaciÃ³n">14.3. Criterios de planificaciÃ³n</h3>
<div class="paragraph">
<p>Los diferentes algoritmos de planificaciÃ³n de la CPU tienen diversas propiedades que pueden favorecer a una clase de procesos respecto a otra.
Por ello es interesante disponer de algÃºn criterio para poder comparar dichos algoritmos y determinar cual es el mejor.
Se han sugerido muchos criterios para comparar los algoritmos de planificaciÃ³n de CPU pero la elecciÃ³n de uno u otro puede crear una diferencia sustancial a la hora de juzgar cual es el mejor.
A continuaciÃ³n presentamos los criterios mÃ¡s comunes.</p>
</div>
<div class="sect3">
<h4 id="_criterios_a_maximizar">14.3.1. Criterios a maximizar</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Uso de CPU</strong>: Un buen <em>planificador deberÃ­a mantener la CPU lo mÃ¡s ocupada posible</em>.
El uso de CPU es la proporciÃ³n de tiempo que se usa la CPU en un periodo de tiempo determinado.
Se suele indicar en tanto por cierto.</p>
<div class="stemblock">
<div class="content">
\$bb "uso de CPU" = "tiempo que la CPU permanece ocupada" / "tiempo durante el que se toma la medida" "%"\$
</div>
</div>
</li>
<li>
<p><strong>Tasa de procesamiento</strong>: Cuando la CPU estÃ¡ ocupada es porque el trabajo se estÃ¡ haciendo.
Por tanto <em>una buena medida del volumen de trabajo realizado puede ser el nÃºmero de tareas o procesos terminados por unidad de tiempo.
_A dicha magnitud es a la que denominamos como _tasa de procesamiento</em>.</p>
<div class="stemblock">
<div class="content">
\$bb "tasa de procesamiento" = "numero de procesos terminados" / "tiempo durante el que se toma la medida" "procesos/s"\$
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_criterios_a_minimizar">14.3.2. Criterios a minimizar</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Tiempo de ejecuciÃ³n</strong>: Es el <em>intervalo de tiempo que transcurre desde que el proceso es cargado hasta que termina</em>.</p>
</li>
<li>
<p><strong>Tiempo de espera</strong>: Es la <em>suma de tiempos que el proceso permanece a la espera en la cola de preparados</em>.
Evidentemente esta medida de tiempo no incluye el tiempo de espera debido a las operaciones de E/S.</p>
</li>
<li>
<p><strong>Tiempo de respuesta</strong>: Es <em>el intervalo de tiempo que transcurre desde que se le lanza un evento âse pulsa una tecla, se hace clic con el ratÃ³n o llega un paquete por la interfaz de redâ hasta que se produce la primera respuesta del proceso</em>.
Evidentemente esto mide el tiempo que se tarda en responder y no el tiempo de E/S, mientras que el tiempo de ejecuciÃ³n sÃ­ suele estar limitado por la velocidad de los dispositivos E/S.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_elecciÃ³n_del_criterio_adecuado">14.3.3. ElecciÃ³n del criterio adecuado</h4>
<div class="paragraph">
<p>En funciÃ³n del tipo de sistema o de la clase de trabajos que se van a ejecutar puede ser conveniente medir la eficiencia del sistema usando un criterio u otro.
Esto a su vez beneficiarÃ¡ a unos algoritmos de planificaciÃ³n frente a otros, indicÃ¡ndonos cuÃ¡les son los mÃ¡s eficientes para nuestra clase de trabajos en particular.</p>
</div>
<div class="paragraph">
<p>En general podemos encontrar dos clases de trabajos para los que puede ser necesario evaluar la eficiencia del sistema de manera diferente.:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En los sistemas interactivos âya sean sistemas de escritorio o <em>mainframes</em> de tiempo compartidoâ los procesos pasan la mayor parte del tiempo esperando algÃºn tipo de entrada por parte de los usuarios.
En este tipo de sistemas el tiempo de ejecuciÃ³n no suele ser el mejor criterio para determinar la bondad de un algoritmo de planificaciÃ³n, ya que vendrÃ¡ determinado en gran medida por la velocidad de la entrada de los usuarios.
Por el contrario se espera que el sistema reaccione lo antes posible a las Ã³rdenes recibidas, lo que hace que <em>el tiempo de respuesta se el criterio mÃ¡s adecuado</em> para evaluar al planificador de la CPU.
AdemÃ¡s el tiempo de respuesta se reduce generalmente cuando el tiempo que pasan los procesos interactivos en la cola de preparados tambiÃ©n lo hace âtras haber sido puestos ahÃ­ por la ocurrencia de algÃºn eventoâ por lo que tambiÃ©n <em>puede ser una buena idea utilizar como criterio el tiempo de espera</em>.
Esta selecciÃ³n de criterios no sÃ³lo es adecuada para los sistemas interactivos, ya que existen muchos otros casos donde es interesante seleccionar un planificador de la CPU que minimice el tiempo de respuesta.
Esto por ejemplo ocurre con algunos servicios en red como: sistemas de mensajerÃ­a instantÃ¡nea, chats, servidores de videojuegos, etc.</p>
</li>
<li>
<p>Por el contrario en los <em>mainframes</em> de procesamiento por lotes y multiprogramados, en los superordenadores que realizan complejas simulaciones fÃ­sicas y en los grandes centros de datos de proveedores de Internet como Google, lo de menos es el tiempo de respuesta y lo realmente importante es realizar cada tarea en el menor tiempo posible.
Por eso en ese tipo de sistemas <em>es aconsejable utilizar criterios tales como el tiempo de ejecuciÃ³n o la tasa de procesamiento</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Obviamente estos criterios varÃ­an de un proceso a otro, por lo que normalmente lo que se busca es optimizar los valores promedios en el sistema.
Sin embargo no debemos olvidar que <em>en muchos casos puede ser mÃ¡s conveniente optimizar el mÃ¡ximo y mÃ­nimo de dichos valores antes que el promedio</em>.
Por ejemplo, en los sistemas interactivos es mÃ¡s importante minimizar la varianza en el tiempo de respuesta que el tiempo de respuesta promedio, puesto que para los usuarios un sistema con un tiempo de respuesta predecible es mÃ¡s deseable que uno muy rÃ¡pido en promedio pero con una varianza muy alta.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ciclo_de_rÃ¡fagas_de_cpu_y_de_es">14.4. Ciclo de rÃ¡fagas de CPU y de E/S</h3>
<div class="paragraph">
<p>El Ã©xito de la planificaciÃ³n de CPU depende en gran medida de la siguiente propiedad que podemos observar en los procesos: <em>La ejecuciÃ³n de un proceso consiste de ciclos de CPU y esperas de E/S, de forma que alternan entre estos dos estados.
La ejecuciÃ³n empieza con una rÃ¡faga de CPU, seguida por una rÃ¡faga de E/S, que a su vez es seguida por otra de CPU y asÃ­ sucesivamente.
Finalmente la Ãºltima rÃ¡faga de CPU finaliza con una llamada al sistema âgeneralmente exit()â para terminar la ejecuciÃ³n del proceso</em>.</p>
</div>
<div class="paragraph">
<p>La curva que relaciona la frecuencia de las rÃ¡fagas de CPU con la duraciÃ³n de las mismas tiende a ser exponencial o hiper-exponencial (vÃ©ase la ) aunque varÃ­a enormemente entre procesos y sistemas informÃ¡ticos distintos.
Esto significa que los procesos se pueden clasificar entre aquellos que presentan un gran nÃºmero de rÃ¡fagas de CPU cortas o aquellos con un pequeÃ±o nÃºmero de rÃ¡fagas de CPU largas.
Concretamente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Decimos que un <em>proceso es <strong>limitado por la E/S</strong> cuando presenta muchas rÃ¡fagas de CPU cortas, debido a que si es asÃ­ pasa la mayor parte del tiempo esperando por la E/S</em>.</p>
</li>
<li>
<p>Decimos que un <em>proceso estÃ¡ <strong>limitado por la CPU</strong> cuando presenta pocas rÃ¡fagas de CPU largas, debido a que si es asÃ­ hace un uso intensivo de la misma y a penas pasa tiempo esperando por la E/S</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Esta distinciÃ³n entre tipos de procesos puede ser importante en la selecciÃ³n de un algoritmo de planificaciÃ³n de CPU adecuado.
En general:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>El algoritmo escogido debe favorecer âplanificÃ¡ndolos antesâ a los procesos limitados por la E/S</em>, evitando asÃ­ que los procesos limitados por la CPU âque son los que tienden a usarla mÃ¡s tiempoâ la acaparen.
Si eso ocurriera, los procesos limitados por la E/S se acumularÃ­an en la cola de preparados, dejando vacÃ­as las colas de dispositivos.
A este <em>fenÃ³meno tan negativo que provoca una infrautilizaciÃ³n de los dispositivos de E/S se lo denomina <strong>efecto convoy</strong></em>.</p>
</li>
<li>
<p>AdemÃ¡s planificar primero a los procesos limitados por la E/S tiene dos efectos muy positivos:</p>
<div class="ulist">
<ul>
<li>
<p><em>Los procesos interactivos son generalmente procesos limitados por la E/S, por lo que planificarlos primero hace que mejore el tiempo de respuesta</em>.</p>
</li>
<li>
<p><em>Generalmente el tiempo de espera promedio se reduce cuando se planifican primero los procesos con rÃ¡fagas de CPU cortas</em><sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup>, SegÃºn las definiciones anteriores, estos procesos son precisamente los limitados por la E/S.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n">14.5. PlanificaciÃ³n</h3>
<div class="paragraph">
<p>Hasta el momento hemos considerado la cola de preparados como una estructura donde los procesos que estÃ¡n preparados para ser ejecutados se ordenan y se escogen segÃºn el criterio del algoritmo de planificaciÃ³n.
Aunque a lo largo de todo el tema <a href="#_gestiÃ³n_de_procesos">Apartado 4.1</a> se puede haber intuido que dicha cola es de tipo FIFO âlo que se conoce como algoritmo de planificaciÃ³n FCFS o <em>First Come, First Served</em>â ya al principio del <a href="#_planificaciÃ³n_de_la_cpu">CapÃ­tulo 14</a> indicamos que no tiene porquÃ© ser asÃ­ pues existen muchos otros algoritmos âSJF o <em>Shortest-Job First</em>, SRTF o <em>Shortest-Remaing-Time First</em>, RR o <em>Round-Robin</em>, por prioridades, etc.â que pueden ser preferibles en funciÃ³n del criterio que utilicemos para evaluar la eficiencia de los mismos.</p>
</div>
<div class="paragraph">
<p>Sin embargo en los sistemas operativos modernos realmente las cosas son un poco mÃ¡s complejas ya que generalmente se utiliza algÃºn tipo de <strong>planificaciÃ³n con colas multinivel</strong>.
<em>En este tipo de planificaciÃ³n _no existe una Ãºnica cola de preparados sobre la que se utiliza un Ãºnico algoritmo de planificaciÃ³n sino que</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>La cola de preparados se divide en varias colas separadas</em> y los procesos son asignados a alguna de dichas colas en base a caracterÃ­sticas de los mismos.</p>
</li>
<li>
<p><em>Cada cola puede tener un algoritmo de planificaciÃ³n de la CPU distinto</em>.
Es decir, alguno de los que hemos mencionado anteriormente y que se estudiarÃ¡n en las clases de problemas.</p>
</li>
<li>
<p><em>Mediante un algoritmo determinado se debe seleccionar la cola que debe escoger al siguiente proceso a ejecutar.</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Precisamente una cuestiÃ³n interesante es la indicada en Ã©ste Ãºltimo punto Â¿cÃ³mo seleccionar la cola que debe escoger al siguiente proceso que debe ser ejecutado?.</p>
</div>
<div class="sect3">
<h4 id="_prioridad_fija">14.5.1. Prioridad fija</h4>
<div class="paragraph">
<p>Aunque existen muchas maneras de clasificar los procesos entre las diferentes colas, lo mÃ¡s comÃºn en los sistemas operativos modernos es hacerlo en base a la prioridad de los procesos (vÃ©ase la ):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>A cada proceso se le asigna una prioridad</em>.</p>
</li>
<li>
<p><em>En la cola de preparados hay una cola para cada nivel de prioridad</em>.</p>
</li>
<li>
<p><em>Los procesos, al entrar en la cola de preparados, son insertados en aquella cola que coincide con su prioridad</em>.</p>
</li>
<li>
<p><em>El planificador escoge primero siempre la cola de prioridad mÃ¡s alta que no estÃ© vacÃ­a</em>.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_definiciÃ³n_de_las_prioridades">DefiniciÃ³n de las prioridades</h5>
<div class="paragraph">
<p>Las prioridades se suelen indicar con nÃºmeros enteros en un rango fijo.
Por ejemplo [0-7], [0-31], [0-139] o [0-4095].
En algunos sistemas operativos los nÃºmeros mÃ¡s grandes representan mayor prioridad, mientras que en otros son los procesos con nÃºmeros mÃ¡s pequeÃ±os los que se planifican primero.
<em>En Ã©ste curso utilizaremos la convenciÃ³n de que a menor valor mayor prioridad</em>.</p>
</div>
<div class="paragraph">
<p>En los sistemas con prioridad fija:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Una vez se asigna una prioridad a un proceso Ã©sta nunca cambia.</p>
</li>
<li>
<p><em>Las prioridades normalmente vienen determinadas por criterios ajenos al sistema operativo</em>.
Por ejemplo: la importancia del proceso, la cantidad de dinero pagada para el uso del sistema u otros factores polÃ­ticos.
<em>A este tipo de prioridades se las denomina definidas externamente</em>.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_planificaciÃ³n_expropiativa_o_cooperativa">PlanificaciÃ³n expropiativa o cooperativa</h5>
<div class="paragraph">
<p>La planificaciÃ³n con prioridades puede ser expropiativa o cooperativa.
<em>En el caso expropiativo cuando un proceso llega a la cola de preparados su prioridad es comparada con la del proceso en ejecuciÃ³n, de manera que el segundo es expulsado si la prioridad del primero es superior a la suya</em>.
Obviamente en la planificaciÃ³n cooperativa los nuevos procesos simplemente son insertados en la cola que les corresponde en base a su prioridad, independientemente de si tienen o no mayor prioridad que el que se estÃ© ejecutando.</p>
</div>
</div>
<div class="sect4">
<h5 id="_planificaciÃ³n_entre_procesos_con_la_misma_prioridad">PlanificaciÃ³n entre procesos con la misma prioridad</h5>
<div class="paragraph">
<p>Cada cola en cada nivel de prioridad puede tener cualquier algoritmo de planificaciÃ³n de CPU, lo que virtualmente significa que el abanico de posibilidad es muy amplio.
Sin embargo lo mÃ¡s comÃºn es que los diseÃ±adores del sistema opten por utilizar o bien el planificador FCFS o bien el RR<sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup>.</p>
</div>
<div class="paragraph">
<p>En la planificaciÃ³n <strong>FCFS</strong> (<em>First Come, First Served</em>) o <em>primero que llega, primero servido</em> la cola es FIFO:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Los procesos que llegan se colocan al final de la cola que les corresponde</em>.</p>
</li>
<li>
<p><em>El proceso asignado a la CPU se coge siempre del principio de la cola seleccionada</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El algoritmo <strong>RR</strong> (<em>Round-Robin</em>) es similar al FCFS pero utilizando el temporizador para expropiar la CPU a los procesos a intervalos regulares, alternando asÃ­ entre ellos de manera que se da a todos los procesos la oportunidad de ejecutarse.
Como se puede intuir, fue diseÃ±ado para los sistemas de tiempo compartido, siendo ampliamente utilizado en cualquier sistema operativo de propÃ³sito general moderno.</p>
</div>
<div class="paragraph">
<p>El algoritmo RR requiere los siguientes elementos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Se define una ventana de tiempo o *cuanto*</em>, generalmente entre 10 y 100 ms.</p>
</li>
<li>
<p><em>La cola RR se define como una cola circular dÃ³nde el planificador asigna la CPU a cada proceso en intervalos de tiempo de hasta un cuanto</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cuando se utilizar la planificaciÃ³n RR el tamaÃ±o del cuanto es un factor clave en la eficiencia del planificador:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Cuando se reduce el tiempo del cuanto, el tiempo de respuesta y el tiempo de espera promedio tienden a mejorar</em>.
Sin embargo el nÃºmero de cambios de contexto serÃ¡ mayor, por lo que la ejecuciÃ³n de los procesos serÃ¡ mas lenta.
AdemÃ¡s es importante tener en cuenta que interesa que el tiempo del cuanto sea mucho mayor que el tiempo del cambio de contexto; pues si por ejemplo el tiempo del cambio de contexto es un 10% del tiempo del cuanto, entonces alrededor del 10% de CPU se perderÃ­a en cambios de contexto.</p>
</li>
<li>
<p><em>Cuando se incrementa el tiempo del cuanto, el tiempo de espera promedio se incrementa</em> dado que entonces el RR tiende a comportarse como un FCFS, que suele tener grandes tiempos de espera promedio.
AdemÃ¡s se puede observar experimentalmente que el tiempo de ejecuciÃ³n promedio generalmente mejora cuantos mÃ¡s procesos terminan su prÃ³xima rÃ¡faga de CPU dentro del tiempo del cuanto<sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="View footnote.">8</a>]</sup>.
Por lo tanto nos interesan un cuanto grande para que mÃ¡s procesos terminen su siguiente rÃ¡faga dentro del mismo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La <em>regla general que siguen los diseÃ±adores es intentar que el 80% de las rÃ¡fagas de CPU sean menores que el tiempo de cuanto</em>.
Se busca asÃ­ equilibrar los criterios anteriores, evitando que el tiempo de cuanto sea demasiado grande o demasiado corto<sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnotedef_9" title="View footnote.">9</a>]</sup>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_muerte_por_inaniciÃ³n_y_otros_inconvenientes">Muerte por inaniciÃ³n y otros inconvenientes</h5>
<div class="paragraph">
<p>El principal problema de este tipo de planificaciÃ³n es el <em>bloqueo indefinido</em> o <strong>muerte por inaniciÃ³n</strong>, puesto que el algoritmo puede dejar a los procesos de baja prioridad esperando indefinidamente si hay un conjunto de procesos de mayor prioridad demandando CPU continuamente.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s, como vimos en el <a href="#_ciclo_de_rÃ¡fagas_de_cpu_y_de_es">Apartado 14.4</a>, es conveniente favorecer a los procesos limitados por la E/S frente a los procesos limitados por la CPU para evitar el <em>efecto convoy</em> y para mejorar los tiempos tanto de espera como de respuesta promedio.
Lamentablemente este tipo de planificaciÃ³n con <em>prioridad fija no es capaz de hacerlo ya que la prioridad de los procesos viene determinada exclusivamente por criterios externos al funcionamiento del sistema operativo</em>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_prioridad_dinÃ¡mica">14.5.2. Prioridad dinÃ¡mica</h4>
<div class="paragraph">
<p>La mayor parte de los sistemas operativos modernos de propÃ³sito general<sup class="footnote">[<a id="_footnoteref_10" class="footnote" href="#_footnotedef_10" title="View footnote.">10</a>]</sup> <em>solucionan los inconvenientes de la planificaciÃ³n con prioridad fija permitiendo que la prioridad de los procesos se ajuste dinÃ¡micamente</em> bajo su propio criterio:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Por ejemplo, <em>una soluciÃ³n al problema de la muerte por inaniciÃ³n es utilizar un mecanismo de <strong>envejecimiento</strong></em> que aumente gradualmente la prioridad de los procesos mientras estÃ¡n esperando en la cola de preparados âpor ejemplo 1 nivel de prioridad cada 15 minutosâ.
De esta manera los procesos de baja prioridad tarde o temprano tendrÃ¡n oportunidad de ejecutarse.
Con este mecanismo una vez consiguen ejecutarse, se les restablece su prioridad original.</p>
</li>
<li>
<p><em>Para favorecer en la planificaciÃ³n a los procesos limitados por la E/S el sistema puede aÃ±adir o quitar prioridad a los procesos, respecto a su prioridad fija, en funciÃ³n de medidas internas del sistema operativo</em>.
Por ejemplo se puede tomar en consideraciÃ³n: lÃ­mites de tiempo, necesidades de memoria, nÃºmero de archivos abiertos, la proporciÃ³n entre el tiempo de rÃ¡faga de E/S promedio y el de rÃ¡faga de CPU promedio del proceso, etc.
Obviamente el objetivo suele ser mejorar el rendimiento del sistema priorizando unos procesos respecto a otros.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El resultado de estas polÃ­ticas es que la prioridad que finalmente utiliza el sistema operativo para planificar los procesos en un valor calculado dinÃ¡micamente a partir de intereses externos y medidas internas.
Por lo tanto los procesos pueden cambiar mÃºltiples veces de cola durante su tiempo de vida.
<em>A la planificaciÃ³n de mÃºltiples niveles donde los procesos pueden cambiar de una cola a otra se la denomina <strong>planificaciÃ³n con colas multinivel realimentadas</strong></em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_planificaciÃ³n_por_reparto_proporcional">14.5.3. PlanificaciÃ³n por reparto proporcional</h4>
<div class="paragraph">
<p>Hasta el momento hemos hablado de planificadores que se concentran en cuÃ¡l es el proceso mÃ¡s importante que debe ser ejecutado en cada instante.
Sin embargo otra opciÃ³n, desde el punto de vista de la planificaciÃ³n ,es repartir el tiempo de CPU entre los procesos a un ritmo controlado.
Esto es precisamente lo que hace <em>la <strong>planificaciÃ³n equitativa</strong> (Fair Scheduling) que intenta repartir por igual el tiempo de CPU entre los procesos de la cola de preparados</em>.
Por ejemplo, si 4 procesos compiten por el uso de la CPU, el planificador asignarÃ¡ un 25%
del tiempo de la misma a cada uno.
Si a continuaciÃ³n un usuario iniciase un nuevo proceso, el planificador tendrÃ­a que ajustar el reparto asignando un 20% del tiempo a cada uno.
El algoritmo de planificaciÃ³n equitativa es muy similar al algoritmo RR pero, a diferencia de este Ãºltimo en el que se utiliza un cuanto de tamaÃ±o fijo, <em>la ventana de tiempo se calcula de dinÃ¡micamente para garantizar el reparto equitativo de la CPU</em>.</p>
</div>
<div class="paragraph">
<p>Al igual que en los algoritmos anteriores, en ocasiones puede ser interesante priorizar unos procesos frente a otros, tanto por motivos ajenos al sistema operativo como por motivos internos.
Por ejemplo se puede querer favorecer a los procesos limitados por la E/S para mejorar la eficiencia del sistema, tal y como comentamos en el apartado <a href="#_ciclo_de_rÃ¡fagas_de_cpu_y_de_es">Apartado 14.4</a>.
La <em>planificaciÃ³n equitativa</em> resuelve este problema asignando proporcionalmente mÃ¡s tiempo de CPU a los procesos con mayor prioridad.
<em>A esta generalizaciÃ³n del planificador equitativo se la conoce como <strong>planificador equitativo ponderado</strong></em><sup class="footnote">[<a id="_footnoteref_11" class="footnote" href="#_footnotedef_11" title="View footnote.">11</a>]</sup>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n_de_tiempo_real">14.6. PlanificaciÃ³n de tiempo real</h3>
<div class="paragraph">
<p>En el <a href="#_sistemas_de_tiempo_real">Apartado 2.7</a> discutimos la importancia de los sistemas de tiempo real.
A continuaciÃ³n, describiremos las funcionalidades necesarias para soportar la ejecuciÃ³n de procesos en tiempo real dentro de un sistema operativo de propÃ³sito general.</p>
</div>
<div class="sect3">
<h4 id="_tiempo_real_estricto">14.6.1. Tiempo real estricto</h4>
<div class="paragraph">
<p>Los sistemas de <strong>tiempo real estricto</strong> son necesarios para realizar tareas crÃ­ticas que deben ser completadas dentro de unos mÃ¡rgenes de tiempo preestablecidos.
Generalmente las tareas son entregas al sistema operativo junto con una declaraciÃ³n de las restricciones de tiempo âperiodicidad y lÃ­mite de tiempoâ y la cantidad de tiempo que necesitan para ejecutarse.
El planificador sÃ³lo admitirÃ¡ las tareas si puede garantizar el cumplimiento de las restricciones de tiempo, rechazÃ¡ndolas en caso contrario.
El proporcionar estas garantÃ­as requiere que el planificador conozca exactamente el tiempo mÃ¡ximo que se tarda en realizar todas y cada una de las funciones del sistema operativo.
Esto es imposible en sistemas con almacenamiento secundario o memoria virtual, ya que introducen variaciones no controladas en la cantidad de tiempo necesario para ejecutar una tarea.
Por tanto, el <em>tiempo real estricto no es compatible con los sistemas operativos de propÃ³sito general</em>, como los de tiempo compartido.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tiempo_real_flexible">14.6.2. Tiempo real flexible</h4>
<div class="paragraph">
<p>La ejecuciÃ³n de procesos de <strong>tiempo real flexible</strong> es menos restrictiva.
Tan sÃ³lo requiere que los procesos crÃ­ticos reciban mayor prioridad que los que no lo son.
Esto es compatible con los sistemas de tiempo compartido, aunque <em>puede generar excesos en la cantidad de recursos asignados a los procesos de tiempo real, asÃ­ como inaniciÃ³n y grandes retardos en la ejecuciÃ³n del resto de los procesos</em>.
Sin embargo esto nos permite conseguir sistemas de propÃ³sito general que soporten multimedia, videojuegos y otras tareas que no funcionarÃ­an de manera aceptable en un entorno que no implementara tiempo real flexible.
Por ello la mayor parte de los sistemas operativos modernos soportan este tipo de tiempo real.</p>
</div>
<div class="paragraph">
<p>Implementar el soporte de tiempo real flexible en un sistema operativo de propÃ³sito general requiere:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Sistema operativo con planificaciÃ³n con prioridades.
<em>Los procesos de tiempo real deben tener la mayor prioridad.
AdemÃ¡s, no deben ser afectados por ningÃºn mecanismo de envejecimiento o bonificaciÃ³n</em><sup class="footnote">[<a id="_footnoteref_12" class="footnote" href="#_footnotedef_12" title="View footnote.">12</a>]</sup>, que sÃ­ puede afectar a los procesos de tiempo no real.</p>
</li>
<li>
<p><em>Baja latencia de asignaciÃ³n</em>.
Cuanto menor es la latencia mÃ¡s rÃ¡pido comenzarÃ¡ a ejecutarse el proceso de tiempo real despuÃ©s de ser seleccionado por el planificador de la CPU.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Mientras que el primer requerimiento es bastante sencillo de conseguir, el segundo es mucho mÃ¡s complejo.
Muchos sistemas operativos tienen un nÃºcleo no expropiable.
Estos nÃºcleos no pueden realizar un cambio de contexto mientras se estÃ¡ ejecutando cÃ³digo del nÃºcleo âpor ejemplo debido a una llamada al sistemaâ por lo que se ven obligados a esperar hasta que la tarea que se estÃ© realizando se termine antes de asignar la CPU a otro proceso.
Esto aumenta la <em>latencia de asignaciÃ³n</em> dado que algunas llamadas al sistema pueden ser muy complejas y requerir mucho tiempo para ser completadas.
Con el objetivo de resolverlo existen diversas alternativas:</p>
</div>
<div class="sect4">
<h5 id="_puntos_de_expropiaciÃ³n">Puntos de expropiaciÃ³n</h5>
<div class="paragraph">
<p>Una posibilidad es <em>hacer que el cÃ³digo del nÃºcleo sea expropiable</em>.
Esto se consigue introduciendo <strong>puntos de expropiaciÃ³n</strong> en diversos lugares <em>seguros</em> dentro del cÃ³digo.
En dichos puntos se comprueba si algÃºn proceso de prioridad mÃ¡s alta estÃ¡ en la cola de preparados.
En caso de que sea asÃ­ se expropia la CPU al proceso actual y se le asigna al proceso de mÃ¡s alta prioridad.</p>
</div>
<div class="paragraph">
<p>Debido a la funciÃ³n que realizan los puntos de expropiaciÃ³n, sÃ³lo pueden ser colocados en lugares seguros del cÃ³digo del nÃºcleo.
Es decir, sÃ³lo pueden estar situados allÃ­ donde no se interrumpe la modificaciÃ³n de estructuras de datos.
Sin embargo esto limita el nÃºmero de puntos que pueden ser colocados, por lo que la latencia de asignaciÃ³n puede seguir siendo muy alta para algunas tareas muy complejas del cÃ³digo del nÃºcleo.</p>
</div>
</div>
<div class="sect4">
<h5 id="_nÃºcleo_expropiable">NÃºcleo expropiable</h5>
<div class="paragraph">
<p>Otra posibilidad es <em>diseÃ±ar un nÃºcleo completamente expropiable</em>.
Puesto que en este caso la ejecuciÃ³n de cualquier tarea en el nÃºcleo puede ser interrumpida en cualquier momento por procesos de mayor prioridad âque el que actualmente tiene asignada la CPUâ es necesario proteger las estructuras de datos del nÃºcleo con mecanismos de sincronizaciÃ³n, lo que hace que el diseÃ±o de un nÃºcleo de estas caracterÃ­sticas sea mucho mÃ¡s complejo.</p>
</div>
<div class="paragraph">
<p>Supongamos que un proceso de baja prioridad es interrumpido, porque hay un proceso de alta prioridad en la cola de preparados, mientras accede a una importante estructura de datos del nÃºcleo.
Durante su ejecuciÃ³n el proceso de alta prioridad podrÃ­a intentar acceder a la misma estructura que manipulaba el proceso de baja prioridad cuando fue interrumpido.
Debido al uso de mecanismos de sincronizaciÃ³n el proceso de alta prioridad tendrÃ­a que abandonar la CPU a la espera de que el de baja libere el acceso.
Sin embargo este tardarÃ¡ en ser asignado a la CPU mientras haya algÃºn otro proceso de alta prioridad en la cola de preparados.
AdemÃ¡s otros procesos puede irse aÃ±adiendo a la cola de espera del mecanismo de sincronizaciÃ³n que regula el acceso a la estructura de datos del nÃºcleo.
Al hecho de que un proceso de alta prioridad tenga que esperar por uno de baja se le conoce como <strong>inversiÃ³n de la prioridad</strong>.
Para resolverlo se utiliza un <strong>protocolo de herencia de la prioridad</strong> dÃ³nde un proceso de baja prioridad hereda la prioridad del proceso de mÃ¡s alta prioridad que espera por un recurso al que el primero estÃ¡ accediendo.
En el momento en que el proceso de baja prioridad libere el acceso a dicho recurso, su prioridad retornarÃ¡ a su valor original.</p>
</div>
<div class="paragraph">
<p>Linux 2.6, Solaris y Microsoft Windows NT/2000/XP son algunos ejemplos de sistemas operativos con nÃºcleos expropiables.
En el caso concreto de Solaris la latencia de asignaciÃ³n es inferior a 1 ms.
mientras que con la expropiaciÃ³n del nÃºcleo desactivada Ã©sta puede superar los 100 ms.</p>
</div>
<div class="paragraph">
<p>Lamentablemente el <em>conseguir baja latencia de asignaciÃ³n no tiene coste cero</em>.
El hecho de que el nÃºcleo sea expropiable aumenta el nÃºmero de cambios de contexto, lo que reduce el rendimiento del sistema a cambio de una mejor respuesta.
Por ello resulta muy interesante para aplicaciones de tiempo real, multimedia y sistemas interactivos pero es poco adecuado para servidores y computaciÃ³n de alto rendimiento.
Es por eso que Linux 2.6 permite escoger entre tener un nÃºcleo expropiativo, usar puntos de expropiaciÃ³n o nada de lo anterior.
De esta forma Linux estÃ¡ preparado tanto para servidores como para sistemas de escritorio o de tiempo real.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n_en_sistemas_multiprocesador">14.7. PlanificaciÃ³n en sistemas multiprocesador</h3>
<div class="paragraph">
<p>Para tratar el problema de la planificaciÃ³n en los sistemas multiprocesador nos limitaremos al caso de los <em>sistemas homogÃ©neos</em><sup class="footnote">[<a id="_footnoteref_13" class="footnote" href="#_footnotedef_13" title="View footnote.">13</a>]</sup>.
En dichos sistemas los procesadores son idÃ©nticos, por lo que cualquiera de ellos puede ejecutar cualquier proceso.
Esto es bastante comÃºn y simplifica el problema de la planificaciÃ³n.
Aun asÃ­ no debemos olvidar que incluso en el caso de los sistemas homogÃ©neos pueden aparecer limitaciones en la planificaciÃ³n.
Por ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un dispositivo de E/S puede estar conectado mediante un bus privado a un procesador en particular.
En ese caso los procesos que quieren utilizar ese dispositivo deben ejecutarse en dicho procesador.</p>
</li>
<li>
<p>Los procesadores SMT<sup class="footnote">[<a id="_footnoteref_14" class="footnote" href="#_footnotedef_14" title="View footnote.">14</a>]</sup> (<em>Simultaneous Multithreading</em>) permiten la ejecuciÃ³n concurrente de varios hilos como si de varias CPU se tratara.
Sin embargo, al no disponer cada hilo de una CPU completa es posible que algunos deban esperar a que algÃºn otro libere unidades de la CPU que le son necesarias.
Eso debe ser tenido en cuenta por el planificador con el fin de optimizar el rendimiento del sistema.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Al margen de estas cuestiones, existen diversas posibilidades a la hora de enfrentar el problema de la planificaciÃ³n en un sistema multiprocesador:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando utilizamos <strong>multiprocesamiento asimÃ©trico</strong><sup class="footnote">[<a id="_footnoteref_15" class="footnote" href="#_footnotedef_15" title="View footnote.">15</a>]</sup> todas las decisiones de planificaciÃ³n, procesamiento de E/S y otras actividades son gestionadas por un Ãºnico procesador, el <em>servidor</em> o <em>maestro</em>.
El resto de procesadores se limitan a ejecutar el cÃ³digo de usuarios que les es asignado.
Este esquema <em>es sencillo puesto que evita la necesidad de compartir estructuras de datos entre el cÃ³digo que se ejecuta en los procesadores</em>.</p>
</li>
<li>
<p>Cuando utilizamos <strong>multiprocesamiento simÃ©trico</strong><sup class="footnote">[<a id="_footnoteref_16" class="footnote" href="#_footnotedef_16" title="View footnote.">16</a>]</sup> o <em>SMP</em> cada procesador ejecuta su propia copia del nÃºcleo del sistema operativo y se auto-planifica mediante su propio planificador de CPU.
En estos sistemas nos podemos encontrar con varias alternativas:</p>
<div class="ulist">
<ul>
<li>
<p>Algunos sistemas disponen de <em>una cola de preparados comÃºn para todos los procesadores</em>.
Puesto que se mira en una Ãºnica cola, <em>todos los procesos pueden ser planificados en cualquier procesador</em>.
Este esquema requiere el uso mecanismos de sincronizaciÃ³n debido a que hay estructuras de datos que se comparten entre todos los nÃºcleos.
En caso contrario varios procesadores podrÃ­an escoger y ejecuta el mismo proceso a la vez.</p>
</li>
<li>
<p>Por el contrario otros sistemas disponen de <em>una cola de preparados para cada procesador</em>.
El mayor inconveniente de esta soluciÃ³n es que puede generar desequilibrios entre los procesadores, ya que un procesador puede acabar desocupado âcon la cola de preparados vacÃ­aâ mientras otro estÃ¡ muy ocupado.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Muchos sistemas operativos modernos implementan el esquema SMP con una cola de preparados comÃºn.
Esto incluye Microsoft Windows NT/2000/XP, Solaris, macOS y versiones anteriores a Linux 2.6.
Sin embargo, esta soluciÃ³n presenta algunos inconvenientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La posibilidad de que un proceso se pueda ejecutar en cualquier CPU âaunque parezca beneficiosaâ es negativa desde el punto de vista de que dejan de ser Ãºtiles las cachÃ©s de los procesadores, penalizando notablemente el rendimiento del sistema.
Por eso realmente la mayorÃ­a de los sistemas operativos de este tipo intenta evitar la migraciÃ³n de procesos de un procesador a otro.
A esto se lo conoce con el nombre de <strong>afinidad al procesador</strong>.</p>
</li>
<li>
<p>Los mecanismos de sincronizaciÃ³n requeridos para controlar el acceso a la cola de preparados pueden mantener a los procesadores mucho tiempo desocupados âmientras esperanâ en sistemas con un gran nÃºmero de procesadores y con muchos procesos a la espera de ser ejecutados.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cada vez mÃ¡s sistemas modernos âincluido Linux 2.6â estÃ¡n optando por utilizar el esquema SMP con una cola de preparados por procesador.
De esta manera, al no utilizar mecanismos de sincronizaciÃ³n, se eliminan los tiempos de espera para acceder a la cola de preparados y escoger un nuevo proceso.
Sin embargo, con el fin de mantener la carga de trabajo equilibrada entre todos los procesadores es necesario disponer de algunos mecanismos de <strong>balanceo de carga</strong>.
Por ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En la <strong>migraciÃ³n comandada</strong> o <em>push migration</em> un tarea especÃ­fica âque se ejecuta con menor frecuencia que el planificador de la CPUâ estima la carga de trabajo de cada CPU y en caso de encontrar algÃºn desequilibrio mueve algunos procesos de la cola de preparados de unos procesadores a la de los otros * En la <strong>migraciÃ³n solicitada</strong> o <em>pull migration</em> un procesador inactivo extrae de la cola de preparados de un procesador ocupado alguna tarea que estÃ© esperando.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Tanto el planificador de Linux 2.6 como el planificador ULE, disponible en los sistemas FreeBSD, implementan ambas tÃ©cnicas.
Mientras que en Microsoft Windows, a partir de Windows Vista, sÃ³lo se hace uso de la <em>migraciÃ³n solicitada</em>.</p>
</div>
<div class="paragraph">
<p>Para ilustrar los visto hasta el momento sobre la planificaciÃ³n de la CPU en sistemas operativos modernos, vamos a estudiar las principales caracterÃ­sticas de las Ãºltimas versiones de Microsoft Windows a este respecto.</p>
</div>
<div class="paragraph">
<p>Las actuales versiones de sistemas operativos Windows se agrupan dentro de la familia Microsoft Windows NT; que naciÃ³ con el sistema operativo Windows NT 3.1 en 1993 y que llega hasta hoy en dÃ­a con Microsoft Windows 8.1 y Windows Server 2012 R2 âque se corresponden con la versiÃ³n 6.3 de dicha familia Windows NTâ</p>
</div>
<div class="paragraph">
<p>El nÃºcleo de la familia <em>Windows NT</em> es multihilo e internamente implementa un algoritmo de planificaciÃ³n expropiativa con colas multinivel realimentadas basado en prioridades:</p>
</div>
<div class="paragraph">
<p>Como cualquier sistema operativo moderno, el nÃºcleo de Windows es expropiable âlo que sabemos que ofrece latencias de asignaciÃ³n mÃ¡s bajas que si no lo fueraâ y soporta tiempo real flexible:</p>
</div>
<div class="paragraph">
<p>Respecto a esto Ãºltimo, en Windows los programadores o administradores del sistema pueden utilizar el API para establecer la prioridad de los hilos.
Sin embargo sobre estas preferencias el nÃºcleo aplica ciertas bonificaciones para obtener la prioridad real; combinando diferentes criterios para reducir la latencia, mejorar la respuesta âobviamente a travÃ©s de beneficiar a los hilos limitados por E/Sâ evitar la muerte por inaniciÃ³n y la inversiÃ³n de prioridad.
Estas bonificaciones pueden ocurrir en los siguientes casos:</p>
</div>
<div class="paragraph">
<p>Respecto al tiempo de cuanto, desde Windows Vista âNT 6.0â no se usa el temporizador para controlarlo sino un contador de ciclos de reloj de la CPU<sup class="footnote">[<a id="_footnoteref_17" class="footnote" href="#_footnotedef_17" title="View footnote.">17</a>]</sup>.
AsÃ­ el sistema puede determinar con precisiÃ³n el tiempo que se hay estado ejecutando un hilo, sin incluir los tiempos dedicados a otras cuestiones, como por ejemplo a manejar interrupciones.</p>
</div>
<div class="paragraph">
<p>En Windows los hilos se insertan en la cabeza de su cola âno en el finalâ y conservan lo que les queda de cuanto, cuando son expropiados.
Mientras que se insertan por el final con el valor de cuanto reiniciado, cuando abandonan la CPU por haber agotado el cuanto anterior.</p>
</div>
<div class="paragraph">
<p>En Windows las prioridades de los procesos se pueden ver desde dos perspectivas: la del API de Windows y la del nÃºcleo.
Esta Ãºltima es la que hemos estudiado en el apartado anterior.
Mientras que el API tiene una organizaciÃ³n muy diferente que en Ãºltima instancia debe ser mapeada a las prioridades numÃ©ricas del nÃºcleo de Windows.</p>
</div>
<div class="paragraph">
<p>El API organiza los procesos por clases de prioridad: Tiempo real (15), Alta (10), Arriba de lo normal (9), Normal (8), Debajo de lo normal (7), Baja (6) y Reposo (1) .
Al tiempo que cada hilo tiene una prioridad relativa: De tiempo crÃ­tico (15), MÃ¡s alta (2), Arriba de lo normal (1), Normal (0), Debajo de lo normal (â1), MÃ¡s baja (â2) y Reposo (â15).
Por lo que la prioridad interna de cada hilo, desde el punto de vista del nÃºcleo, es el resultado de sumar la prioridad base obtenida a partir de la clase de prioridad del proceso con la prioridad relativa del hilo en cuestiÃ³n.</p>
</div>
</div>
</div>
</div>
<h1 id="_gestiÃ³n_de_la_memoria" class="sect0">Parte IV: GestiÃ³n de la memoria</h1>
<div class="sect1">
<h2 id="_memoria_principal">15. Memoria principal</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La memoria es un recurso central para el funcionamiento de un sistema operativo moderno, puesto que es el Ãºnico medio de almacenamiento al que la CPU puede acceder directamente.
Por ello, para que un programa pueda ser ejecutado debe ser cargado en la memoria, desde el disco, y creadas o modificadas las estructuras internas del sistema operativo necesarias para convertirlo en un proceso.
AdemÃ¡s, dependiendo de la forma en la que se gestiona la memoria, los procesos o partes de los mismos pueden moverse de la memoria al disco y viceversa durante su ejecuciÃ³n, con el objetivo de ajustar las necesidades de memoria manteniendo la utilizaciÃ³n de la CPU lo mÃ¡s alta posible.</p>
</div>
<div class="paragraph">
<p>Como ya comentamos en el aparatado <a href="#_mainframe">Apartado 2.1</a>, en los <strong>sistemas multiprogramados</strong> existe una <strong>cola de entrada</strong> que se define <em>como aquella formada por el conjunto de procesos en disco que esperan para ser cargados en la memoria para su ejecuciÃ³n</em>.</p>
</div>
<div class="paragraph">
<p>Por tanto, el procedimiento normal de ejecuciÃ³n de un programa en dichos sistemas es:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Seleccionar un proceso de la cola de entrada y cargarlo en la memoria</em>.</p>
</li>
<li>
<p><em>Mientras el proceso se ejecuta, Ã©ste accede a instrucciones y datos de la memoria</em>.</p>
</li>
<li>
<p><em>Finalmente el proceso termina y su espacio en memoria es marcado como disponible</em>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>En los <strong>sistemas de tiempo compartido</strong> no existe <strong>cola de entrada</strong>, por lo que los programas se cargan inmediatamente en memoria cuando su ejecuciÃ³n es solicitada por los usuarios.
Excepto por eso, el procedimiento normal de ejecuciÃ³n de un programa es el mismo que para los <em>sistemas multiprogramados</em>.</p>
</div>
<div class="sect2">
<h3 id="_reubicaciÃ³n_de_las_direcciones">15.1. ReubicaciÃ³n de las direcciones</h3>
<div class="paragraph">
<p>La mayor parte de los sistemas permiten que un proceso de usuario resida en cualquier parte de la memoria fÃ­sica.
AsÃ­, aunque el espacio de direcciones del sistema comience en <code>0x000000</code>, la primera direcciÃ³n del proceso de usuario no tiene porque ser esa.
En la mayor parte de los casos, un programa de usuario debe pasar por diferentes etapas âalgunas de las cuales son opcionalesâ antes de ser ejecutado (vÃ©ase la ).
En cada una de ellas las direcciones pueden representarse de formas distintas, por lo que en cada paso es necesario reubicar las direcciones usadas en una etapa en direcciones de la siguiente.
Por ejemplo, en el cÃ³digo fuente de un programa las direcciones son generalmente <em>simbÃ³licas</em>, como los nombres de las variables y las funciones.
A continuaciÃ³n, un compilador suele reasignar esas direcciones simbÃ³licas en <em>direcciones reubicables</em> del estilo de "120 bytes desde el comienzo del mÃ³dulo".
Finalmente, el enlazador o el cargador convierte esas direcciones reubicables en <em>direcciones absolutas</em> como <code>0x210243</code>.</p>
</div>
<div class="paragraph">
<p>Por tanto, en cada etapa se mapean las direcciones de un espacio de direcciones en el siguiente.
Sin embargo, para que al final el programa pueda ser ejecutado es necesario que tanto a los datos como a las instrucciones se les reasignen direcciones absolutas de la memoria.
Esto realmente puede ocurrir en cualquiera de las siguientes etapas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En <strong>tiempo de compilaciÃ³n</strong>.
Si durante la compilaciÃ³n o el enlazado se conoce el lugar de la memoria donde va a ser ejecutado el proceso, se puede generar directamente cÃ³digo con <em>direcciones absolutas</em>, o <strong>cÃ³digo absoluto</strong>.
Si en algÃºn momento la direcciÃ³n de inicio donde es cargado el programa cambia, es necesario recompilar el cÃ³digo fuente del programa.
Los programas con formato COM del MS-DOS son un ejemplo de este tipo de programas.</p>
</li>
</ul>
</div>
<div class="ulist">
<ul>
<li>
<p>En <strong>tiempo de carga</strong>.
Si no se conoce durante la compilaciÃ³n el lugar donde va a residir un programa cuando sea ejecutado, el compilador debe generar <strong>cÃ³digo reubicable</strong>.
En este tipo de cÃ³digo se utilizan <em>direcciones reubicables</em>, de manera que se retrasa la reubicaciÃ³n a direcciones absolutas hasta el momento de la carga del programa.
Esto permite a muchos sistemas operativos que un proceso pueda residir en cualquier parte de la memoria fÃ­sica, cargando los procesos donde mÃ¡s convenga para maximizar el aprovechamiento de la misma.</p>
</li>
<li>
<p>En <strong>tiempo de ejecuciÃ³n</strong>.
Si un proceso puede ser movido durante su ejecuciÃ³n de un lugar de la memoria a otro, la reubicaciÃ³n de direcciones debe ser retrasada hasta el momento de la ejecuciÃ³n de cada instrucciÃ³n del programa.
Para que esto sea posible necesitamos disponer de hardware especial que suele estar presente en la mayor parte de las CPU modernas, por lo que la inmensa mayorÃ­a de los sistemas operativos modernos de propÃ³sito general utilizan este mÃ©todo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En el <a href="#_protecciÃ³n_de_la_memoria">Apartado 7.3</a> vimos en lo sistemas operativos modernos, como medida de protecciÃ³n, los procesos no tienen acceso libre a la memoria fÃ­sica.
En lugar de eso el sistema operativo âasistido por la MMU (Memory-Management Unit)â proporciona a cada proceso un <em>espacio de direcciones virtual</em> que ofrece una Â«vistaÂ» privada de la memoria similar a la que tendrÃ­an si cada uno de los procesos estuviera siendo ejecutando en solitario (vÃ©ase la ).
Es durante los acceso a la memoria principal en tiempo de ejecuciÃ³n cuando estas <em>direcciones virtuales</em> son convertidas en las <em>direcciones fÃ­sica</em> con las que realmente se accede a la memoria.</p>
</div>
<div class="paragraph">
<p>El mecanismo de protecciÃ³n descrito <em>es una forma muy comÃºn de reubicaciÃ³n de las direcciones en tiempo de ejecuciÃ³n</em> que estÃ¡ presente en la mayor parte de los sistemas operativos modernos de propÃ³sito general.
A parte de la protecciÃ³n, algunas de las caracterÃ­sticas de dicho mecanismo son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Los programas pueden ser cargados en cualquier zona libre de la memoria fÃ­sica e incluso movidos de una regiÃ³n a otra durante la ejecuciÃ³n de los procesos</em>, puesto que la transformaciÃ³n (reubicaciÃ³n) de las direcciones virtuales en direcciones fÃ­sicas se realiza durante la ejecuciÃ³n de cada instrucciÃ³n.</p>
</li>
<li>
<p><em>La reubicaciÃ³n de las direcciones virtuales âes decir, la asignaciÃ³n de direcciones virtuales a las direcciones del programaâ puede hacerse en tiempo de compilaciÃ³n</em> puesto que de antemano se sabe que todo el espacio de direcciones virtual va a estar disponible.
Lo comÃºn es que los programas se ubiquen en la parte baja del espacio de direcciones virtual, por ejemplo en empezando en la direcciÃ³n <code>0x00000000</code>.</p>
</li>
<li>
<p><em>Se puede reducir el consumo de memoria principal compartiendo las regiones de memoria fÃ­sica asignadas al cÃ³digo y los datos de sÃ³lo lectura de los procesos de un mismo programa</em>.
El cÃ³digo de un programa suele contener direcciones tanto para los saltos como para el acceso a los datos.
Al ubicar los programas siempre en las mismas regiones de los espacios de direcciones virtuales nos estamos asegurando de que el cÃ³digo en memoria de los procesos de un mismo programa siempre es el mismo, por lo que se puede compartir la memoria fÃ­sica que ocupan.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_enlazado_dinÃ¡mico_y_librerÃ­as_compartidas">15.2. Enlazado dinÃ¡mico y librerÃ­as compartidas</h3>
<div class="paragraph">
<p>Fundamentalmente existen dos tipos de enlazado:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>En el <strong>enlazado estÃ¡tico</strong>, las librerÃ­as del sistema y otros mÃ³dulos son combinados por el enlazador para formar la imagen binaria del programa que es almacenada en disco</em>.
Algunos sistemas operativos, como MS-DOS, sÃ³lo soportan este tipo de enlazado.</p>
</li>
<li>
<p><em>En el <strong>enlazado dinÃ¡mico</strong>, Ã©ste se pospone hasta la carga o la ejecuciÃ³n</em> (vÃ©ase la ).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Generalmente el enlazado dinÃ¡mico ocurre durante la carga del programa:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Durante la carga del mÃ³dulo ejecutable se comprueban las dependencias del mismo</em>.
Estas se almacenan en el mismo archivo en disco que dicho mÃ³dulo.</p>
</li>
<li>
<p><em>Las librerÃ­as a enlazar se cargar y ubican en el espacio de direcciones virtual creado para el nuevo proceso</em>.</p>
</li>
<li>
<p>Finalmente, <em>las referencias del programa a las funciones de cada una de las librerÃ­as cargadas se actualizan con la direcciÃ³n en memoria de las mismas</em>.
AsÃ­ la invocaciÃ³n de las funciones por parte del programa se puede realizar de forma transparente, como si siempre hubieran formado parte del mismo.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando el enlazado se va a realizar en tiempo de ejecuciÃ³n se habla de <em>enlazado dinÃ¡mico con carga diferida</em>.
En ese caso el procedimiento es el siguiente.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Durante el enlazado estÃ¡tico del mÃ³dulo ejecutable se pone un stub a cada referencia a alguna funciÃ³n de la librerÃ­a que va a ser enlazada dinÃ¡micamente</em>.</p>
</li>
<li>
<p><em>Si durante la ejecuciÃ³n alguna de dichas funciones es invocada, se ejecuta el stub</em>.
El <em>stub</em> es una pequeÃ±a pieza de cÃ³digo que sabe como carga la librerÃ­a, si no ha sido cargada previamente, y como localizar la funciÃ³n adecuada en la misma.</p>
</li>
<li>
<p>Finalmente, <em>el stub se sustituye a si mismo con la direcciÃ³n de la funciÃ³n y la invoca</em>.
Esto permite que la siguiente ejecuciÃ³n de la funciÃ³n no incurra en ningÃºn coste adicional.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Sin esta habilidad cada programa en el sistema, por ejemplo, debe tener una copia de la librerÃ­a del sistema incluida en la imagen binaria del mismo, lo que significa un desperdicio de espacio libre en disco y memoria principal.
AdemÃ¡s este esquema facilita la actualizaciÃ³n de las librerÃ­a, puesto que los programas pueden utilizar directamente las versiones actualizadas sin necesidad de volver a ser enlazados.</p>
</div>
<div class="paragraph">
<p>Puesto que durante la compilaciÃ³n de una librerÃ­a no se conoce la regiÃ³n que va a ocupar dentro de los espacios de direcciones virtuales de los distintos procesos que la van a utilizar:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Para las librerÃ­as <em>el compilador debe generar cÃ³digo PIC (Position-Independent Code) o independiente de la posiciÃ³n</em>.
Este tipo de cÃ³digo se puede ejecutar adecuadamente y sin modificaciones independientemente del lugar de la memoria donde estÃ© ubicado.
Esto permite reducir el consumo de memoria principal compartiendo las regiones de memoria fÃ­sica asignadas al cÃ³digo de una misma librerÃ­a en los distintos procesos que la utilizan.</p>
</li>
<li>
<p>En los sistemas operativos donde no se usa cÃ³digo PIC el compilador debe generar cÃ³digo reubicable <em>para que la reubicaciÃ³n de las direcciones virtuales de las librerÃ­as dinÃ¡micas se haga en tiempo de carga</em>.
Esto aumenta el tiempo de carga de las librerÃ­as y sÃ³lo permite que compartan memoria fÃ­sica el cÃ³digo de las instancias de una misma librerÃ­a que ha sido cargado en la misma regiÃ³n del espacio de direcciones virtual en los distintos procesos que la utilizan.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Habitualmente las librerÃ­as incluyen informaciÃ³n acerca de la versiÃ³n que puede ser utilizada para evitar que los programas se ejecuten con versiones incompatibles de las mismas, o para permitir que haya mÃ¡s de una versiÃ³n de cada librerÃ­a en memoria</em>.
AsÃ­ los viejos programas se pueden ejecutar con las viejas versiones de las mismas, o con versiones actualizadas pero compatibles, mientras los nuevos programas se ejecuten con las versiones mÃ¡s recientes e incompatibles con los viejos programas.
A este sistema se lo conoce como <strong>librerÃ­as compartidas</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_asignaciÃ³n_de_memoria_contigua">15.3. AsignaciÃ³n de memoria contigua</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_paginaciÃ³n">16. PaginaciÃ³n</h2>
<div class="sectionbody">
<div class="paragraph">
<p>El mapeo entre direcciones virtuales y fÃ­sicas puede realizarse de diversas maneras.
La forma mÃ¡s extendida es <em>la <strong>paginaciÃ³n</strong>, que no es sino un esquema de gestiÃ³n de la memoria que permite que el espacio de direcciones fÃ­sico de un proceso no sea continuo</em>.</p>
</div>
<div class="sect2">
<h3 id="_mÃ©todo_bÃ¡sico">16.1. MÃ©todo bÃ¡sico</h3>
<div class="paragraph">
<p>En la paginaciÃ³n <em>la memoria fÃ­sica se divide en bloques de tamaÃ±o fijo denominados <strong>marcos</strong>, mientras que el espacio de direcciones virtual se divide en bloques del mismo tamaÃ±o que los marcos, denominados <strong>pÃ¡ginas</strong></em>.
Cuando un proceso va a ser ejecutado sus pÃ¡ginas son cargadas desde el almacenamiento secundario en marcos libres de la memoria fÃ­sica.</p>
</div>
<div class="paragraph">
<p>La paginaciÃ³n es una forma de <em>reubicaciÃ³n de las direcciones en tiempo de ejecuciÃ³n</em> donde la transformaciÃ³n de las direcciones virtuales en direcciones fÃ­sicas se realiza de la siguiente manera (vÃ©ase la ):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Cada direcciÃ³n virtual generada por la CPU es divida en dos partes</em>: un <strong>nÃºmero de pÃ¡gina</strong> \$p\$ y un <strong>desplazamiento</strong> \$d\$.</p>
</li>
<li>
<p><em>El nÃºmero de pÃ¡gina es utilizado por la MMU para indexar la <strong>tabla de pÃ¡ginas</strong></em>, que contiene el <strong>nÃºmero de marco</strong> \$f\$ de cada pÃ¡gina en la memoria fÃ­sica.</p>
</li>
<li>
<p><em>El nÃºmero de marco \$f\$ es combinado con el <strong>desplazamiento</strong> \$d\$</em> para generar la direcciÃ³n fÃ­sica que va a ser enviada por el bus de direcciones hacia la memoria.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El tamaÃ±o de las pÃ¡ginas ây el de los marcosâ viene definido por el hardware y normalmente es un nÃºmero entero potencia de 2 que puede variar entre 512 bytes y 16 MB, dependiendo de la arquitectura.
Es decir, si el espacio de direcciones es de \$2^m\$ y el tamaÃ±o de pÃ¡gina es de \$2^n\$, los \$m - n\$ bits de mayor orden del espacio de direcciones indican el <em>nÃºmero de pÃ¡gina</em>, mientras que los \$n\$ bits de menor orden indican el <em>desplazamiento</em> (vÃ©ase la )</p>
</div>
<div class="sect3">
<h4 id="_desde_el_punto_de_vista_de_los_procesos">16.1.1. Desde el punto de vista de los procesos</h4>
<div class="paragraph">
<p>Cada pÃ¡gina de un proceso requiere un marco.
Por tanto, cuando un proceso llega al sistema:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Si el proceso requiere n pÃ¡ginas, el sistema operativo debe escoger n marcos</em>.
Estos marcos son tomados de la <em>lista de marcos libres</em> que debe mantener el sistema.
Puesto que son escogidos de allÃ­ donde los haya libres, <em>el espacio de direcciones fÃ­sico puede no ser contiguo aunque los procesos vean un espacio de direcciones virtual contiguo</em>.</p>
</li>
<li>
<p>Los marcos seleccionados son asignados al proceso y <em>cada pÃ¡gina del proceso es cargada en uno</em> de dichos marcos.</p>
</li>
<li>
<p><em>La tabla de pÃ¡ginas es actualizada</em> de manera que en la entrada de cada pÃ¡gina del proceso se pone el nÃºmero de marco correspondiente.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Un aspecto importante de la paginaciÃ³n es la diferencia entre como ven los proceso la memoria y como es realmente la memoria fÃ­sica.
Cada proceso ve la memoria como un espacio Ãºnico que lo contiene sÃ³lo a Ã©l.
Sin embargo la realidad es que el programa estÃ¡ disperso por la memoria fÃ­sica, que ademÃ¡s puede almacenar a otros programas.
<em>Esto es posible porque en cada momento la tabla de pÃ¡ginas sÃ³lo contiene las pÃ¡ginas del proceso actual</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_desde_el_punto_de_vista_del_sistema_operativo">16.1.2. Desde el punto de vista del sistema operativo</h4>
<div class="paragraph">
<p>Puesto que el sistema operativo es quiÃ©n gestiona la memoria fÃ­sica, <em>Ã©ste debe mantenerse al tanto de las particularidades de su uso</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Que marcos estÃ¡n asignados y a que pÃ¡gina de que proceso o procesos</em>.</p>
</li>
<li>
<p><em>Que marcos estÃ¡n disponibles</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Toda esta informaciÃ³n generalmente se guarda en una estructura denominada la <em><strong>tabla de marcos</strong>, que tiene una entrada por cada marco de la memoria fÃ­sica</em>.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s <em>el sistema operativo debe mantener una copia de la tabla de pÃ¡ginas para cada proceso en el PCB</em>, igual que mantiene una copia del contador de programa y del contenido de los registros de la CPU.
Esta copia es utilizada:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Por <em>el asignador para sustituir la tabla de pÃ¡ginas hardware cuando realiza un cambio de contexto</em>.
Por lo tanto el uso de la paginaciÃ³n incrementa el tiempo del cambio de contexto.</p>
</li>
<li>
<p><em>Para el mapeo manual de direcciones virtuales en fÃ­sicas</em>.
Por ejemplo, cuando un proceso realiza una llamada al sistema para realizar una operaciÃ³n de E/S y proporciona una direcciÃ³n como parÃ¡metro, dicha direcciÃ³n debe ser mapeada manualmente para producir la direcciÃ³n fÃ­sica correspondiente que serÃ¡ utilizada por el hardware para realizar la operaciÃ³n.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_tamaÃ±o_de_las_pÃ¡ginas">16.1.3. TamaÃ±o de las pÃ¡ginas</h4>
<div class="paragraph">
<p>Una decisiÃ³n de diseÃ±o importante es escoger el tamaÃ±o de las pÃ¡ginas adecuado:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Con pÃ¡ginas mÃ¡s pequeÃ±as esperamos tener menos fragmentaciÃ³n interna</em>.
Los marcos son asignados como unidades indivisibles, por lo que si los requerimientos de memoria de un procesos no coinciden con un lÃ­mite de pÃ¡ginas el Ãºltimo marco asignado no serÃ­a utilizado completamente (en ocasiones incluso se podrÃ­a desperdiciar un marco completo).
A ese fenÃ³meno se lo conoce como <em>fragmentaciÃ³n interna</em></p>
</li>
<li>
<p><em>Con pÃ¡ginas mÃ¡s grande se pierde menos espacio en la tabla de pÃ¡ginas</em>.
No olvidemos que cuanto mÃ¡s pequeÃ±as son las pÃ¡ginas mÃ¡s pÃ¡ginas son necesarias y, por tanto, mÃ¡s entradas en la tabla de pÃ¡ginas se necesitan.
AdemÃ¡s <em>la E/S es mÃ¡s eficiente cuanto mÃ¡s datos son transferidos en cada operaciÃ³n</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los tamaÃ±os de pÃ¡ginas tÃ­picos son 4 y 8 KB.
Por ejemplo, normalmente cada entrada en la tabla de paginas es de 4 bytes âaunque esto tambiÃ©n puede variarâ.
Eso significa que cada entrada puede direccionar a uno de los 2<sup>32</sup> marcos de la memoria fÃ­sica.
Si suponemos que el tamaÃ±o de cada marco es de 4 KB, podemos determinar que el sistema es capaz de direccionar 2<sup>44</sup> bytes âo 16 TBâ de memoria fÃ­sica, para lo que es necesario disponer de una tabla de pÃ¡ginas de 4 MB.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_soporte_hardware_de_la_tabla_de_pÃ¡ginas">16.2. Soporte hardware de la tabla de pÃ¡ginas</h3>
<div class="paragraph">
<p>La implementaciÃ³n en hardware de la tabla de pÃ¡ginas puede realizarse de diversas maneras:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Como un conjunto de registros dedicados de la CPU</em>.
Es decir, la tabla de pÃ¡ginas del proceso actual es alojada dentro de la propia CPU, en unos registros destinados a tal fin.</p>
</li>
<li>
<p><em>Almacenada en la memoria</em>.
Es decir, la tabla de pÃ¡ginas del proceso actual es alojada en la memoria, normalmente en un formato definido por la CPU.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Debido a la velocidad de los registros de la CPU <em>la implementaciÃ³n como conjunto de registros es la mÃ¡s eficiente.</em> Sin embargo <em>sÃ³lo puede ser utilizado para tablas de pÃ¡ginas razonablemente pequeÃ±as</em>.
El DEC PDP-11 âpara el que se diseÃ±o el primer UNIXâ es un ejemplo de sistema con esta implementaciÃ³n.
En el mismo se utilizaba un espacio de direcciones de 16 bits y un tamaÃ±o de pÃ¡ginas de 8 KB, por lo que sÃ³lo necesitaba 8 registros dedicados para alojar toda tabla de pÃ¡ginas.</p>
</div>
<div class="paragraph">
<p>En los sistemas modernos se utilizan tablas de pÃ¡ginas muchos mÃ¡s grandes âde un millÃ³n de entradas o mÃ¡sâ que difÃ­cilmente pueden alojarse en registros dentro de la CPU, ya que alojar tablas de pÃ¡ginas de mÃ¡s de 256 entradas es muy costoso.
Por eso los sistemas actuales almacenan la tabla de pÃ¡ginas del proceso en ejecuciÃ³n en la memoria._ Eso permite disponer tablas de pÃ¡ginas de gran tamaÃ±o_ aunque a costa de <em>necesitar dos acceso a la memoria fÃ­sica por cada acceso a una palabra de la memoria virtual<sup class="footnote">[<a id="_footnoteref_18" class="footnote" href="#_footnotedef_18" title="View footnote.">18</a>]</sup></em>.</p>
</div>
<div class="paragraph">
<p>Para que la MMU pueda conocer la ubicaciÃ³n de la tabla de pÃ¡ginas durante la traducciÃ³n de las direcciones, <em>la CPU debe disponer de un registro âel <strong>PTBR</strong> (Page-Table Base Register)â donde se guarda la direcciÃ³n de la tabla de pÃ¡ginas actual</em>.
AdemÃ¡s esto permite que el cambio de contexto sea mÃ¡s rÃ¡pido ârespecto al uso de registros para almacenar la tabla de pÃ¡ginasâ puesto que sÃ³lo es necesario carga un Ãºnico registro mÃ¡s âel PTBRâ durante el mismo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_protecciÃ³n">16.3. ProtecciÃ³n</h3>
<div class="paragraph">
<p>La protecciÃ³n de las pÃ¡ginas <em>se consigue mediante unos <strong>bits de protecciÃ³n</strong> asociados a cada entrada de la tabla de pÃ¡ginas</em> y normalmente almacenados en la misma.
Estos bits pueden ser:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Solo lectura</strong>.</p>
</li>
<li>
<p><strong>Lectura â Escritura</strong>.
En algunos sistemas hay un bit especÃ­fico para este permiso, mientras que en otros se utilizan bit separados como: <em>lectura</em>, <em>escritura</em> y <em>ejecuciÃ³n</em>.</p>
</li>
<li>
<p><strong>SÃ³lo ejecuciÃ³n</strong>.
Que no existen en todas las plataformas.
Por ejemplo, la familia Intel x86 careciÃ³ de esta caracterÃ­stica hasta que AMD la incluyÃ³ en su arquitectura AMD64, lo que obligÃ³ a Intel a incluirla en las versiones mÃ¡s modernas de su Pentium IV.
El bit âque para ser exacto indica <em>no ejecuciÃ³n</em>â fue introducido para evitar cierto tipo de ataques de seguridad.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Durante la traducciÃ³n de las direcciones la MMU comprueba que el tipo de acceso sea vÃ¡lido.
Si esto no es asÃ­, se genera una excepciÃ³n de violaciÃ³n de protecciÃ³n de memoria, dado que el acceso en un modo o autorizado se considera una instrucciones privilegiada.
Normalmente el sistema operativo responde a dicha excepciÃ³n terminando el proceso que la generÃ³.</p>
</div>
<div class="paragraph">
<p><em>AdemÃ¡s de los bits comentados se suele aÃ±adir a cada entrada un <strong>bit de vÃ¡lido</strong></em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Cuando una pÃ¡gina es vÃ¡lida</em>, la pagina asociada estÃ¡ en el espacio de direcciones virtual del proceso.
Es decir, <em>es legal</em>.</p>
</li>
<li>
<p><em>Cuando la pÃ¡gina no es invÃ¡lida</em>, la pÃ¡gina no estÃ¡ asociada al espacio de direcciones virtual del proceso.
Es decir, <em>es ilegal</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>El sistema operativo puede utilizar este bit para permitir o denegar el acceso a una pÃ¡gina</em>, por ejemplo porque no le ha asignado un marco ya que no estÃ¡ siendo utilizada por el proceso.
Al igual que con los bits de permisos, los intentos de acceso a una pÃ¡gina ilegal generan una excepciÃ³n.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en la vemos el espacio de direcciones virtual y la tabla de pÃ¡ginas de un proceso de 5096 bytes en un sistema con pÃ¡ginas de 1024 bytes.
Puesto que el proceso no ocupa todo el espacio de direcciones, sÃ³lo las direcciones de la 0 a la 5119 son vÃ¡lidas.
En dicho ejemplo podemos apreciar varios fenÃ³menos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Debido a la fragmentaciÃ³n interna las direcciones de la 5097 a la 5119 son vÃ¡lidas, aunque el proceso solo ocupe hasta la 5096.
Es decir, se estÃ¡ asignando al proceso una porciÃ³n de memoria que no necesita.</p>
</li>
<li>
<p>Las pÃ¡ginas ocupadas por el proceso son vÃ¡lidas.
Pero todas las paginas en direcciones por encima de la 5119 estÃ¡n marcadas como ilegales.
<em>AsÃ­ el sistema operativo no tiene que asignar marcos a pÃ¡ginas no utilizadas por el proceso</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En general los procesos sÃ³lo necesitan una porciÃ³n muy pequeÃ±a de su espacio de direcciones virtual.
En esos casos es un desperdicio de memoria crear y almacenar un tabla de pÃ¡gina completa con una entrada para cada pÃ¡gina del espacio de direcciones.
Para evitarlo <em>en algunas CPU existe el <strong>PTLR</strong> (Page-Table Length Register) que se utiliza para indicar el tamaÃ±o actual de la tabla de pÃ¡gina</em>.
Este valor es comparado por la MMU durante la traducciÃ³n con el nÃºmero de pÃ¡gina de cada direcciÃ³n virtual, de manera que las pÃ¡ginas con entradas mÃ¡s allÃ¡ de la Ãºltima almacenada en la tabla son consideradas ilegales.</p>
</div>
<div class="paragraph">
<p>En realidad, tal y como vimos en el <a href="#_el_proceso">Apartado 9.1</a>, <em>lo mÃ¡s comÃºn es que los procesos tengan un espacio de direcciones virtual disperso como el de la _.
En la misma podemos observar como el sistema operativo ubica los diferentes componentes del proceso de una forma particular dentro del espacio de direcciones virtual.
Este esquema permite que tanto el _montÃ³n</em> âa travÃ©s del mecanismo de asignaciÃ³n dinÃ¡mica de memoria de <code>malloc()</code>â como la pila puedan extenderse, en base a las necesidades de memoria que tenga el proceso, sobre la regiÃ³n de memoria no ocupada.
Esa regiÃ³n tambiÃ©n puede ser parcialmente ocupada por librerÃ­as de enlace dinÃ¡mico o por otros objetos compartidos que sean necesitados durante la ejecuciÃ³n del proceso.
<em>En cualquier caso las pÃ¡ginas de dicha regiÃ³n forman parte del espacio de direcciones virtual pero no tienen marcos de memoria fÃ­sica asignados, en tanto en cuanto el proceso no las vaya a utilizar.
La falta de marco es indicada por el sistema operativo utilizando el bit de vÃ¡lido para denegar el acceso</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pÃ¡ginas_compartidas">16.4. PÃ¡ginas compartidas</h3>
<div class="paragraph">
<p>Una de las ventajas importantes de la paginaciÃ³n es la posibilidad de compartir pÃ¡ginas entre procesos.
Para conseguir esto basta con que <em>las <strong>pÃ¡ginas compartidas</strong> de los distintos procesos tengan asignadas un mismo marco</em>.
Esto permite, por ejemplo, que los procesos de un mismo programa puedan compartir las pÃ¡ginas de cÃ³digo o los datos de sÃ³lo lectura con el fin de ahorrar memoria.
TambiÃ©n permite compartir las pÃ¡ginas de cÃ³digo de una librerÃ­a compartida enlazada a diferentes procesos.</p>
</div>
<div class="paragraph">
<p>Compartir pÃ¡ginas no sÃ³lo permite ahorrar memoria pues en <em>los sistemas operativos modernos la memoria compartida (vÃ©ase el <a href="#_memoria_compartida">CapÃ­tulo 11</a>) se implementa mediante pÃ¡ginas compartidas</em>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_paginaciÃ³n_bajo_demanda">17. PaginaciÃ³n bajo demanda</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La <em>paginaciÃ³n bajo demanda</em> es la tÃ©cnica con la que frecuentemente se implementa la <em>memoria virtual</em> en los sistemas con paginaciÃ³n.
El concepto de <em>memoria virtual</em> no debe confundirse con el de <em>espacio de direcciones virtual</em>, aunque estÃ¡n relacionados puesto que <em>el que exista separaciÃ³n entre la memoria fÃ­sica y la manera en la que los procesos perciben la memoria es un requisito para poder implementar la memoria virtual</em>.</p>
</div>
<div class="sect2">
<h3 id="_memoria_virtual">17.1. Memoria virtual</h3>
<div class="paragraph">
<p><em>La <strong>memoria virtual</strong> es una tÃ©cnica que permite la ejecuciÃ³n de procesos sin que Ã©stos tengan que ser cargados completamente en la memoria</em>.</p>
</div>
<div class="paragraph">
<p>Los programas suelen tener partes de cÃ³digo que rara vez son ejecutadas, por ejemplo las funciones para manejar condiciones de error que, aunque Ãºtiles, generalmente nunca son invocadas.
TambiÃ©n es frecuente que se reserve mÃ¡s memoria para datos de lo que realmente es necesario.
Por ejemplo muchos programadores tiene la costumbres de hacer cosas tales como declarar un <em>array</em> de 1000 por 1000 elementos cuando realmente sÃ³lo necesitan 100 por 100.
Teniendo todo esto en cuenta y con el fin de mejorar el aprovechamiento de la memoria, parece que serÃ­a interesante no tener que cargar todas las porciones de los procesos pero de manera que Ã©stos aun asÃ­ puedan seguir siendo ejecutados.
Eso es exactamente lo que proporciona la memoria virtual, en general, y la paginaciÃ³n bajo demanda, en particular, para los sistemas que soportan paginaciÃ³n.</p>
</div>
<div class="paragraph">
<p>La habilidad de ejecutar un proceso cargado parcialmente en memoria proporciona algunos beneficios importantes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Un programa no estarÃ¡ nunca mÃ¡s limitado por la cantidad de memoria disponible</em>.
Es decir, los desarrolladores pueden escribir programas considerando que disponen de un espacio de direcciones virtual extremadamente grande y sin considerar la cantidad de memoria realmente disponible.
Es importante no olvidar que sin memoria virtual para que un proceso pueda ser ejecutado debe estar completamente cargado en la memoria.</p>
</li>
<li>
<p>Puesto que cada programa ocupa menos memoria <em>mÃ¡s programas se pueden ejecutar al mismo tiempo, con el correspondiente incremento en el uso de la CPU y en el rendimiento del sistema</em> y sin efectos negativos en el tiempo de respuesta y en el de ejecuciÃ³n.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_mÃ©todo_bÃ¡sico_2">17.2. MÃ©todo bÃ¡sico</h3>
<div class="paragraph">
<p><em>En la paginaciÃ³n bajo demanda las pÃ¡ginas individuales, en las que se dividen los espacios de direcciones virtuales de los diferentes procesos, pueden ser sacadas de la memoria de manera temporal y copiadas a un almacenamiento de respaldo, para posteriormente volver a ser traÃ­das a la memoria cuando son necesitadas por su proceso</em>.
A este proceso de guardado y recuperaciÃ³n de las pÃ¡ginas sobre el almacenamiento de respaldo se lo denomina <strong>intercambio</strong> o <em>swapping</em> y es llevado a cabo por un componente del sistema operativo denominado el <em>paginador</em>.</p>
</div>
<div class="paragraph">
<p>Para que se puedan cargar las pÃ¡ginas cuando son necesitadas por su proceso hace falta que el paginador sepa cuando lo son.
Eso requiere que el hardware proporcione algÃºn tipo de soporte, por ejemplo incorporando un <strong>bit de vÃ¡lido</strong> a la entrada de cada pÃ¡gina en la tabla de pÃ¡ginas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Cuando el bit de vÃ¡lido estÃ¡ a 1 la pÃ¡gina es legal y estÃ¡ en la memoria</em>.
Es decir, la pÃ¡gina existe en el espacio de direcciones virtual del proceso y tiene asignado un marco de memoria fÃ­sica.</p>
</li>
<li>
<p><em>Cuando el bit de vÃ¡lido estÃ¡ a 0</em> pueden ocurrir varias cosas:</p>
<div class="ulist">
<ul>
<li>
<p><em>La pÃ¡gina es legal pero esta almacenada en disco</em> y no en la memoria.</p>
</li>
<li>
<p><em>La pÃ¡gina no es legal</em>.
Es decir, no existe en el espacio de direcciones virtual del proceso.
Esto puede ser debido a que la pÃ¡gina estÃ© en un hueco del espacio de direcciones âen una regiÃ³n que no estÃ¡ siendo utilizadaâ por lo que el sistema operativo no le ha asignado espacio de almacenamiento ni en disco ni en la memoria.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Si un proceso accede a una pÃ¡gina <em>residente en memoria</em> âmarcada como vÃ¡lidaâ no ocurre nada y la instrucciÃ³n se ejecuta con normalidad.
Pero si accede a una pÃ¡gina marcada como invÃ¡lida:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Al intentar acceder a la pÃ¡gina la MMU comprueba el bit de vÃ¡lido y <em>genera una excepciÃ³n de fallo pÃ¡gina al estar marcada como invÃ¡lida</em>.
Dicha excepciÃ³n es capturada por el sistema operativo.</p>
</li>
<li>
<p><em>El sistema operativo comprueba en una tabla interna si la pÃ¡gina es legal o no</em>.
Es decir, si la pÃ¡gina realmente no pertenece al espacio de direcciones virtual del proceso o si pertenece pero estÃ¡ almacenada en el disco.
Esta tabla interna suele almacenarse en el PCB del proceso como parte de la informaciÃ³n de gestiÃ³n de la memoria.</p>
</li>
<li>
<p><em>Si la pÃ¡gina es ilegal, el proceso ha cometido un error y debe ser terminado</em>.
En UNIX, por ejemplo, el sistema envÃ­a al proceso una seÃ±al de <em>violaciÃ³n de segmento</em> que lo obliga a terminar.</p>
</li>
<li>
<p><em>Si la pÃ¡gina es legal debe ser cargada desde el disco</em>:</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>..
<em>El nÃºcleo debe buscar un marco de memoria libre</em> que, por ejemplo, se puede escoger de la lista de marcos libres del sistema.</p>
</div>
<div class="paragraph">
<p>..
<em>Se solicita una operaciÃ³n de disco para leer la pÃ¡gina deseada en el marco asignado</em>.
Puesto que no resulta eficiente mantener la CPU ocupada mientras la pÃ¡gina es recuperada desde el disco, el sistema debe solicitar la lectura de la pÃ¡gina y poner al proceso en estado de espera.</p>
</div>
<div class="paragraph">
<p>..
<em>Cuando la lectura del disco haya terminado se debe modificar la tabla interna, antes mencionada, y la tabla de pÃ¡ginas para indicar que la pÃ¡gina estÃ¡ en la memoria</em>.</p>
</div>
<div class="paragraph">
<p>..
<em>Reiniciar la instrucciÃ³n que fue interrumpida por la excepciÃ³n</em>.
Generalmente esto se hace colocando el proceso nuevamente en la cola de preparados y dejando que el asignador lo reinicie cuando sea escogido por el planificador de la CPU.</p>
</div>
<div class="paragraph">
<p>Un caso extremo de la paginaciÃ³n bajo demanda es la <strong>paginaciÃ³n bajo demanda pura</strong>.
En ella <em>la ejecuciÃ³n de un proceso se inicia sin cargar ninguna pÃ¡gina en la memoria</em>.
Cuando el sistema operativo sitÃºa al contador de programas en la primera instrucciÃ³n del proceso âque es una pÃ¡gina no residente en memoriaâ se genera inmediatamente un fallo de pÃ¡gina.
La pÃ¡gina es cargada en la memoria âtal y como hemos descrito anteriormenteâ y el proceso continua ejecutÃ¡ndose, fallando cuando sea necesario con cada pÃ¡gina que necesite y no estÃ© cargada.
Las principales ventajas de la <em>paginaciÃ³n bajo demanda pura</em> son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nunca se traerÃ¡ desde el disco una pÃ¡gina que no sea necesaria.</p>
</li>
<li>
<p>El inicio de la ejecuciÃ³n de un proceso es mucho mÃ¡s rÃ¡pido que si se cargara todo el proceso desde el principio.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_requerimientos_de_la_paginaciÃ³n_bajo_demanda">17.3. Requerimientos de la paginaciÃ³n bajo demanda</h3>
<div class="paragraph">
<p>Los requerimientos hardware para que un sistema operativo pueda soportar la paginaciÃ³n bajo demanda son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Tabla de pÃ¡ginas con habilidad para marcar entradas invÃ¡lidas</em>, ya sea utilizando un bit especÃ­fico o con valores especiales en los bits de protecciÃ³n.</p>
</li>
<li>
<p><em>Disponibilidad de una memoria secundaria</em>.
En esta memoria se guardan las pÃ¡ginas que no estÃ¡n presentes en la memoria principal.
Normalmente se trata de un disco conocido como <strong>dispositivo de intercambio</strong>, mientras que la secciÃ³n de disco utilizada concretamente para dicho propÃ³sito se conoce como <strong>espacio de intercambio</strong> o <em>swap</em>.</p>
</li>
<li>
<p><em>Posibilidad de reiniciar cualquier instrucciÃ³n</em> despuÃ©s de un fallo de pÃ¡gina.
En la mayor parte de los casos esta funcionalidad es sencilla de conseguir.
Sin embargo, la mayor dificultad proviene de las instrucciones que pueden modificar diferentes posiciones de la memoria, como aquellas pensadas para mover bloques de bytes o palabras.
En el caso de que el bloque de origen o de destino atraviese un borde de pÃ¡gina, la instrucciÃ³n serÃ­a interrumpida cuando la operaciÃ³n solo haya sido realizada parcialmente.
Si ademÃ¡s ambos bloques se superpusieran, no se podrÃ­a reiniciar la instrucciÃ³n completa.
Las posibles soluciones a este problema deben ser implementadas en el hardware.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_rendimiento_de_la_paginaciÃ³n_bajo_demanda">17.4. Rendimiento de la paginaciÃ³n bajo demanda</h3>
<div class="paragraph">
<p>Indudablemente el rendimiento de un sistema con paginaciÃ³n bajo demanda se ve afectado por el nÃºmero de fallos de pÃ¡ginas.
En el peor de los casos, en cada instrucciÃ³n un proceso puede intentar acceder a una pÃ¡gina distinta empeorando notablemente el rendimiento.
Sin embargo esto no ocurre puesto que los programas tienden a tener localidad de referencia (vÃ©ase el <a href="#_hiperpaginaciÃ³n">Apartado 17.9</a>).</p>
</div>
<div class="sect3">
<h4 id="_tiempo_de_acceso_efectivo">17.4.1. Tiempo de acceso efectivo</h4>
<div class="paragraph">
<p>El rendimiento de un sistema con paginaciÃ³n bajo demanda estÃ¡ relacionado con el concepto de <strong>tiempo de acceso efectivo</strong> a la memoria.
<em>Ãste intenta estimar el tiempo que realmente se tarda en acceder a la memoria teniendo en cuenta mecanismos del sistema operativo como la paginaciÃ³n bajo demanda</em>.</p>
</div>
<div class="paragraph">
<p>En muchos sistemas informÃ¡ticos el <strong>tiempo de acceso</strong> âa la memoria fÃ­sicaâ \$T_m\$ es de unos pocos nanosegundos.
Por lo tanto, si no hay fallos de pÃ¡gina, el <em>tiempo de acceso efectivo</em> es igual al tiempo de acceso a la memoria.
Pero si hay fallos de pÃ¡gina, primero es necesario leer la pÃ¡gina del disco, por lo que el <em>tiempo de acceso efectivo</em> a la memoria es mayor.</p>
</div>
<div class="paragraph">
<p>Supongamos que conocemos la probabilidad \$p\$ de que ocurra un fallo de pÃ¡gina.
_El tiempo de acceso efectivo se podrÃ­a calcular como una media ponderada por la probabilidad p del tiempo de acceso a la memoria \$T_m\$ mas el tiempo necesario para gestionar cada fallo de pÃ¡gina âo <strong>tiempo de fallo de pÃ¡gina</strong>â \$T_(fp)\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$T_(em)=(1-p)*T_m+p T_(fp)\$
</div>
</div>
<div class="paragraph">
<p>Por tanto, para calcular el <em>tiempo de acceso efectivo</em> \$T_(em)\$ necesitamos estimar el <em>tiempo de fallo de pÃ¡gina</em> \$T_(fp)\$, que se consume fundamentalmente en:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Servir la excepciÃ³n de fallo de pÃ¡gina</em>.
Esto incluye capturar la interrupciÃ³n, salvar los registros y el estado del proceso, determinar que la interrupciÃ³n es debida a una excepciÃ³n de fallo de pÃ¡gina, comprobar si la pÃ¡gina es legal y determinar la localizaciÃ³n de la misma en el disco.
Aproximadamente, en realizar esta tarea el sistema puede tardar de 1 a 100Î¼s.</p>
</li>
<li>
<p><em>Leer la pÃ¡gina en un marco libre</em>.
En esta tarea se puede tardar alrededor de 8ms, pero este tiempo puede ser mucho mayor si el dispositivo estÃ¡ ocupado y se debe esperar a que se realicen otras operaciones.</p>
</li>
<li>
<p><em>Reiniciar el proceso</em>.
Si incluimos el tiempo de espera en la cola de preparados, se puede tardar entre 1 y 100Î¼s.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como se puede apreciar <em>la mayor parte del tiempo de fallo de pÃ¡gina es debido al tiempo requerido para acceder al dispositivo de intercambio</em>.</p>
</div>
<div class="paragraph">
<p>Para ilustrar el cÃ¡lculo del <em>tiempo de acceso efectivo</em> a la memoria: sÃ³lo vamos a considerar el tiempo requerido para acceder al dispositivo de intercambio âignorando las otras tareas a realizar durante el fallo de pÃ¡ginaâ vamos suponer que el <em>tiempo de acceso</em> a la memoria \$T_m\$ es de 200 ns y que la probabilidad \$p\$ es muy pequeÃ±a (es decir, \$p âª 1\$):</p>
</div>
<div class="stemblock">
<div class="content">
\${:(T_(em),=,(1-p)*200ns+p * 8ms),
(      ,=,(1-p)*200ns+p * 8000000ns),
( ,approx, 200ns+7999800ns * p ):}\$
</div>
</div>
<div class="paragraph">
<p>Como se puede apreciar el <em>tiempo de acceso efectivo</em> es proporcional a la <strong>tasa de fallos de pÃ¡gina</strong>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[stem]
++++
T_(em) approx T_(m)+r_(fp)
++++</pre>
</div>
</div>
<div class="paragraph">
<p>Por ejemplo, si un proceso causa un fallo de pÃ¡gina en uno de cada 1000 accesos (\$p = 0,001\$), el <em>tiempo de acceso efectivo</em> es de 8,2 ms.
Es decir, el rendimiento del sistema es 40 veces inferior debido a la paginaciÃ³n bajo demanda.
Por tanto <em>es necesario mantener la tasa de fallos de pÃ¡gina lo mÃ¡s baja posible para mantener un rendimiento adecuado</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_manejo_y_uso_del_espacio_de_intercambio">17.4.2. Manejo y uso del espacio de intercambio</h4>
<div class="paragraph">
<p><em>Otro aspecto fundamental que afecta al rendimiento de la paginaciÃ³n bajo demanda es el uso del espacio de intercambio</em>.
Cuando un proceso genera un fallo de pÃ¡gina el sistema operativo debe recuperar la pÃ¡gina de allÃ­ donde estÃ© almacenada.
Si esto ocurre al principio de la ejecuciÃ³n, ese lugar seguramente serÃ¡ el archivo que contiene la imagen binara del programa, pues es donde se encuentran las pÃ¡ginas en su estado inicial.
Sin embargo el acceso al espacio de intercambio es mucho mÃ¡s eficiente que el acceso a un sistema de archivos, incluso aunque el primero estÃ© almacenado dentro de un archivo de gran tamaÃ±o.
Esto es debido a que los datos se organizan en bloques contiguos de gran tamaÃ±o, se evitan las bÃºsquedas de archivos y las indirecciones en la asignaciÃ³n de espacio.
Por ello debemos plantearnos que hacer con las imÃ¡genes de los programas que van a ser ejecutados.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se puede mejorar el rendimiento <em>copiando en el espacio de intercambio la imagen completa de los programas durante el inicio del proceso, para despuÃ©s realizar la paginaciÃ³n bajo demanda sobre dicha copia</em>.</p>
</li>
<li>
<p>Otra alternativa es <em>cargar las pÃ¡ginas desde el archivo que contiene la imagen cuando son usadas por primera vez pero siendo escritas en el espacio de intercambio cuando dichas pÃ¡ginas tiene que ser reemplazadas</em>.
Esta aproximaciÃ³n garantiza que sÃ³lo las pÃ¡ginas necesarias son leÃ­das desde el sistema de archivos reduciendo el uso de espacio de intercambio, mientras que las siguientes operaciones de intercambio se hacen sobre dicho espacio.</p>
</li>
<li>
<p>TambiÃ©n se puede suponer que el cÃ³digo de los procesos no puede cambiar.
Esto permite <em>utilizar el archivo de la imagen binaria para recargar las pÃ¡ginas de cÃ³digo, lo que tambiÃ©n evita escribirlas cuando son sustituidas.
Sin embargo el espacio de intercambio se sigue utilizando para las pÃ¡ginas que no estÃ¡n directamente asociadas a un archivo, como la pila o el montÃ³n de los procesos</em>.
Este mÃ©todo parece conseguir un buen compromiso entre el tamaÃ±o del espacio de intercambio y el rendimiento.
Por eso se utiliza en la mayor parte de los sistemas operativos modernos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_copy_on_write">17.5. Copy-on-write</h3>
<div class="paragraph">
<p><em>El <strong>copy-on-write</strong> o copia durante la escritura permite la creaciÃ³n rÃ¡pida de nuevos procesos, minimizando la cantidad de pÃ¡ginas que deben ser asignadas a estos</em>.
Para entenderlo es importante recordar que la llamada al sistema <code>fork()</code> crear un proceso hijo cuyo espacio de direcciones es un duplicado del espacio de direcciones del padre.
Indudablemente esto significa que durante la llamada es necesario asignar suficientes marcos de memoria fÃ­sica como para alojar las pÃ¡ginas del nuevo proceso hijo.
El <em>copy-on-write</em> minimiza de la siguiente manera el nÃºmero de marcos que deben ser asignadas al nuevo proceso:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Cuando la llamada al sistema <code>fork()</code> crea el nuevo proceso lo hace de forma que Ã©ste comparta todas sus pÃ¡ginas con las del padre</em> (vÃ©ase la ).
Sin el <em>copy-on-write</em> el <code>fork()</code> tendrÃ­a que asignar marcos de memoria fÃ­sica a el hijo, para a continuaciÃ³n copiar las pÃ¡ginas del padre en ellos.
Sin embargo con el <em>copy-on-write</em> padre e hijo mapean sus pÃ¡ginas en los mismos marcos, evitando tener que asignar memoria libre.</p>
</li>
<li>
<p><em>Las pÃ¡ginas compartidas se marcan como copy-on-write</em>.
Para ello se puede marcar todas las pÃ¡ginas como de <em>solo lectura</em> en la tabla de pÃ¡ginas de ambos procesos y utilizar una tabla interna alojada en el PCB para indicar cuales son realmente de <em>sÃ³lo lectura</em> y cuales estÃ¡n en <em>copy-on-write</em>.
<em>Es importante destacar que realmente sÃ³lo las pÃ¡ginas que pueden ser modificadas se marcan como copy-on-write.</em> Las pÃ¡ginas que no puede ser modificadas âpor ejemplo las que contienen el cÃ³digo ejecutable del programaâ simplemente pueden ser compartidas como de sÃ³lo lectura por los procesos, como hemos comentado anteriormente.</p>
</li>
<li>
<p><em>Si algÃºn proceso intenta escribir en una pÃ¡gina copy-on-write, la MMU genera una excepciÃ³n para notificar el suceso al sistema operativo</em>.
Siguiendo lo indicado en el punto anterior, la excepciÃ³n se originarÃ­a porque la pÃ¡gina estÃ¡ marcada como de <em>solo lectura,</em> por lo que el sistema operativo deberÃ­a comprobar si se trata de un acceso a una pÃ¡gina <em>copy-on-write</em> o a un intento real de escribir en una pÃ¡gina de <em>sÃ³lo lectura</em>.
Para ello el sistema sÃ³lo tendrÃ­a que mirar la tabla interna almacenada en el PCB.
Si se ha intentado escribir en una pÃ¡gina de <em>solo lectura</em>, el proceso ha cometido un error y generalmente debe ser terminado.</p>
</li>
<li>
<p><em>Si el sistema detecta una escritura a una pÃ¡gina de copy-on-write sÃ³lo tiene que copiarla en un marco libre y mapearlo en el espacio de direcciones del proceso</em> (vÃ©ase la ).
Para esto se sustituye la pÃ¡gina compartida por otra que contiene una copia pero que ya no estÃ¡ compartida.
Indudablemente la nueva pÃ¡gina debe ser marcada como de escritura para que en el futuro pueda ser modificada por el proceso.</p>
</li>
<li>
<p><em>La pÃ¡gina original marcada como copy-on-write puede ser marcada como de escritura y no como copy-on-write, pero sÃ³lo si ya no va a seguir siendo compartida</em>.
Esto es asÃ­ porque una pÃ¡gina marcada como <em>copy-on-write</em> puede ser compartida por varios procesos.</p>
</li>
<li>
<p><em>El sistema operativo puede reiniciar el proceso</em>.
A partir de ahora Ã©ste puede escribir en la pÃ¡gina sin afectar al resto de los procesos.
Sin embargo puede seguir compartiendo otras pÃ¡ginas en <em>copy-on-write</em>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El <em>copy-on-write</em> permite ahorrar memoria y tiempo en la creaciÃ³n de los procesos puesto que sÃ³lo se copian las pÃ¡ginas que son modificadas por Ã©stos, por lo que se trata de una tÃ©cnica comÃºn en mÃºltiples sistemas operativos, como por ejemplo Microsoft Windows, Linux y Solaris.</p>
</div>
<div class="paragraph">
<p>El <em>copy-on-write</em> <em>es especialmente interesante si a continuaciÃ³n se va a utilizar la llamada al sistema exec() puesto que si es asÃ­ copiar el espacio de direcciones completo es una pÃ©rdida de tiempo</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_archivos_mapeados_en_memoria">17.6. Archivos mapeados en memoria</h3>
<div class="paragraph">
<p><em>Los <strong>archivos mapeados en memoria</strong> permiten acceder a un archivo como parte del espacio de direcciones virtuales de un proceso</em>.
Algunas de las caracterÃ­sticas de esta tÃ©cnica son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando una regiÃ³n del espacio de direcciones queda marcada para ser mapeada sobre una regiÃ³n de un archivo <em>se utiliza una estrategia similar a la comentada para el mÃ©todo bÃ¡sico de la paginaciÃ³n bajo demanda.
La diferencia es que las pÃ¡ginas son cargadas desde dicho archivo y no desde el espacio de intercambio</em>.
Es decir, en un primer acceso a una pÃ¡gina mapeada se produce un fallo de pÃ¡gina que es resuelto por el sistema operativo leyendo una porciÃ³n del archivo en el marco asignado a la pÃ¡gina.</p>
</li>
<li>
<p>Esto significa que <em>la lectura y escritura del archivo se realiza a travÃ©s de lecturas y escrituras en la memoria</em>, lo que simplifica el acceso y elimina el costo adicional de las llamadas al sistema: <code>read()</code>, <code>write()</code>, etc.</p>
</li>
<li>
<p><em>Las escrituras en disco se suelen realizar de forma asÃ­ncrona</em>.
Para ello el sistema operativo comprueba periÃ³dicamente las pÃ¡ginas modificadas y las escribe en disco.</p>
</li>
<li>
<p><em>Los marcos utilizados en el mapeo pueden ser compartidos, lo que permite compartir los datos de los archivo</em>.
AdemÃ¡s se puede incluir soporte de <em>copy-on-write</em>, lo que permite a los procesos compartir un archivo en modo de sÃ³lo lectura pero disponiendo de sus propias copias de aquellas pÃ¡ginas que modifiquen.
Indudablemente para que los procesos puedan compartir datos es necesario que exista algÃºn tipo de coordinaciÃ³n (vÃ©ase el <a href="#_sincronizaciÃ³n">CapÃ­tulo 13</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Algunos sistemas operativos ofrecen el servicio de mapeo de archivos en la memoria sÃ³lo a travÃ©s de una llamada al sistema concreta, permitiendo utilizar las llamadas estÃ¡ndar â<code>read()</code>, <code>write()</code>, etc.â para hacer uso de la E/S tradicional.
Sin embargo <em>muchos sistemas modernos utilizan el mapeo en la memoria independientemente de que se pidan o no</em>.
Por ejemplo, en Linux si un proceso utiliza llamada al sistema <code>mmap()</code> es porque explÃ­citamente pide que el archivo sea mapeado en memoria.
Por tanto, el nÃºcleo mapea el archivo en el espacio de direcciones del proceso.
Sin embargo, si un archivo es abierto con llamadas al sistemas estÃ¡ndar âcomo <code>open()</code>â Linux mapea el archivo en el espacio de direcciones del nÃºcleo y traduce las llamadas <code>read()</code> y <code>write()</code> en accesos a la memoria en dicha regiÃ³n.
No importa como sea abierto el archivo, Linux trata toda la E/S a archivos como mapeada en memoria, permitiendo que el acceso a los mismos tenga lugar a travÃ©s del eficiente componente de gestiÃ³n de la memoria.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reemplazo_de_pÃ¡gina">17.7. Reemplazo de pÃ¡gina</h3>
<div class="paragraph">
<p>Hasta el momento hemos considerado que disponemos de memoria fÃ­sica suficiente para atender cualquier fallo de pÃ¡gina pero Â¿quÃ© pasa cuando no quedan marcos libres?.
En ese caso el cÃ³digo que da servicio a la excepciÃ³n de fallo de pÃ¡gina debe escoger alguna pÃ¡gina, intercambiarla con el disco y utilizar el marco de la misma para cargar la nueva pÃ¡gina.
Es decir, debemos modificar la funciÃ³n que ejecuta los pasos descritos en el <a href="#_protecciÃ³n_y_seguridad">Apartado 4.7</a> de la siguiente manera:</p>
</div>
<div class="paragraph">
<p>["arabic", start=4] .
. <em>Si la pÃ¡gina es legal, debe ser cargada desde el disco</em>.</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><em>Buscar la localizaciÃ³n de la pÃ¡gina en disco</em>.</p>
</li>
<li>
<p><em>El nÃºcleo debe buscar un marco de memoria libre</em> que, por ejemplo, se puede escoger de la lista de marcos libres del sistema.</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p><em>Si hay uno, usarlo</em>.</p>
</li>
<li>
<p><em>Si no hay, usar un algoritmo de reemplazo de pÃ¡gina para seleccionar una vÃ­ctima</em>.</p>
</li>
<li>
<p><em>Escribir la vÃ­ctima en el disco</em> y cambiar las tablas de paginas y de marcos libres de acuerdo a la nueva situaciÃ³n.
Para evitar mantener la CPU ocupada, el sistema debe solicitar la escritura de la pÃ¡gina y poner al proceso en estado de espera.</p>
</li>
</ol>
</div>
</li>
<li>
<p><em>Se solicita una operaciÃ³n de disco para leer la pÃ¡gina deseada en el marco asignado</em>.
Para evitar mantener la CPU ocupada, el sistema debe solicitar la escritura de la pÃ¡gina y poner al proceso en estado de espera.</p>
</li>
<li>
<p><em>Cuando la lectura del disco haya terminado se debe modificar la tabla interna de pÃ¡ginas vÃ¡lidas y la tabla de pÃ¡ginas para indicar que la pÃ¡gina estÃ¡ en la memoria.</em></p>
</li>
<li>
<p><em>Reiniciar el proceso interrumpido</em>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Es importante destacar que <em>en caso de reemplazo se necesita realizar dos accesos al disco.
Esto se puede evitar utilizando un <strong>bit de modificado</strong> asociado a cada pÃ¡gina en la tabla de pÃ¡ginas</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Este bit es puesto a 1 por el hardware cuando se modifica la pÃ¡gina</em>.</p>
</li>
<li>
<p><em>Se puede evitar escribir en disco aquellas pÃ¡ginas que tienen este bit a 0 cuando son seleccionada para reemplazo</em>, siempre que el contenido de la pÃ¡gina no haya sido sobrescrito por otra en el espacio de intercambio</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En general para implementar la paginaciÃ³n bajo demanda necesitamos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Un algoritmo de asignaciÃ³n de marcos</em> que se encarga de asignar los marcos a los procesos.</p>
</li>
<li>
<p><em>Un algoritmo de reemplazo de pÃ¡gina</em> para seleccionar que pÃ¡gina reemplazamos cuando no hay marcos suficientes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Obviamente estos algoritmos deben ser escogidos de forma que mantengan la tasa de fallos de pÃ¡gina lo mÃ¡s baja posible.</p>
</div>
<div class="sect3">
<h4 id="_algoritmos_de_reemplazo_de_pÃ¡ginas">17.7.1. Algoritmos de reemplazo de pÃ¡ginas</h4>
<div class="paragraph">
<p>Existen diversos criterios para escoger la pÃ¡gina que reemplazamos cuando no hay suficientes marcos disponibles.
En cualquier caso <em>el algoritmo Ã³ptimo âel que garantiza la tasa de fallos de pÃ¡gina mÃ¡s bajaâ consiste en seleccionar siempre la pÃ¡gina que mÃ¡s se va a tardar en necesitar</em>.
Desafortunadamente <em>este algoritmo es difÃ­cil de implementar puesto que necesita tener informaciÃ³n acerca de cuÃ¡les van a ser las pÃ¡ginas referencias en el futuro</em>.
Por eso sÃ³lo se puede utilizar en estudios comparativos con el fin de saber cuanto se aproxima al Ã³ptimo un algoritmo de reemplazo concreto.</p>
</div>
<div class="paragraph">
<p>Otros algoritmos de reemplazo pueden utilizar uno o varios de los siguientes criterios:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Reemplazar la pÃ¡gina que hace mÃ¡s tiempo que fue cargada</em>.
Este criterio da lugar al algoritmo FIFO de reemplazo que no siempre tiene un buen rendimiento puesto que la pÃ¡gina mÃ¡s antigua no necesariamente es la que se va a tardar mÃ¡s tiempo en necesitar âque serÃ­a la elecciÃ³n Ã³ptimaâ.</p>
</li>
<li>
<p><em>Reemplazar la pÃ¡gina que hace mÃ¡s tiempo que fue utilizada</em> bajo la hipÃ³tesis de que si una pÃ¡gina no ha sido usada durante un gran periodo de tiempo, entonces es poco probable que vaya a serlo en el futuro.
Este criterio da lugar a la familia de algoritmos <strong>LRU</strong> (Least Recently Used):</p>
<div class="ulist">
<ul>
<li>
<p><em>Estos algoritmos requieren de soporte por parte del hardware</em> puesto que al sistema operativo no se le notifican los acceso legales a las pÃ¡ginas, por lo que no tiene forma de saber cuando una pÃ¡gina fue usada por Ãºltima vez.</p>
</li>
<li>
<p><em>Normalmente el soporte por parte del hardware es a travÃ©s de un bit en la tabla de pÃ¡ginas llamado <strong>bit de referencia</strong></em>.
Este bit se pone a 1 cada vez que una instrucciÃ³n ejecutada en la CPU referencia a una pÃ¡gina, lo que permite al sistema operativo hacerse una idea aproximada<sup class="footnote">[<a id="_footnoteref_19" class="footnote" href="#_footnotedef_19" title="View footnote.">19</a>]</sup> de las pÃ¡ginas que han sido usadas recientemente.
A los algoritmos que siguen esta aproximaciÃ³n se los denomina <em>*NRU*</em> (Not Recently Used).</p>
</li>
<li>
<p><em>Dentro de los algoritmos NRU tambiÃ©n estÃ¡n aquellos que son mejorados incluyendo el valor del bit de modificado en el criterio de elecciÃ³n de la pÃ¡gina</em>.
Estos algoritmos escogen las pÃ¡ginas no referencias antes que las referencias âpara lo que utilizan el valor del bit de referenciaâ y dentro de cada clase las no modificadas antes que las modificadas âpara lo que utilizan el valor del bit de modificadoâ para evitar en lo posible reemplazar pÃ¡ginas cuyo contenido tiene que ser escrito en disco.</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>Reemplazar la pÃ¡gina que ha sido usada con mayor o menos frecuencia</em> utilizando contadores de referencias para cada pÃ¡gina âalmacenados en la tabla de pÃ¡ginasâ que sos actualizados por el hardware en cada referencia.
Este criterio da lugar a los algoritmos <strong>LFU</strong> (Least Frequently Used) âcuando se escogen las pÃ¡ginas utilizadas con menos frecuenciaâ y <strong>MFU</strong> (Most Frequently Used) âcuando se escogen las pÃ¡ginas utilizadas con mÃ¡s frecuenciaâ.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_algoritmos_de_buffering_de_pÃ¡ginas">17.7.2. Algoritmos de buffering de pÃ¡ginas</h4>
<div class="paragraph">
<p>Existen otros procedimientos que pueden ser utilizados, junto con alguno de los algoritmos de reemplazo comentados, con el objetivo de mejorar su eficiencia.
Estos procedimientos se agrupan dentro de lo que se denomina algoritmos de <strong>buffering de pÃ¡ginas</strong>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Se puede mantener una lista de marcos libres</em>.
Cuando se produce un fallo de paginas se escoge un marco de la lista y se carga la pÃ¡gina, al tiempo que se selecciona una pÃ¡gina como vÃ­ctima y se copia al disco.
Esto permite que el proceso se reinicie lo antes posible, sin esperar a que la pÃ¡gina reemplazada sea escrito en el disco.
Posteriormente, cuando la escritura finalice, el marco es incluido en la lista de marcos libres.</p>
</li>
<li>
<p>Una mejora de lo anterior serÃ­a <em>recordar que pÃ¡gina estuvo en cada marco antes de que Ã©ste pasara a la lista de marcos libres</em>.
De esta forma las pÃ¡ginas podrÃ­an ser recuperadas directamente desde la lista si fallara alguna antes de que su marco fuera utilizado por otra pÃ¡gina.
Esto permite reducir los efectos de que el algoritmo de reemplazo escoja una vÃ­ctima equivocada.</p>
</li>
<li>
<p><em>Se puede mantener una lista de pÃ¡ginas modificadas e ir escribiÃ©ndolas cuando el dispositivo del espacio de intercambio no estÃ© ocupado</em>.
Este esquema aumenta la probabilidad de que una pÃ¡gina estÃ© limpia cuando sea seleccionada por el algoritmo de reemplazo, evitando la escritura en disco.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_reemplazo_local_frente_a_global">17.7.3. Reemplazo local frente a global</h4>
<div class="paragraph">
<p>Cuando un proceso necesita un marco el algoritmo de reemplazo puede tanto extraerlo de cualquier proceso como ser obligado a considerar sÃ³lo aquellas pÃ¡ginas que pertenecen al proceso que generÃ³ el fallo.
Eso permite clasificar los algoritmos de reemplazo en dos categorÃ­as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En <em>el <strong>reemplazo local</strong> sÃ³lo se pueden escoger marcos de entre los asignados al proceso</em>.</p>
<div class="ulist">
<ul>
<li>
<p>El nÃºmero de marcos asignados a un proceso no cambia por que ocurran fallos de pÃ¡ginas.</p>
</li>
<li>
<p>El mayor inconveniente es que <em>un proceso no puede hacer disponible a otros procesos los marcos de memoria que menos usa</em>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>En <em>el <strong>reemplazo global</strong> se pueden escoger marcos de entre todos los del sistema</em>, independientemente de que estÃ©n asignados a otro proceso o no.</p>
<div class="ulist">
<ul>
<li>
<p>El nÃºmero de marcos asignados a un proceso puede aumentar si durante los fallos de pÃ¡gina se seleccionan marcos de otros procesos.</p>
</li>
<li>
<p>El mayor inconveniente <em>es que los procesos no pueden controlar su tasa de fallos de pÃ¡gina</em>, puesto que esta depende del comportamiento de los otros procesos, afectando al tiempo de ejecuciÃ³n de forma significativa.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Generalmente <em>el reemplazo global proporciona mayor rendimiento por lo que es el mÃ©todo mÃ¡s utilizado</em>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_asignaciÃ³n_de_marcos_de_pÃ¡gina">17.8. AsignaciÃ³n de marcos de pÃ¡gina</h3>
<div class="paragraph">
<p>La cuestiÃ³n que queda por resolver es cÃ³mo repartir los marcos de memoria fÃ­sica libre entre los diferentes procesos con el fin de cubrir las necesidades de reemplazo de cada uno de ellos.
Posibles soluciones a esto serÃ­an: repartir la memoria por igual entre todos los procesos o hacerlo en proporciÃ³n a la cantidad de memoria virtual que utilizan.
Sin embargo parece que puede ser interesante determinar el mÃ­nimo nÃºmero de marcos que realmente necesita cada proceso, pues asÃ­ el sistema podrÃ­a disponer de memoria libre para aumentar el nÃºmero de procesos âaumentando el uso de la CPUâ o para dedicarla a otras funciones âcomo es el caso de los <em>bÃºferes</em> y las cachÃ©s de E/S â.</p>
</div>
<div class="paragraph">
<p>El mÃ­nimo nÃºmero de marcos viene establecido por diversos factores:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando ocurre un fallo de pÃ¡gina la instrucciÃ³n que la ha provocado debe ser reiniciada despuÃ©s de cargar la pÃ¡gina en un marco libre.
Por lo tanto <em>un proceso debe disponer de suficientes marcos como para guardar todas las pÃ¡ginas a las que una simple instrucciÃ³n pueda acceder</em>, pues de lo contrario el proceso nunca podrÃ­a ser reiniciado al fallar permanentemente en alguno de los acceso a memoria de la instrucciÃ³n.
Obviamente este lÃ­mite viene establecido por la arquitectura de la mÃ¡quina.</p>
</li>
<li>
<p>Todo proceso tiene una cierta cantidad de pÃ¡ginas que en cada instante son utilizadas frecuentemente.
<em>Si el proceso no dispone de suficientes marcos como para alojar dichas pÃ¡ginas, generarÃ¡ fallos de pÃ¡gina con demasiada frecuencia</em>.
Esto afecta negativamente al rendimiento del sistema, por lo que es conveniente que el sistema asigne al nÃºmero de marcos necesario para que eso no ocurra.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En general, si se va reduciendo el nÃºmero de marcos asignados a un proceso, mucho antes de haber alcanzado el mÃ­nimo establecido por la arquitectura, el proceso dejarÃ¡ de ser Ãºtil debido a la elevada tasa de fallos de pÃ¡gina, que serÃ¡ mayor cuantos menos marcos tenga asignados.
Cuando eso ocurre se dice que el proceso estÃ¡ <em>hiperpaginando</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_hiperpaginaciÃ³n">17.9. HiperpaginaciÃ³n</h3>
<div class="paragraph">
<p>Se dice que _un proceso sufre de <strong>hiperpaginaciÃ³n</strong> cuando gasta mÃ¡s tiempo paginando que ejecutÃ¡ndos_e.</p>
</div>
<div class="sect3">
<h4 id="_causas_de_la_hiperpaginaciÃ³n">17.9.1. Causas de la hiperpaginaciÃ³n</h4>
<div class="paragraph">
<p>En los primeros sistemas multiprogramados que implementaron la paginaciÃ³n bajo demanda era posible que se diera el siguiente caso:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>El sistema operativo monitorizaba el uso de la CPU</em>.
Si el uso de la misma era bajo, se cargaban nuevos procesos desde la cola de entrada para aumentar el grado de multiprogramaciÃ³n.</p>
</li>
<li>
<p><em>Si un proceso necesitaba demasiada memoria, le podÃ­a quitar los marcos a otro</em> puesto que se utilizaba un algoritmo de reemplazo global.
Esto podÃ­a ocasionar que aumentara la tasa de fallos de pÃ¡gina del proceso que perdÃ­a los marcos.</p>
</li>
<li>
<p><em>Al aumentar los fallos de pagina el uso de la CPU decrecÃ­a</em>, por lo que el sistema operativo cargaba mÃ¡s procesos para aumentar el grado de multiprogramaciÃ³n y con ello el uso de la CPU.</p>
</li>
<li>
<p><em>Esto reducÃ­a la cantidad de memoria disponible para cada proceso</em>, lo que aumentaba la tasa de fallos de pÃ¡ginas que nuevamente reducÃ­a el uso de la CPU</p>
</li>
<li>
<p>Este mecanismo iteraba hasta reducir considerablemente el rendimiento del sistema.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El fenÃ³meno comentado se ilustra en la donde el uso de la CPU es trazado frente al nÃºmero de procesos cargados en el sistema.
Cuando esto Ãºltimo aumenta el uso de la CPU aumenta hasta alcanzar un mÃ¡ximo.
Si el grado de multiprogramaciÃ³n supera dicho punto, el sistema comienza a hiperpaginar, por lo que el uso de la CPU disminuye bruscamente.
Por lo tanto, si el sistema estÃ¡ hiperpaginando, es necesario reducir el grado de multiprogramaciÃ³n con el objetivo de liberar memoria.</p>
</div>
<div class="paragraph">
<p>En los sistemas de tiempo compartido modernos ocurre algo parecido a lo descrito para los sistemas multiprogramados, aunque sin el efecto en cadena ocasionado por el intento del planificador de largo plazo de maximizar el uso de la CPU, ya que estos sistemas carecen de dicho planificador.
Sea como fuere, <em>en ambos casos los procesos hiperpaginarÃ¡n si no se les asigna un nÃºmero suficiente de marcos</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_soluciones_a_la_hiperpaginaciÃ³n">17.9.2. Soluciones a la hiperpaginaciÃ³n</h4>
<div class="paragraph">
<p>Para el problema de la hiperpaginaciÃ³n existen diversas soluciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Utiliza un algoritmo de reemplazo local</em> pues de esta manera un proceso que hiperpagina no puede afectar a otro.
Sin embargo, el uso intensivo del dispositivo de intercambio podrÃ­a afectar al rendimiento del sistema al aumentar el tiempo de acceso efectivo.</p>
</li>
<li>
<p><em>Proporcionar a un proceso tantos marcos como le hagan falta</em>.
Como ya hemos comentados en diversas ocasiones, para evitar la hiperpaginaciÃ³n es necesario asignar al procesos al menos un nÃºmero mÃ­nimos de marcos, que a priori no es conocido.
Una de las estrategias que pretenden estimar dicho nÃºmero es el <strong>modelo de conjunto de trabajo</strong>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_modelo_del_conjunto_de_trabajo">17.9.3. Modelo del conjunto de trabajo</h4>
<div class="paragraph">
<p>Para entender el modelo de conjunto de trabajo es necesario comenzar definiendo el <strong>modelo de localidad</strong>.
El modelo de localidad establece que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Una localidad es un conjunto de pÃ¡ginas que se utilizan juntas</em>.</p>
</li>
<li>
<p><em>Cuando un proceso se ejecuta se va moviendo de una localidad a otra</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por ejemplo, cuando se invoca una funciÃ³n se define una nueva localidad.
En esta localidad las referencias a la memoria se realizan al cÃ³digo de la funciÃ³n, a las variables locales de la misma y a algunas variables globales del programa.</p>
</div>
<div class="paragraph">
<p>Supongamos que proporcionamos a un proceso suficientes marcos como para alojar toda su localidad en un momento dado.
Entonces el proceso generarÃ¡ fallos de pÃ¡gina hasta que todas las pÃ¡ginas de su localidad estÃ©n cargadas, pero despuÃ©s de eso no volverÃ¡ a fallar hasta que no cambie a una nueva localidad.
Sin embargo <em>si damos al proceso menos marcos de los que necesita su localidad, Ã©ste hiperpaginarÃ¡</em>.</p>
</div>
<div class="paragraph">
<p><em>El <strong>modelo de conjunto de trabajo</strong> es una estrategia que permite obtener una aproximaciÃ³n de la localidad del programa</em> y consiste en lo siguiente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Definir el parÃ¡metro \$Delta\$ como el tamaÃ±o de la ventana del conjunto de trabajo</em>.</p>
</li>
<li>
<p><em>En un instante dado el conjunto de pÃ¡ginas presente en las \$Delta\$ referencias mÃ¡s recientes a la memoria se consideran el <strong>conjunto de trabajo</strong></em>.</p>
</li>
<li>
<p>Por lo tanto, <em>el <strong>conjunto de trabajo</strong> es una aproximaciÃ³n de localidad del programa</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por ejemplo, dada la siguiente lista de referencias a pÃ¡ginas en la memoria memoria:</p>
</div>
<div class="paragraph">
<p>si \$Delta = 10\$ referencias a la memoria, entonces el conjunto de trabajo en \$t_1\$ es \${1, 2, 5, 6, 7}\$.
Mientras que en \$t_2\$ el conjunto de trabajo es \${3, 4}\$.</p>
</div>
<div class="paragraph">
<p>Obviamente <em>la precisiÃ³n del conjunto de trabajo como aproximaciÃ³n de la localidad del programa depende del parÃ¡metro \$Delta\$</em>.
Por ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si \$Delta\$ es muy pequeÃ±a, el conjunto de trabajo no cubrÃ­a toda la localidad.</p>
</li>
<li>
<p>Si \$Delta\$ es muy grande, el conjunto de trabajo se superpondrÃ­an a varias localidades.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_uso_del_conjunto_del_trabajo_para_evitar_la_hiperpaginaciÃ³n">17.9.4. Uso del conjunto del trabajo para evitar la hiperpaginaciÃ³n</h4>
<div class="paragraph">
<p>El uso del conjunto de trabajo es bastante sencillo:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Se selecciona \$Delta\$</em>.</p>
</li>
<li>
<p><em>El sistema operativo monitoriza el conjunto de trabajo de cada proceso y le asigna tantos marcos como pÃ¡ginas haya en el conjunto de trabajo</em>.</p>
</li>
<li>
<p><em>Si sobran suficientes marcos otro proceso puede ser iniciado âen el caso de los sistemas multiprogramadosâ o se puede destinar la memoria libre a otros usos</em>.</p>
</li>
<li>
<p><em>Si el tamaÃ±o del conjunto de trabajo D crece y excede el nÃºmero de marcos disponibles, el sistema podrÃ­a seleccionar un proceso para ser suspendido</em>.
Ãste podrÃ¡ volver a ser reiniciado mÃ¡s tarde.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Donde el tamaÃ±o del conjunto de trabajo \$D\$ es la suma del tamaÃ±o de los conjuntos de trabajo \$WSS^i\$ para cada proceso \$i\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$D=sum WSS_i\$
</div>
</div>
<div class="paragraph">
<p>y representa la demanda total de marcos.
Por eso <em>si \$D\$ es mayor que el nÃºmero de marcos disponibles, habrÃ¡ hiperpaginaciÃ³n</em>.</p>
</div>
<div class="paragraph">
<p>Este sencillo algoritmo anterior permite evitar la hiperpaginaciÃ³n.
Sin embargo, el problema estÃ¡ en como mover la ventana del conjunto de trabajo en cada referencia, con el fin de volver a calcular el conjunto de trabajo.
Una posible aproximaciÃ³n serÃ­a utilizar un temporizador que periÃ³dicamente invocase a una funciÃ³n encargada de examinar el bit de referencia de las pÃ¡ginas en la ventana <em>\$Delta\$</em>.
Es de suponer que las pÃ¡ginas con el bit de referencia a 1 forman parte de la localidad del programa y por tanto serÃ¡n el conjunto de trabajo a lo largo del siguiente periodo.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_otras_consideraciones">17.10. Otras consideraciones</h3>
<div class="paragraph">
<p>Ya hemos comentado que las principales decisiones que deben ser tomadas en el diseÃ±o de un sistema con paginaciÃ³n bajo demanda son la elecciÃ³n del algoritmo de reemplazo y la del de asignaciÃ³n de marcos de pÃ¡gina.
Sin embargo hay otras consideraciones que deben ser tenidas en cuenta.</p>
</div>
<div class="sect3">
<h4 id="_prepaginado">17.10.1. Prepaginado</h4>
<div class="paragraph">
<p><em>El <strong>prepaginado</strong> es una tÃ©cnica que consiste en cargar mÃºltiples pÃ¡ginas junto con la pÃ¡gina demandada en cada fallo de pÃ¡gina</em>.
Esas otras pÃ¡ginas se escogen especulativamente bajo la hipÃ³tesis de que van a ser necesitadas por el proceso en un corto espacio de tiempo, de manera que si la predicciÃ³n es acertada la tasa de fallos de pÃ¡gina se reduce significativamente.
Esta tÃ©cnica puede ser utiliza, por ejemplo, en las siguiente situaciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En la paginaciÃ³n bajo demanda pura, donde el sistema sabe de antemano que cuando se inicia un proceso siempre fallan las primeras pÃ¡ginas de cÃ³digo, por lo que son buenas candidatas para el prepaginado.</p>
</li>
<li>
<p>En el acceso secuencial a archivos mapeados en memoria.
El sistema puede determinar que el acceso es de ese tipo tanto mediante el uso de tÃ©cnicas heurÃ­sticas como mediante las indicaciones dadas por el proceso en la llamada al sistema con la que se abriÃ³ el archivo.
En cualquier caso, si el sistema determina que el acceso al archivo es secuencial, en cada fallo de pÃ¡gina puede cargar tanto la pÃ¡gina demanda como las siguientes en previsiÃ³n de que vayan a ser utilizas por el proceso.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En general el Ãºnico inconveniente del prepaginado es que debe ser ajustarlo para que el coste del mismo sea inferior al de servir los fallos de pÃ¡gina.</p>
</div>
</div>
<div class="sect3">
<h4 id="_aplicaciones_en_modo_raw">17.10.2. Aplicaciones en modo RAW</h4>
<div class="paragraph">
<p><em>Algunas aplicaciones al acceder a sus datos a travÃ©s de los mecanismos de memoria virtual del sistema operativo ofrecen peor rendimiento del que conseguirÃ­an si este mecanismo no existiera</em>.
El ejemplo tÃ­pico son las bases de datos, que conocen sus necesidades de memoria y disco mejor que cualquier sistema operativo de propÃ³sito general, por lo que salen beneficiadas si implementan sus propios algoritmos de gestiÃ³n de la memoria y de buffering de E/S.</p>
</div>
<div class="paragraph">
<p><em>Muchos sistemas operativos modernos permiten que los programas que lo soliciten puedan acceder a los discos en modo raw</em>.
En el <em>modo raw</em> no hay sistemas de archivos, ni paginaciÃ³n bajo demanda, ni bloqueo de archivos, ni prepaginaciÃ³n, ni nada; por lo que dichas aplicaciones deben implementar sus propios algoritmos de almacenamiento y gestiÃ³n de la memoria.
Sin embargo, hay que tener en cuenta que la mayor parte de las aplicaciones siempre funcionan mejor utilizando los servicios convencionales ofrecidos por el sistema operativo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tamaÃ±o_de_las_pÃ¡ginas_2">17.10.3. TamaÃ±o de las pÃ¡ginas</h4>
<div class="paragraph">
<p>Como ya comentamos al estudiar el mÃ©todo bÃ¡sico de paginaciÃ³n (vÃ©ase el <a href="#_paginaciÃ³n">CapÃ­tulo 16</a>), una decisiÃ³n de diseÃ±o importante es escoger el tamaÃ±o adecuado para las pÃ¡ginas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Con pÃ¡ginas grandes</strong>:</p>
<div class="ulist">
<ul>
<li>
<p><em>Se consiguen menos fallos de pÃ¡ginas</em>.
Por ejemplo, en un caso extremo un proceso de 100 KB solo podrÃ­a generar un fallo de pÃ¡gina si cada pÃ¡gina es de 100 KB, pero puede generar 102400 fallos si cada pagina es de 1 byte.</p>
</li>
<li>
<p><em>Se consiguen tablas de pÃ¡ginas mÃ¡s pequeÃ±as</em>.</p>
</li>
<li>
<p><em>La E/S para acceder al contenido de cada pÃ¡gina requiere menos tiempo</em>.
En general el tiempo de transferencia es proporcional a la cantidad de informaciÃ³n transferida, lo que deberÃ­a beneficiar a los sistemas con pÃ¡ginas de pequeÃ±o tamaÃ±o.
Sin embargo la latencia y el tiempo requerido para posicionar la cabeza lectora de los discos es muy superior al tiempo de transferencias de datos, por lo que es mÃ¡s eficiente tener menos transferencias de mayor tamaÃ±o âcomo cuando se usan pÃ¡ginas de grandesâ que mÃ¡s transferencias de menor tamaÃ±o âcomo cuando se usan pÃ¡ginas pequeÃ±asâ.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Con pÃ¡ginas pequeÃ±as</strong>:</p>
<div class="ulist">
<ul>
<li>
<p><em>Se consigue tener menos fragmentaciÃ³n interna</em> y por tanto un mejor aprovechamiento de la memoria.</p>
</li>
<li>
<p><em>TeÃ³ricamente se obtiene mejor resoluciÃ³n para asignar y transferir al disco sÃ³lo la memoria que realmente necesitamos</em>.
Esto a la larga deberÃ­a redundar en menos memoria asignada y menos operaciones de E/S.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>En la actualidad el tamaÃ±o de pÃ¡gina mÃ¡s comÃºn es de 4KB en sistemas de 32 bits y 8 KB en los de 64 bits, ya que son adecuados para la mayor parte de las aplicaciones.
Sin embargo, <em>muchos sistemas modernos soportan el uso simultÃ¡neo de mÃºltiples tamaÃ±os de pÃ¡gina</em>.
Esto permite que la mayor parte de las aplicaciones utilicen el tamaÃ±o estÃ¡ndar, mientras las que hacen un uso intensivo de la memoria puedan utilizar pÃ¡ginas de mayor tamaÃ±o.
Por ejemplo, en la familia Intel x86 el tamaÃ±o estÃ¡ndar es de 4 KB, pero muchas bases de datos âcomo por ejemplo Oracleâ y nÃºcleos de sistema operativo âcomo por ejemplo Linux o Solarisâ utilizan pÃ¡ginas de 4 MB<sup class="footnote">[<a id="_footnoteref_20" class="footnote" href="#_footnotedef_20" title="View footnote.">20</a>]</sup> cuando corren sobre dicha arquitectura.</p>
</div>
</div>
<div class="sect3">
<h4 id="_efecto_de_la_estructura_de_los_programas">17.10.4. Efecto de la estructura de los programas</h4>
<div class="paragraph">
<p><em>Los programas estructurados con un buena localidad de referencia pueden mejorar su rendimiento en los sistemas con paginaciÃ³n bajo demanda</em>.</p>
</div>
<div class="paragraph">
<p>Vamos a ilustrarlo con el siguiente ejemplo de un programa que inicializa a 0 un <em>array</em> de 128 por 128 elementos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">int</span> <span class="n">data</span><span class="p">[][]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">128</span><span class="p">][</span><span class="mi">128</span><span class="p">];</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Un <em>array</em> como el indicado es almacenado en filas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="p">...,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">127</span><span class="p">]</span>
<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="p">...,</span> <span class="n">data</span><span class="p">[</span><span class="mi">127</span><span class="p">][</span><span class="mi">127</span><span class="p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>De manera que si suponemos que el tamaÃ±o de cada pÃ¡gina es de 128 palabras, en el mejor de los casos cada fila estarÃ¡ almacenada en una pÃ¡gina.
Por lo tanto:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si el sistema le asigna 128 marcos o mÃ¡s, el proceso solo generarÃ¡ 128 fallos de pÃ¡gina.</p>
</li>
<li>
<p>Si el sistema operativo le asigna un solo marco, el proceso tendrÃ¡ 16,384 fallos aproximadamente.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sin embargo, el ejemplo serÃ­a diferente si el bucle interno del programa recorriera las columnas del <em>array</em> y no las filas:</p>
</div>
<div class="paragraph">
<p>Pues se podrÃ­an a 0 primero todas las palabras de una misma pÃ¡gina antes de empezar con la siguiente, reduciendo el nÃºmero de fallos de pÃ¡gina a 128 aunque el sistema operativo sÃ³lo asigne un marco al proceso.</p>
</div>
<div class="paragraph">
<p>Por lo tanto se puede concluir que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>La selecciÃ³n cuidadosa de las estructuras de datos y de programaciÃ³n pueden mejorar la localidad, reduciendo la tasa de fallos de pÃ¡ginas y el tamaÃ±o del conjunto de trabajo</em>.
Por ejemplo, las pilas tienen buena localidad puesto que el acceso siempre se realiza en lo alto de las mismas.
Sin embargo las tablas de dispersiÃ³n, obviamente, estÃ¡n diseÃ±adas para dispersar las referencias, lo que produce una mala localidad.</p>
</li>
<li>
<p><em>La elecciÃ³n del lenguaje de programaciÃ³n tambiÃ©n puede tener efecto</em>.
En los lenguajes como C y C&#43;&#43; se utilizan punteros con frecuencia, lo que aleatoriza el acceso a la memoria empeorando la localidad de referencia.
AdemÃ¡s algunos estudios indican que los lenguajes orientados a objetos tienden a tener peor localidad de referencia que los que no lo son.</p>
</li>
<li>
<p><em>El compilador y el cargador tambiÃ©n pueden tener un efecto importante</em>:</p>
<div class="ulist">
<ul>
<li>
<p><em>Separando el cÃ³digo de los datos para permitir que las paginas de cÃ³digo pueda ser de sÃ³lo lectura</em>.
Esto es interesante porque las paginas no modificadas no tienen que ser escritas antes de ser reemplazadas.</p>
</li>
<li>
<p><em>El compilador puede colocar las _funciones</em> que se llaman entre sÃ­ en la misma pÃ¡gina._</p>
</li>
<li>
<p><em>El cargador puede situar las _funciones</em> <em>en la memoria _de _tal</em> forma que <em>en lo posible no _crucen los bordes de las pÃ¡ginas</em>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_interbloqueo_de_es">17.10.5. Interbloqueo de E/S</h4>
<div class="paragraph">
<p><em>Supongamos que un proceso solicita una operaciÃ³n de E/S sobre el contenido de alguna de las pÃ¡ginas de su espacio de direcciones y que la pÃ¡gina es reemplazada despuÃ©s de que el proceso queda en espera pero antes de que la operaciÃ³n es realizada</em>.
En ese caso la operaciÃ³n de E/S se podrÃ­a acabar realizando sobre una pÃ¡gina que pertenece a un proceso diferente.
Para evitarlo existen diversas soluciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Se puede utilizar la memoria del nÃºcleo como bÃºfer en las operaciones de E/S</em>.
En una escritura esto obliga a la llamada al sistema a copiar los datos desde las pÃ¡ginas del proceso a la memoria del nÃºcleo antes de solicitar la operaciÃ³n de E/S.
Mientras que en las operaciones de lectura serÃ­a justo al contrario.</p>
</li>
<li>
<p><em>Cada pÃ¡gina puede tener un bit de bloqueo</em> que se utiliza para indicar que pÃ¡ginas no pueden ser seleccionadas para reemplazo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>AdemÃ¡s los bits de bloqueo se pueden utilizar en otras muchas situaciones</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Bloquear las pÃ¡ginas del nÃºcleo para evitar que sean reemplazadas</em>.</p>
</li>
<li>
<p><em>Bloquear las pÃ¡ginas que acaban de ser cargadas</em>.
Esto evita que un proceso de mayor prioridad pueda reclamar el marco antes de que el proceso para el que se cargÃ³ la pÃ¡gina sea reiniciado, desperdiciando el trabajo de cargarla y provocando un nuevo fallo de pÃ¡gina.
Para implementarlo se puede poner el bit de bloqueo a 1 cuando la pÃ¡gina se carga, volviÃ©ndolo a poner a 0 cuando el proceso es planificado por primera vez despuÃ©s del fallo de pÃ¡gina que provocÃ³ la carga de la misma.</p>
</li>
<li>
<p><em>En los sistemas con tiempo real flexible se suele permitir que las tareas de tiempo real informen de cuales son las pÃ¡ginas mÃ¡s importantes con el fin de que sean bloqueadas para evitar que puedan ser reemplazadas</em>.
Para evitar riesgos, el sistema suele considerar estÃ¡s solicitudes como <em>consejos de bloqueo</em>, de manera que es libre de descartar dichos consejos si el conjunto de marcos libres llega a ser demasiado pequeÃ±o o si un proceso concreto pide bloquear demasiadas pÃ¡ginas.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interfaz_de_gestiÃ³n_de_la_memoria">18. Interfaz de gestiÃ³n de la memoria</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gracias a la abstracciÃ³n de las tÃ©cnicas de memoria virtual âcomo la paginaciÃ³n bajo demandaâ desde el punto de vista de los procesos en cualquier sistema moderno <em>prÃ¡cticamente sÃ³lo hace falta una llamada al sistema para gestionar su espacio de direcciones virtual</em>.
En los sistemas POSIX âcomo GNU/Linuxâ esta llamada es <code>mmap()</code> âjunto a su opuesta <code>munmap()</code>â y sirve para:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Reservar una porciÃ³n de espacio de direcciones virtual del proceso</em>.
Obviamente la llamada sÃ³lo hace la reserva para que dicha regiÃ³n pueda ser usada por el proceso, siendo el componente de paginaciÃ³n bajo demanda el responsable de asignar la memoria fÃ­sica que la respalda.</p>
</li>
<li>
<p><em>Establecer permisos âlectura, escritura y ejecuciÃ³nâ, opciones de comparticiÃ³n entre procesos, bloqueo de pÃ¡ginas en la memoria fÃ­sica, pÃ¡ginas de gran tamaÃ±o, etc.</em> en la regiÃ³n de memoria virtual a reservar.</p>
</li>
<li>
<p><em>Mapear archivos en regiones del espacio de direcciones virtual</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sin embargo <em>en funciones como <code>mmap()</code> la pÃ¡gina es la unidad mÃ­nima en la gestiÃ³n de la memoria</em>.
Es decir, las regiones reservadas del espacio de direcciones virtual siempre comienzan en un borde de pÃ¡gina y su tamaÃ±o es mÃºltiplo del tamaÃ±o de pÃ¡gina.
La cuestiÃ³n es como compatibilizar eso con las necesidades reales de los programas, que durante su ejecuciÃ³n necesitan reservar y liberar constantemente memoria para pequeÃ±os elementos como: <em>arrays</em>, cadenas de texto, estructuras, objetos, etc.
Para esos casos <em>utilizar directamente <code>mmap()</code> no es una soluciÃ³n puesto que la fragmentaciÃ³n interna con llevarÃ­a un importante derroche de recursos</em>.</p>
</div>
<div class="sect2">
<h3 id="_uso_del_espacio_de_direcciones_virtual_del_proceso">18.1. Uso del espacio de direcciones virtual del proceso</h3>
<div class="paragraph">
<p>Los procesos pueden utilizar diversas ubicaciones dentro de su espacio de direcciones virtual para almacenar los datos que necesitan para su ejecuciÃ³n (vÃ©ase la ):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>La variables y constantes globales se almacenan en la secciÃ³n de datos</em>, que tiene tamaÃ±o fijo ya que las dimensiones de estas variables se conocen de antemano en tiempo de compilaciÃ³n, al igual que ocurre con el cÃ³digo del programa.</p>
</li>
<li>
<p><em>Las variables locales y los argumentos de las _funciones</em> se almacenan en la pila_ junto con la direcciones de retorno de las mismas.
Esta es la ubicaciÃ³n ideal puesto que al retornar de una funciÃ³n, la pila se restablece al estado previo al que tenÃ­a cuando se invocÃ³ dicha funciÃ³n, haciendo que las variables locales y argumentos desaparezcan automÃ¡ticamente.</p>
</li>
<li>
<p><em>Las variables asignadas dinÃ¡micamente âpor ejemplo, usando <code>malloc()</code>/<code>free()</code> en C o <code>new</code>/<code>delete</code> en C&#43;&#43; o Javaâ se almacenan en el montÃ³n</em>, que no es mÃ¡s una regiÃ³n continua de memoria ubicada inmediatamente despuÃ©s de la secciÃ³n de datos del proceso.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cada lenguaje de programaciÃ³n debe proporcionar âpor ejemplo a travÃ©s de su <em>librerÃ­a estÃ¡ndar</em>â un mecanismo en espacio de usuario adecuado para la gestiÃ³n en tiempo de ejecuciÃ³n de la memoria del <em>montÃ³n</em> del proceso.
Para eso cada lenguaje puede utilizar su propia implementaciÃ³n de dicho mecanismo o bien recurrir a la proporcionada por la <em>librerÃ­a del sistema</em>.
Por ejemplo, en los sistemas POSIX la <em>librerÃ­a del sistema</em> proporciona su propia implementaciÃ³n, accesible a travÃ©s de las funciones <code>malloc()</code> y <code>free()</code>, que es utilizada directamente por los programas escritos en C.
Otros lenguajes de programaciÃ³n tienen otras interfaces para gestionar la memoria pero utilizan internamente las funciones <code>malloc()</code> y <code>free()</code> de la <em>librerÃ­a estÃ¡ndar</em>.
Pero este no es el caso ni de C&#43;&#43; ni de Java ni de otros muchos lenguajes; donde los operadores <code>new</code> y <code>delete</code> utilizan sus propios algoritmos de gestiÃ³n de la memoria del montÃ³n mÃ¡s optimizados que <code>malloc()</code> y <code>free()</code> para la creaciÃ³n y destrucciÃ³n de objetos de manera eficiente.</p>
</div>
</div>
<div class="sect2">
<h3 id="_gestiÃ³n_de_la_memoria_del_montÃ³n">18.2. GestiÃ³n de la memoria del montÃ³n</h3>
<div class="paragraph">
<p>Para ilustrar cÃ³mo se gestiona la memoria del <em>montÃ³n</em> utilizaremos como ejemplo el mecanismo empleado por la <em>librerÃ­a del sistema</em> de los sistemas POSIX âaccesible a travÃ©s de las funciones <code>malloc()</code> y <code>free()</code>â aunque es importante tener en cuenta que esta tarea se realiza de manera muy similar en las implementaciones de otros sistemas operativos y lenguajes de programaciÃ³n.</p>
</div>
<div class="paragraph">
<p>El funcionamiento bÃ¡sico de <code>malloc()</code> sigue las siguiente reglas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Cuando la memoria solicitada supera cierto umbral â128KB en sistemas GNU/Linuxâ es reservada directamente mediante la llamada al sistema `mmap()`</em>.
Eso significa que las peticiones de gran tamaÃ±o realmente no consumen espacio del <em>montÃ³n</em>.</p>
</li>
<li>
<p><em>En caso contrario la peticiÃ³n de memoria se atiende utilizando un algoritmo de reserva de memoria continua sobre el espacio libre en el montÃ³n.</em> Estos algoritmos los veremos posteriormente.</p>
</li>
<li>
<p><em>Si no hay suficiente memoria libre contigua como para atender la peticiÃ³n se utiliza la llamada al sistema <code>brk()</code> para ampliar el tamaÃ±o del montÃ³n</em> sobre la regiÃ³n no asignada del espacio de direcciones virtual del proceso.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando un proceso hace una peticiÃ³n de memoria dinÃ¡mica espera que el espacio ofrecido sea continuo en el espacio de direcciones virtual, por lo que es necesario utilizar algÃºn algoritmo de <strong>asignaciÃ³n de memoria contigua</strong>.
Como las peticiones de los procesos son de tamaÃ±o variable, la forma mÃ¡s eficiente de enfrentar este problema es utilizando lo que se denomina un esquema de <strong>particionado dinÃ¡mico</strong>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>La librerÃ­a mantiene una lista indicando que regiones del montÃ³n estÃ¡n libres y cuales no</em>.
El montÃ³n se inicializa con un tamaÃ±o determinado completamente libre, por lo que es considerado como un gran hueco de memoria disponible.</p>
</li>
<li>
<p><em>Cuando un proceso realiza una peticiÃ³n âa travÃ©s de <code>malloc()</code>â se busca un hueco lo suficientemente grande para atenderla</em>.
Si se encuentra, sÃ³lo se le asigna el espacio necesario, que es marcado como ocupado en la lista.
El resto sigue siendo considerado como un hueco libre, aunque de menor tamaÃ±o.</p>
</li>
<li>
<p><em>Si el proceso libera una porciÃ³n de la memoria y se crean dos huecos adyacentes, se funden en uno solo</em>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>En general, en un momento dado tenemos una peticiÃ³n de tamaÃ±o <em>n</em> que debemos satisfacer con una lista de huecos libres de tamaÃ±o variable.
Esto no es mÃ¡s que un caso particular del <em>problema _clÃ¡sico</em> de la asignaciÃ³n dinÃ¡mica de almacenamiento_ para el que hay diversas soluciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>En el <strong>primer ajuste</strong> se escoge el primer hueco lo suficientemente grande como para satisfacer la peticiÃ³n</em>.
La bÃºsqueda puede ser desde el principio de la lista o desde donde ha terminado la bÃºsqueda anterior.</p>
</li>
<li>
<p><em>En el <strong>mejor ajuste</strong> se escoge el hueco mÃ¡s pequeÃ±o que sea lo suficientemente grande para satisfacer la peticiÃ³n</em>.
Indudablemente esto obliga a recorrer la lista de huecos completa o a tenerla ordenada por tamaÃ±o.</p>
</li>
<li>
<p><em>En el <strong>peor ajuste</strong> se escoge el hueco mÃ¡s grande</em>.
Igualmente obliga a buscar en toda la lista de huecos o a tenerla ordenada por tamaÃ±o.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En la actualidad <em>la estrategia mÃ¡s comÃºn es utilizar el mejor ajuste junto con algÃºn tipo de estructura de datos que mantenga los huecos libres ordenados por tamaÃ±o</em>, de manera que puedan ser encontrados eficientemente.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fragmentaciÃ³n">18.3. FragmentaciÃ³n</h3>
<div class="paragraph">
<p>Las estrategia comentada no sufre de <em>fragmentaciÃ³n interna</em> porque se asigna exactamente la cantidad de memoria solicitada.
Sin embargo si sufre de otro tipo de fragmentaciÃ³n denominada fragmentaciÃ³n externa.</p>
</div>
<div class="paragraph">
<p><em>La <strong>fragmentaciÃ³n externa</strong> ocurre cuando hay suficiente espacio libre para satisfacer una peticiÃ³n pero el espacio no es contiguo</em>.
Es decir, el espacio de almacenamiento estÃ¡ fraccionado en un gran nÃºmero de huecos de pequeÃ±o tamaÃ±o, obligando a la librerÃ­a a invocar la llamada al sistema <code>brk()</code> con el objetivo de incrementar el tamaÃ±o del montÃ³n.
Este problema:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Afecta tanto a la estrategia del primer como del mejor ajuste</em>.
Siendo el primero mejor en algunos sistemas y el segundo mejor en otros.</p>
</li>
<li>
<p>Algunos anÃ¡lisis estadÃ­sticos realizados con el primer ajuste revelan que <em>incluso con algunas optimizaciones, con n bloques asignados se pierden 0.5n por fragmentaciÃ³n externa</em>.
Es decir, un tercio de la memoria no es utilizable.
A esto se lo conoce como la <em>regla del 50%</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Lamentablemente este problema no tiene una soluciÃ³n sencilla ya que aunque se podrÃ­a intentar mover los bloques de memoria para que toda la memoria libre quedara en un Ãºnico hueco, serÃ­a necesario modificar en tiempo de ejecuciÃ³n las direcciones virtuales utilizadas por el proceso en cada puntero o referencia a los bloques de memoria en el montÃ³n.</p>
</div>
</div>
</div>
</div>
<h1 id="_gestiÃ³n_del_almacenamiento" class="sect0">Parte V: GestiÃ³n del almacenamiento</h1>
<div class="sect1">
<h2 id="_dispositivos_de_almacenamiento">19. Dispositivos de almacenamiento</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Los ordenadores pueden almacenar informaciÃ³n en diferentes soportes de almacenamiento âpor ejemplo en discos magnÃ©ticos, en DVD, en memorias de estado sÃ³lido, etc.â.
Cada uno tiene propiedades fÃ­sicas diferentes que pasamos a comentar brevemente a continuaciÃ³n.</p>
</div>
<div class="sect2">
<h3 id="_discos_magnÃ©ticos">19.1. Discos magnÃ©ticos</h3>
<div class="paragraph">
<p>Los discos magnÃ©ticos son el tipo principal de almacenamiento secundario, generalmente en la forma de lo que se denominan discos duros.
Tal y como se puede apreciar en la cada unidad estÃ¡ compuesta por una serie de platos de forma circular recubiertos de material magnÃ©tico.
La informaciÃ³n se almacena grabÃ¡ndola magnÃ©ticamente sobre los platos, para lo cual se utilizan unas cabezas de lectura que Â«flotanÂ» tanto por encima como por debajo de cada plato.</p>
</div>
<div class="paragraph">
<p>Desde el punto de vista lÃ³gico (vÃ©ase la ) <em>la superficie de cada plato estÃ¡ dividida en <strong>pistas</strong> circulares, cada una de las cuales se subdivide en <strong>sectores</strong></em>.
<em>El conjunto de pistas formado por todas aquellas que estÃ¡n situadas en la misma posiciÃ³n en los distintos platos se denomina <strong>cilindro</strong></em>.</p>
</div>
<div class="paragraph">
<p>En estos dispositivos consume mucho mÃ¡s tiempo mover la cabeza de lectura hasta el sector de interÃ©s que la lectura y transferencia de los datos almacenados a la memoria RAM.
Por lo tanto el tiempo de acceso aleatorio al disco es mucho mayor que el de acceso secuencial.</p>
</div>
</div>
<div class="sect2">
<h3 id="_discos_Ã³pticos">19.2. Discos Ã³pticos</h3>
<div class="paragraph">
<p>Los discos Ã³pticos âCD, DVD, BluRay, etc.â consisten en un disco circular en el cual la informaciÃ³n se almacena haciendo uso de surcos microscÃ³picos que se leen haciendo incidir un lÃ¡ser sobre una de las caras planas que lo componen.</p>
</div>
<div class="paragraph">
<p>En este tipo de discos la informaciÃ³n se almacena siguiendo un recorrido continuo en espiral que cubre la superficie entera del disco, extendiÃ©ndose desde el interior hacia el exterior.
Dado que el lÃ¡ser siempre debe desplazarse sobre la espiral, el acceso aleatorio a los datos es mÃ¡s lento que con otras tecnologÃ­as de disco.</p>
</div>
</div>
<div class="sect2">
<h3 id="_memorias_de_estado_sÃ³lido">19.3. Memorias de estado sÃ³lido</h3>
<div class="paragraph">
<p>Una memoria de estado sÃ³lido âmemoria USB, SSD, etc.â es un dispositivo de almacenamiento que usa una memoria no volÃ¡til, como las <em>memorias flash</em>, para almacenar datos, en lugar de utilizar discos Ã³pticos o magnÃ©ticos.
En este tipo de memorias la informaciÃ³n se almacena como en un vector lineal de bytes, que se puede indexar aleatoriamente con la misma eficiencia con la que se accede secuencialmente, como ocurre con la memoria RAM, Aunque algunos dispositivos, de cara al resto del sistema informÃ¡tico, emulan una interfaz y un modo de direccionamiento similar al utilizado por los discos magnÃ©ticos âes decir, usando pistas, sectores y cilindros.â por temas de compatibilidad.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_archivos_y_sistemas_de_archivos">20. Archivos y sistemas de archivos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Teniendo en cuenta la gran diversidad de dispositivos de almacenamiento que existen, para que el sistema informÃ¡tico sea cÃ³modo de utilizar el sistema operativo proporciona una visiÃ³n lÃ³gica uniforme de todos los sistemas de almacenamiento.
Es decir, abstrae las propiedades fÃ­sicas de los dispositivos de almacenamiento para definir una unidad de almacenamiento lÃ³gico que sea Ãºtil para los usuarios.
Esta unidad es el <em>archivo</em>.</p>
</div>
<div class="paragraph">
<p><em>Un <strong>archivo</strong> es una colecciÃ³n de informaciÃ³n relacionada cuya estructura y significado de sus datos los define su creador</em>.
Desde la perspectiva de los usuarios, un archivo es la unidad mÃ¡s pequeÃ±a de almacenamiento.
Es decir, no se pueden escribir datos en el almacenamiento secundario a menos que estos se encuentren dentro de un archivo.</p>
</div>
<div class="paragraph">
<p>El sistema operativo puede ofrecer esta abstracciÃ³n gracia al <strong>sistema de archivos</strong>.
<em>Este proporciona los mecanismos para el almacenamiento de lo datos y programas en archivos</em>, tanto del propio sistema operativo como los de todos los usuarios del sistema informÃ¡tico.</p>
</div>
<div class="paragraph">
<p><em>Los sistemas de archivos estÃ¡n compuestos de dos partes claramente diferenciadas:</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Una colecciÃ³n de archivos</em>, cada uno de los cuales almacena una serie de datos relacionados.</p>
</li>
<li>
<p><em>Una colecciÃ³n de estructuras de metadatos</em>, que contienen informaciÃ³n relativa a los archivos almacenados ânombre, ubicaciÃ³n en el disco, permisos, etc.â y que se encarga de organizarlos, generalmente haciendo uso de una estructura de directorios.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_volÃºmenes_de_datos">21. VolÃºmenes de datos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Los dispositivos de almacenamiento comentados anteriormente pueden ser utilizados al 100% con un Ãºnico sistema de archivos.
Sin embargo, en ocasiones es interesante hacer divisiones con el objeto de disponer de mÃºltiples sistemas de archivos en el mismo dispositivo.
Cada una de esas divisiones es un <em>volumen</em>.</p>
</div>
<div class="paragraph">
<p>En otros casos interesa combinar divisiones o dispositivos de almacenamiento completos para crear espacios de mayor tamaÃ±o âtambiÃ©n denominadas volÃºmenesâ cada una de las cuales puede albergar un Ãºnico sistema de archivos.
AsÃ­ que en general <em>utilizaremos el tÃ©rmino <strong>volumen</strong> para referirnos a un espacio de almacenamiento que alberga un sistema de archivos</em>, tanto si ese espacio es una pequeÃ±a parte del espacio completo del dispositivo como si se trata de una estructura de mayor tamaÃ±o compuesta a partir de varios dispositivos.</p>
</div>
<div class="paragraph">
<p>A continuaciÃ³n comentaremos brevemente las tecnologÃ­as utilizadas con mayor frecuencia para construir estos volÃºmenes.</p>
</div>
<div class="sect2">
<h3 id="_raid">21.1. RAID</h3>
<div class="paragraph">
<p>La tecnologÃ­a <strong>RAID</strong> (<em>Redundant Array of Inexpensive Disks</em>) permite combinar varios discos duros para mejorar las prestaciones a travÃ©s del paralelismo en el acceso o para mejorar la fiabilidad a travÃ©s del almacenamiento de informaciÃ³n redundante.
En concreto se definen diversos <em>niveles RAID</em>, de entre los cuales los mÃ¡s comunes son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>En un <strong>conjunto RAID 0</strong> se distribuyen los datos equitativamente en bloques de tamaÃ±o fijo entrelazados entre dos o mÃ¡s discos</em>, sin incluir ningÃºn tipo de informaciÃ³n redundante.
Esto permite leer y escribir mÃ¡s datos en el mismo tiempo ya que se pueden enviar en paralelo peticiones a los distintos discos.
Sin embargo la fiabilidad es inversamente proporcional al nÃºmero de discos, ya que para que el conjunto falle basta con que lo haga cualquiera de ellos.</p>
</li>
<li>
<p><em>En un <strong>conjunto RAID 1</strong> se crea una copia exacta âen espejoâ de los datos en dos o mÃ¡s discos</em>.
El resultado es que, incluso con dos discos, se incrementa exponencialmente la fiabilidad respecto a tener uno solo, ya que para que el conjunto falle es necesario que lo hagan todos los discos.
Adicionalmente el rendimiento en las operaciones de lectura se incrementa linealmente con el nÃºmero de copias, ya que los datos estÃ¡n disponibles en todos los discos al mismo tiempo, por lo que se pueden balancear la operaciones de lectura entre todos ellos.</p>
</li>
<li>
<p><em>En un <strong>conjunto RAID 5</strong> se distribuyen los datos equitativamente en bloques de tamaÃ±o fijo entrelazados entre dos o mÃ¡s discos y se utiliza uno adicional para almacenar la informaciÃ³n de paridad de los bloques de una misma divisiÃ³n</em><sup class="footnote">[<a id="_footnoteref_21" class="footnote" href="#_footnotedef_21" title="View footnote.">21</a>]</sup>.
El disco utilizado para almacenar el bloque de paridad cambia de forma escalonada de una divisiÃ³n a la siguiente, de ahÃ­ que se diga que <em>el bloque de paridad estÃ¡ distribuido</em>.
Algunos aspectos adicionales a tener en cuenta son que:</p>
<div class="ulist">
<ul>
<li>
<p><em>Cada vez que se escribe un bloque de datos se debe actualizar el bloque de paridad</em>.
Por lo tanto las escrituras en un conjunto RAID 5 son costosas en tÃ©rminos de operaciones de disco y trÃ¡fico.</p>
</li>
<li>
<p><em>Los bloques de paridad no se leen durante las lecturas de datos</em>, ya que eso reducirÃ­a el rendimiento.
SÃ³lo se hace en caso de que la lectura de un sector falle, puesto que <em>el sector en la misma posiciÃ³n relativa dentro de cada uno de los otros bloques de datos de la divisiÃ³n y en el bloque de paridad se pueden utilizar para reconstruir el sector errÃ³neo.</em></p>
</li>
<li>
<p><em>En un conjunto RAID 5 el fallo de 2 discos provoca la pÃ©rdida completa de los datos</em>.
Esto significa que aunque se pueden aÃ±adir discos de manera ilimitada, eso no suele ocurrir puesto que <em>a mÃ¡s discos en el conjunto mÃ¡s probabilidad de que fallen dos de ellos</em>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>En un <strong>conjunto RAID 6</strong> se utiliza la misma estrategia que en RAID 5 pero _en cada divisiÃ³n hay dos _bloques de paridad â_en lugar de unoâ</em> <em>en dos discos diferentes</em>.
Esto permite que fallen hasta dos discos sin perder los datos.</p>
</li>
<li>
<p><em>En un conjunto con niveles anidados se combinan varios niveles RAID bÃ¡sicos como si fueran capas superpuestas</em>.
Ejemplos tÃ­picos son:</p>
<div class="ulist">
<ul>
<li>
<p>RAID 0+1, donde se hace un espejo de un conjunto RAID 0.</p>
</li>
<li>
<p>RAID 1+0 o RAID 10, donde diversos conjuntos en espejo se combina en un RAID 0, aumentando la capacidad total.</p>
</li>
<li>
<p>RAID 50, donde diversos conjuntos RAID 5 se combinan en un RAID 0, aumentando tambiÃ©n la capacidad total.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>La implementaciÃ³n de RAID es otra de las Ã¡reas donde existen diversas variantes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>RAID puede implementarse en el hardware de la controladora de disco</em>, de tal forma que sÃ³lo los discos conectados a esta pueden formar parte de un conjunto RAID determinado.
Esta soluciÃ³n es muy eficiente, especialmente cuando se utilizan niveles que requieren cÃ¡lculo de la paridad, ya que se evita utilizar tiempo de CPU para ese trabajo.
Sin embargo estas controladoras son notablemente mÃ¡s caras que las que carecen de soporte para RAID.</p>
</li>
<li>
<p><em>RAID puede implementarse dentro del sistema operativo en lo que se denomina el software de <strong>gestiÃ³n de volÃºmenes</strong></em>.
En este caso las soluciones RAID con paridad son bastante lentas por lo que normalmente sÃ³lo se soportan los niveles RAID 0, 1, 10 o 0+1.
Algunas controladoras de disco modernas que dicen venir con soporte RAID realmente implementan esta tecnologÃ­a en software, a nivel del controlador de dispositivo, mientras que en el hardware sÃ³lo se implementan unas caracterÃ­sticas de apoyo mÃ­nimas<sup class="footnote">[<a id="_footnoteref_22" class="footnote" href="#_footnotedef_22" title="View footnote.">22</a>]</sup>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cada conjunto RAID se comporta como una unidad de almacenamiento independiente desde el punto de vista del resto del sistema, por lo que se puede utilizar entero para albergar un Ãºnico sistema de archivos.
Sin embargo, lo mÃ¡s comÃºn es dividirlo en regiones con el objeto de utilizar mÃºltiples sistemas de archivos o combinarlo en estructuras de mayor tamaÃ±o, para lo cuÃ¡l se pueden utilizar alguna de las tÃ©cnicas que veremos a continuaciÃ³n.</p>
</div>
</div>
<div class="sect2">
<h3 id="_particiones">21.2. Particiones</h3>
<div class="paragraph">
<p><em>Un disco, un conjunto RAID o cualquier otro dispositivo de almacenamiento se puede dividir en regiones para utilizar en cada una de ellas un sistema de archivos diferente</em>.
A esas regiones se las conoce comÃºnmente como <strong>particiones</strong>, <strong>franjas</strong> o <strong>minidiscos</strong>.</p>
</div>
<div class="paragraph">
<p>SegÃºn la plataforma, existen diversas maneras de implementar el soporte de particiones.
Entre los sistemas de escritorio las tecnologÃ­as mÃ¡s difundidas y utilizadas son la <strong>MBR</strong> (<em>Master Boot Record</em>) y la <strong>GPT</strong> (<em>GUID Partition Table</em>).
En ambas <em>se almacena, en los primeros sectores del dispositivo de almacenamiento, una tabla con una entrada por particiÃ³n donde se guardan las direcciones del primer y Ãºltimo sector de cada una de ellas en el dispositivo</em>, asÃ­ como otra informaciÃ³n.
Eso es todo lo que necesita el sistema operativo para determinar los lÃ­mites de la regiÃ³n ocupada por cada sistema de archivos.</p>
</div>
</div>
<div class="sect2">
<h3 id="_volÃºmenes_dinÃ¡micos">21.3. VolÃºmenes dinÃ¡micos</h3>
<div class="paragraph">
<p>SegÃºn la tecnologÃ­a que se utilice para particionar es posible encontrarse con una serie de restricciones comunes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El limitado nÃºmero de particiones diferentes que puede contener un mismo dispositivo.</p>
</li>
<li>
<p>Limitaciones o imposibilidad de redimencionar las particiones.
Especialmente si el sistema operativo estÃ¡ en ejecuciÃ³n.</p>
</li>
<li>
<p>La imposibilidad de crear particiones que hagan uso de regiones libres en diferentes dispositivos de almacenamiento.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para resolverlo algunos sistemas operativos incluyen un <em>software de gestiÃ³n de volÃºmenes</em> que hace uso de tecnologÃ­a propia para superar estas limitaciones.
Estas herramientas generalmente permiten agrupar dispositivos completos, conjuntos RAID, particiones, etc.
y sobre ellos construir los volÃºmenes que sean necesarios.
Estos volÃºmenes pueden ser redimensionados âen ocasiones sin tener que detener la ejecuciÃ³n del sistema operativoâ y en caso de que haga falta se pueden incluir dinÃ¡micamente nuevos dispositivos para incrementar el espacio disponible.
AdemÃ¡s, como ya hemos comentado, el software de gestiÃ³n de volÃºmenes puede incluir alguna funcionalidad propia de conjuntos RAID con el objeto de mejorar las prestaciones, a travÃ©s del paralelismo en el acceso, o mejorar la fiabilidad a travÃ©s del almacenamiento de informaciÃ³n redundante.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sistemas_de_archivos">22. Sistemas de archivos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Cada volumen puede albergar un sistema de archivos.
A continuaciÃ³n estudiaremos los elementos mÃ¡s comunes a la mayor parte de los sistemas de archivos.</p>
</div>
<div class="sect2">
<h3 id="_estructura_de_un_sistema_de_archivos">22.1. Estructura de un sistema de archivos</h3>
<div class="paragraph">
<p>Un sistema de archivos suele estar compuesto de varios niveles diferentes.
En la se muestra un ejemplo tÃ­pico de la estructura de un sistema de archivos diseÃ±ado en niveles.
Cada nivel utiliza las funciones de los niveles inferiores y proporciona nuevas funciones a los niveles superiores:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>En el nivel mÃ¡s bajo, accediendo directamente a los dispositivos de almacenamiento, se encuentra el <strong>control de E/S</strong>.
<em>Ãste estÃ¡ compuesto por los controladores de dispositivo encargados de transferir la informaciÃ³n entre la memoria principal y el disco</em>.
Estos controladores, que generalmente son compartidos entre los distintos sistemas de archivos, transfieren los datos en unidades de <em>bloques</em> âen lugar de transferir un byte cada vezâ para mejorar la eficiencia .
Cada <em>bloque</em> estÃ¡ formado por uno o mÃ¡s sectores<sup class="footnote">[<a id="_footnoteref_23" class="footnote" href="#_footnotedef_23" title="View footnote.">23</a>]</sup>.</p>
</li>
<li>
<p><em>El <strong>sistema bÃ¡sico de archivos</strong> se encarga de enviar comandos genÃ©ricos al controlador de dispositivo apropiado con el fin de leer y escribir bloques fÃ­sicos en el disco</em>.
Cada bloque fÃ­sico se identifica mediante su direcciÃ³n de disco numÃ©rica (por ejemplo: unidad 1, cilindro 73, cabeza 2, sector 10).</p>
</li>
<li>
<p><em>El <strong>mÃ³dulo de organizaciÃ³n de archivos</strong> tiene conocimiento de los archivos y se encarga de traducir las direcciones lÃ³gicas de bloque âposiciÃ³n del bloque dentro del archivoâ en las direcciones fÃ­sicas de bloque âpoe ejemplo, cilindro, cabeza y sector de los bloques correspondientes en el dispositivo de almacenamientoâ</em> que serÃ¡n enviadas al <em>sistema bÃ¡sico de archivos</em> para que realice las transferencias solicitadas.
Los bloques lÃ³gicos de cada archivo son numerados de 0 a <em>N</em>, pero los bloques fÃ­sicos asignados a estos bloques lÃ³gicos no tienen porquÃ© coincidir en los nÃºmeros de bloque.
Por eso el <em>mÃ³dulo de organizaciÃ³n de archivos</em> debe utilizar la ubicaciÃ³n del contenido del archivo y la informaciÃ³n sobre la asignaciÃ³n de bloques, para traducir las direcciones lÃ³gicas en direcciones fÃ­sicas.
AdemÃ¡s, el mÃ³dulo de organizaciÃ³n incluye el gestor de espacio libre, que controla los bloques no asignados y proporciona dichos bloques cuando el <em>mÃ³dulo de organizaciÃ³n de archivos</em> lo necesita.</p>
</li>
<li>
<p><em>El <strong>sistema lÃ³gico de archivos</strong> gestiona los metadatos</em>.
Los metadatos incluyen toda la estructura del sistema de archivos, excepto los propios datos de los archivos.
Entre dichos metadatos estÃ¡ la estructura de directorios y los <em>bloques de control de archivo</em>.
<em>Un <strong>bloque de control de archivo</strong> o <strong>FCB</strong> (File Control Block) contiene informaciÃ³n acerca del archivo</em>, incluyendo su propietario, los permisos y la ubicaciÃ³n del contenido del mismo.
AdemÃ¡s, el <em>sistema lÃ³gico de archivos</em> tambiÃ©n es responsable de las tareas de protecciÃ³n y seguridad.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cada sistema operativo puede soportar uno o mÃ¡s sistemas de archivos para dispositivos de disco.
Por ejemplo, en los sistemas UNIX se utiliza el <em>sistema de archivos UNIX</em> o UFS (<em>UNIX File System</em>), que estÃ¡ basado en el sistema FFS (<em>Fast File System</em>) de Berkeley.
Microsoft Windows soporta los sistemas de archivo FAT, FAT32 y NTFS (<em>NT File System</em>).
En Linux se soportan mÃ¡s de cuarenta sistemas de archivo, entre los que podrÃ­amos destacar: el <em>sistema de archivos extendido</em> âext2, ext3 y ext4â XFS y BTRFS.
AdemÃ¡s, la mayorÃ­a de los sistemas operativos modernos soportan otros sistemas de archivo, como los utilizados en los soportes removibles.
Por ejemplo el ISO-9660, utilizado por la mayor parte de los CD-ROM, o el UFS (<em>Universal File System</em>), utilizado por los DVD-ROM.</p>
</div>
</div>
<div class="sect2">
<h3 id="_estructuras_de_metadatos">22.2. Estructuras de metadatos</h3>
<div class="paragraph">
<p>Para implementar un sistema de archivos se utilizan diversas estructuras de metadatos alojadas tanto en el disco como en la memoria.
Estas estructuras varÃ­an dependiendo del sistema operativo y del sistema de archivos.
Sin embargo, a continuaciÃ³n intentaremos describir brevemente las estructuras en disco de uso mÃ¡s comÃºn:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Un <strong>bloque de control de arranque</strong> (<strong>bloque de inicio</strong> o <strong>sector de arranque</strong>) que suele ocupar el primer bloque de cada volumen y que contiene la informaciÃ³n necesaria para iniciar un sistema operativo a partir de dicho volumen</em>.
Este bloque puede estar vacÃ­o, si el volumen no contiene un sistema operativo.</p>
</li>
<li>
<p><em>Un <strong>bloque de control de volumen</strong> que contiene todos los detalles acerca del volumen</em>, tales como: el nÃºmero mÃ¡ximo de bloques, el tamaÃ±o de los bloques, el nÃºmero de bloques libres y punteros a los mismos, asÃ­ como un contador de bloques de informaciÃ³n FCB y punteros a estos.
En los sistemas de archivos para UNIX y Linux, a esta estructura se la denomina <strong>superbloque</strong>.
Mientras que en NTFS esta informaciÃ³n se almacena en la <strong>tabla maestra de archivos</strong> o <strong>MFT</strong> (<em>Master File Table</em>).</p>
</li>
<li>
<p><em>Un FCB por cada archivo</em> donde se almacenan numerosos detalles sobre el mismo, por ejemplo: los permisos, el propietario, el tamaÃ±o y la ubicaciÃ³n de los bloques de datos.
En tÃ©rminos generales todos los FCB del sistema de archivos se almacenan en una tabla denominada directorio de dispositivo o tabla de contenidos del volumen.
En los sistemas de archivos para UNIX y Linux cada FCB se denomina <strong>inodo</strong> y se almacenan a continuaciÃ³n del superbloque.
En NTFS esta informaciÃ³n se almacena en la MFT, ya que cada entrada de dicha tabla es un FCB.</p>
</li>
<li>
<p><em>Una estructura de directorios para organizar los archivos</em>.
En los sistemas de archivos para UNIX y Linux, cada directorio es como un archivo especial que almacena los nombres de los archivos que contiene y los nÃºmeros de FCB asociados a los mismos.
En NTFS es similar, aunque la estructura de directorios completa se almacena en la propia MFT.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La informaciÃ³n almacenada en memoria se utiliza tanto para la gestiÃ³n del sistema de archivo como para mejorar el rendimiento del mismo mediante mecanismos de cachÃ©.
Los datos se cargan en el momento de comenzar a utilizar el sistema de archivos âmontajeâ y se descartan cuando se va a dejar de hacer uso del mismo âdesmontajeâ.
Las estructuras existentes en la memoria pueden incluir las que a continuaciÃ³n se describen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Una tabla de montaje en memoria que contiene informaciÃ³n acerca de cada volumen montado</em>.</p>
</li>
<li>
<p><em>Una cachÃ© en memoria de la estructura de directorios que almacena la informaciÃ³n relativa a los directorios a los que se han accediÃ³ recientemente</em>.
Los directorios que actÃºan como puntos de montaje puede contener un puntero a la entrada, en la tabla de montaje, del volumen montado en el directorio.</p>
</li>
<li>
<p><em>La tabla global de archivos abiertos que contiene una copia del FCB de cada archivo abierto en el sistema</em>, ademÃ¡s de otras informaciones.</p>
</li>
<li>
<p><em>La <strong>tabla de archivos abiertos</strong> de cada proceso</em>.
El PCB de cada proceso contiene una tabla donde se listan los archivos abiertos por el proceso.
La tabla contiene para cada archivo un puntero a la entrada correspondiente del mismo archivo en la tabla global de archivos abiertos, asÃ­ como otras informaciones adicionales que son particulares de cada proceso.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_montaje_de_sistemas_de_archivos">22.3. Montaje de sistemas de archivos</h3>
<div class="paragraph">
<p>Un sistema de archivos debe <em>montarse</em> para que sus archivos sean accesibles a los procesos del sistema.
El proceso de montaje incluye los siguientes pasos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Al sistema operativo se le debe proporcionar el nombre o identificador del dispositivo y el punto de montaje.
El <strong>punto de montaje</strong> es la ubicaciÃ³n dentro de la estructura de directorios âel directorio concretoâ a la que queremos conectar el sistema de archivos</em>.
DespuÃ©s de que el proceso de montaje se haya completado, los archivos y directorios del sistema de archivos montado serÃ¡n accesibles como descendientes del directorio del punto de montaje.</p>
</li>
<li>
<p>A continuaciÃ³n <em>el sistema operativo verifica que el dispositivo contiene un sistema de archivos vÃ¡lido</em>.
Para ello lee el <em>bloque de control de volumen</em> y comprueba que tiene un formato vÃ¡lido.</p>
</li>
<li>
<p>Finalmente <em>el sistema operativo registra en la tabla de montaje _el tipo de sistema de archivos y el identificador del del dispositivo montado, mientras en la copia en memoria del FCB del directorio que hace de punto de montaje almacena un identificador de la entrada correspondiente en la tabla de montaje</em>.
Esto permite que pueda ser recorrida la estructura de directorios de distintos sistemas de archivos, pasando de uno a otro de forma transparente, segÃºn sea necesario.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>En muchos sistemas operativos modernos el montaje se ejecuta automÃ¡ticamente cuando los dispositivos son detectados durante el arranque del sistema o cuando se conectan durante el funcionamiento del mismo âpor ejemplo, cuando se inserta un medio en la unidad CD-ROM o se pincha una memoria flash en un puerto USBâ.
AdemÃ¡s, en algunos se permite que el administrador del equipo ejecute operaciones de montaje manuales.</p>
</div>
</div>
<div class="sect2">
<h3 id="_archivos">22.4. Archivos</h3>
<div class="paragraph">
<p>Cada sistema de archivos almacena en disco una tabla donde cada entrada guarda un bloque de control de archivo o FCB (File Control Block) por archivo.
Concretamente, en cada FCB se almacena diversa informaciÃ³n acerca del archivo al que representa.</p>
</div>
<div class="sect3">
<h4 id="_atributos_de_archivos">22.4.1. Atributos de archivos</h4>
<div class="paragraph">
<p>La colecciÃ³n de atributos asociada a un archivo varÃ­a de un sistema operativo a otro, pero tÃ­picamente son los siguientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Nombre</strong>.
Nombre simbÃ³lico del archivo que se mantiene en un formato legible para conveniencia de las personas.</p>
</li>
<li>
<p><strong>Identificador</strong>.
Identifica de forma unÃ­voca el archivo dentro del sistema de archivos.
Generalmente es el Ã­ndice del FCB en la tabla de contenidos del volumen, donde se almacenan los FCB.</p>
</li>
<li>
<p><strong>Tipo</strong>.
Es un atributo necesario en los sistemas que soportan diferentes tipos de archivos.</p>
</li>
<li>
<p><strong>UbicaciÃ³n</strong>.
Es un puntero a un dispositivo y a la ubicaciÃ³n del archivo dentro del mismo.</p>
</li>
<li>
<p><strong>TamaÃ±o</strong>.
Indica el tamaÃ±o actual de archivo âen bytes, palabras o bloquesâ y, posiblemente, el tamaÃ±o mÃ¡ximo permitido.</p>
</li>
<li>
<p><strong>ProtecciÃ³n</strong>.
InformaciÃ³n de control de acceso que determina quiÃ©n puede leerlo, escribirlo, ejecutarlo, etc.</p>
</li>
<li>
<p><strong>Fecha, hora e identificaciÃ³n del usuario</strong>.
Esta informaciÃ³n puede mantenerse para los sucesos de creaciÃ³n, de Ãºltima modificaciÃ³n y Ãºltimo uso del archivo.
Esto puede resultar Ãºtil para la protecciÃ³n, seguridad y monitorizaciÃ³n del uso del archivo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los atributos de los archivos se almacenan en las estructuras de metadatos.
Normalmente el nombre se almacena en la estructura de directorios, de tal manera que una entrada de directorio estÃ¡ compuesta del nombre de un archivo y del identificador de su FCB.
Dicho identificador permite localizar el FCB en la tabla de contenidos del volumen, que contiene el resto de los atributos del archivo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_operaciones_con_los_archivos">22.4.2. Operaciones con los archivos</h4>
<div class="paragraph">
<p>Un archivo es un tipo abstracto de datos sobre el que pueden realizarse diversas operaciones.
Concretamente <em>el sistema operativo proporciona llamadas al sistema para: crear, escribir, leer, reposicionar<sup class="footnote">[<a id="_footnoteref_24" class="footnote" href="#_footnotedef_24" title="View footnote.">24</a>]</sup>, borrar y truncar archivos</em>.
AdemÃ¡s en muchos sistemas se suelen incluir llamadas para otras operaciones comunes, como aÃ±adir datos al final de un archivo o el renombrado de un archivo existente.
Estas operaciones primitivas puede combinarse a su vez para realizar otras operaciones mÃ¡s complejas âpor ejemplo, crear una copia de un archivo o moverlo a otro lugar de la estructura de directoriosâ.
AdemÃ¡s, muchos sistemas tambiÃ©n disponen de operaciones para consultar y modificar diversos atributos de un archivo, como la longitud o el propietario del mismo.</p>
</div>
<div class="paragraph">
<p>La mayor parte de estas operaciones implican realizar una bÃºsqueda en el directorio para encontrar la entrada asociada con el archivo cuyo nombre se ha indicado.
Para evitarlo <em>muchos sistemas requieren<sup class="footnote">[<a id="_footnoteref_25" class="footnote" href="#_footnotedef_25" title="View footnote.">25</a>]</sup> que el proceso haga una llamada al sistema open(), antes de realizar cualquiera de estas operaciones por primera vez sobre un archivo</em>.
En concreto esta llamada al sistema:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Busca en el directorio el nombre del archivo hasta encontrar la entrada asociada y recupera el identificador del mismo.</p>
</li>
<li>
<p>Utiliza el identificador del archivo para recuperar el FCB correspondiente.</p>
</li>
<li>
<p>Crea una entrada para el archivo en la tabla de archivos abiertos donde se almacena la informaciÃ³n del FCB.</p>
</li>
<li>
<p>Retorna devolviendo un identificador âen forma de puntero o de Ã­ndiceâ a la nueva entrada en la tabla de archivos abiertos.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>El nombre con el que se designa a esas entradas en la tabla de archivos abiertos varÃ­a de unos sistemas a otros.
En los sistemas UNIX se utiliza el tÃ©rmino <strong>descriptor de archivo</strong> âo <em>file descriptor</em>â mientras que en los sistemas Microsoft Windows se prefiere el tÃ©rmino <strong>manejador de archivo</strong> âo <em>file handler</em>â.</p>
</div>
<div class="paragraph">
<p>DespuÃ©s de utilizar la llamada al sistema <code>open()</code>, cuando se desee solicitar una operaciÃ³n sobre un archivo, sÃ³lo es necesario proporcionar el identificador devuelto, evitando asÃ­ que haga falta realizar exploraciÃ³n alguna del directorio.
Cuando el archivo deja de ser utilizado activamente por el proceso, puede ser cerrado utilizado la llamada al sistema <code>close()</code>.</p>
</div>
<div class="paragraph">
<p><em>En los sistemas operativos donde varios procesos pueden abrir un mismo archivo se suelen utilizar dos niveles de tablas de archivos abiertos</em>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Una tabla para cada proceso âalmacenada en el PCBâ donde se indican todos los archivos que Ã©ste ha abierto</em>.
En dicha tabla se almacena toda la informaciÃ³n referente al uso de cada archivo por parte de un proceso.
Por ejemplo, se puede almacenar la posiciÃ³n actual utilizada por las operaciones de lectura y escritura o los derechos de acceso.</p>
</li>
<li>
<p><em>Una tabla global para todo el sistema donde se almacena toda la informaciÃ³n independiente de los procesos</em>, como la ubicaciÃ³n del archivo en el disco, las fechas de acceso y el tamaÃ±o del archivo.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando un proceso invoca la llamada <code>open()</code> se aÃ±ade una entrada en la tabla de archivos abiertos del proceso, que a su vez apunta a la entrada correspondiente dentro de la tabla global del sistema.
Si el archivo no existe en esta Ãºltima, tambiÃ©n hay que crear una entrada en la tabla global del sistema haciendo uso de la informaciÃ³n contenida en disco en el FCB correspondiente.
Es muy comÃºn que la tabla global almacene un <em>contador de aperturas</em> para cada archivo con el objetivo de indicar cuantos procesos lo mantienen abierto.
Dicho contador se decrementa con cada llamada al sistema <code>close()</code>, de forma que cuando alcance cero querrÃ¡ decir que la entrada puede ser eliminada de la tabla global de archivos abiertos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tipos_de_archivo">22.4.3. Tipos de archivo</h4>
<div class="paragraph">
<p>Cuando se diseÃ±a un sistema operativo es necesario considerar si debe reconocer y soportar el concepto de tipo de archivo.
Si el sistema operativo reconoce el tipo de un archivo puede operar con el mismo de formas razonables.
Por ejemplo, el sistema puede impedir que un usuario intente imprimir los archivos que contienen programas en formato binario, pues el documento impreso serÃ­a ininteligible.</p>
</div>
<div class="paragraph">
<p>En los sistemas operativos mÃ¡s comunes las tÃ©cnicas utilizadas para implementar los tipos de archivo son las siguientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>En MSDOS y Microsoft Windows el tipo de archivo se incluye como parte del nombre del archivo</em>.
Es decir, el nombre se divide en dos partes: un nombre y una extensiÃ³n; normalmente separadas por un carÃ¡cter de punto.
El sistema puede utilizar la extensiÃ³n para conocer el tipo de archivo y el tipo de operaciones que se pueden realizar con el mismo.</p>
</li>
<li>
<p><em>En macOS cada archivo tiene un atributo que almacena el tipo</em> âpor ejemplo, <code>TEXT</code> para los archivos de texto o <code>APPL</code> para las aplicacionesâ y otro que contiene el nombre del programa que lo creÃ³.
Cuando el usuario hace clic con el ratÃ³n sobre el icono de un archivo, el programa que lo creÃ³ se ejecuta automÃ¡ticamente y el archivo se carga en la memoria.</p>
</li>
<li>
<p><em>En los sistemas UNIX se utiliza un <strong>nÃºmero mÃ¡gico</strong> almacenado al principio de algunos archivos</em> para indicar el tipo del mismo.
No todos los archivos tienen nÃºmeros mÃ¡gicos, por lo que se permite hacer sugerencias en forma de extensiones del nombre del archivo.
Sin embargo estas extensiones ni son obligatorias ni el sistema depende de ellas.
Fundamentalmente su objetivo es ayudar a los usuarios a determinar el tipo de contenido de un archivo, por lo que pueden ser utilizadas o ignoradas por cada aplicaciÃ³n concreta, en funciÃ³n de las preferencias de sus desarrolladores.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructura_de_directorios">22.5. Estructura de directorios</h3>
<div class="paragraph">
<p>Algunos sistemas de archivos pueden almacenar millones de archivos en terabytes de disco.
Para gestionar todos esos datos necesitamos organizarlos de alguna manera, lo que generalmente implica el uso de directorios.
<em>Un <strong>directorio</strong> puede considerarse una tabla de sÃ­mbolos que traduce los nombre de los archivos en los identificadores que permiten recuperar sus correspondientes entradas en la tabla de contenidos del volumen</em>, donde se almacenan los FCB.
A continuaciÃ³n vamos a estudiar los diversos esquemas para definir la estructura lÃ³gica del sistema de directorios.</p>
</div>
<div class="sect3">
<h4 id="_directorios_de_un_nivel">22.5.1. Directorios de un nivel</h4>
<div class="paragraph">
<p><em>En la estructura de directorios de un nivel todos los archivos estÃ¡n contenidos en un Ãºnico directorio</em>.
Esto presenta algunas limitaciones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando el nÃºmero de usuarios del sistema aumenta se hace mÃ¡s difÃ­cil que cada uno escoja nombres diferentes para sus archivos, lo cual es necesario puesto que todos los archivos se encuentran en el mismo directorio.</p>
</li>
<li>
<p>Incluso en los sistemas operativos monousuario puede ser difÃ­cil para un usuario mantener organizados sus datos a media que se incrementa el nÃºmero de archivos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este esquema fue utilizado por la primera versiÃ³n del sistema operativo MSDOS.</p>
</div>
</div>
<div class="sect3">
<h4 id="_directorio_de_dos_niveles">22.5.2. Directorio de dos niveles</h4>
<div class="paragraph">
<p><em>En la estructura de directorios de dos niveles cada usuario tiene su propio <strong>directorio de archivos de usuario</strong> o <strong>UFD</strong> (User File Directory) que cuelga del <strong>directorio maestro de archivos</strong> o <strong>MFD</strong> (Master File Directory)</em>.
Cuando un usuario se conecta al sistema o inicia un trabajo se explora el MFD, que es una tabla indexada por el nombre de los usuarios o por los nÃºmeros de cuenta, donde cada una de sus entradas apunta al UFD de dicho usuario.
Puesto que cada UFD incluye sÃ³lo los archivos del usuario al que pertenece, el sistema operativo puede confinar todas las operaciones que puede realizar un usuarios sobre los archivos a su UFD.
Sin embargo, aunque esto resuelve el problema de la colisiÃ³n de nombres entre diferentes usuarios, tambiÃ©n presenta algunas desventajas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La estructura descrita aÃ­sla a los usuarios, lo cual puede ser un problema cuando Ã©stos quieren compartir datos para cooperar en alguna tarea.
La soluciÃ³n pasa por utilizar <strong>nombres de ruta</strong> para designar a un archivo de forma unÃ­voca.
Por ejemplo, si el usuario <code>usera</code> quiere acceder a su archivo <code>test</code>, simplemente debe referirse a el como <code>test</code>.
Mientras que si quiere acceder al archivo <code>test</code> del usuario <code>userb</code>, debe utilizar un <em>nombre de ruta</em> como <code>/userb/test</code>, donde se indica el nombre del usuario y el nombre del archivo.
En general, cada sistema operativo utiliza su propia sintaxis par nombrar los archivos contenidos en los directorios de otros usuarios.</p>
</li>
<li>
<p>Incluso en este caso puede ser difÃ­cil para un usuario mantener organizados sus datos a media que se incrementa el nÃºmero de archivos personales.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_directorios_con_estructura_de_Ã¡rbol">22.5.3. Directorios con estructura de Ã¡rbol</h4>
<div class="paragraph">
<p><em>La estructura de directorio de dos niveles puede generalizarse en la estructura de directorios en Ã¡rbol de altura arbitraria</em>.
Esto permite que los usuarios puedan crear sus propios subdirectorios para organizar sus archivo de la forma mÃ¡s conveniente.</p>
</div>
<div class="paragraph">
<p>Cada sistema de archivos tiene un <strong>directorio raÃ­z</strong> que puede contener tanto archivos como otros directorios.
A su vez cada directorio puede contener un conjunto de archivos y subdirectorios.
Normalmente cada entrada de directorio incluye un bit donde se indica si dicha entrada apunta a un archivo o a un subdirectorio.
Esto se hace asÃ­ porque los directorios no son mÃ¡s que archivos con un formato interno especial, por lo que el sistema debe saber si la entrada apunta a un directorio para interpretar correctamente los datos del directorio.</p>
</div>
<div class="paragraph">
<p>Generalmente en el PCB de cada proceso se guarda cual es su <strong>directorio de trabajo actual</strong>, de forma que cuando se hace referencia a un archivo usando solo su nombre, se le busca en ese directorio.
Si se necesita un archivo que no se encuentra en el directorio de trabajo actual, entonces el usuario debe especificar un nombre de ruta desde el directorio de trabajo actual.
O cambiar con una llamada al sistema el directorio de trabajo del proceso al directorio donde estÃ¡ almacenado el archivo.
Los nombres de ruta pueden ser de dos tipos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Un <strong>nombre de ruta absoluto</strong> comienza en la raÃ­z y va indicando los directorios que componen la ruta de forma descendente hasta llegar al archivo especificado</em>.</p>
</li>
<li>
<p><em>Un <strong>nombre de ruta relativo</strong> define una ruta a partir del directorio actual</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Con una estructura de directorios en Ã¡rbol se puede permitir que unos usuarios accedan a los archivos de otros.
Para eso sÃ³lo es necesario que se utilicen nombres de ruta para designar los archivos o que se cambie el directorio de trabajo actual.</p>
</div>
<div class="paragraph">
<p>Este tipo de estructura de directorios es la utilizada por MSDOS y por las distintas versiones de Microsoft Windows.</p>
</div>
</div>
<div class="sect3">
<h4 id="_directorios_en_grafo_acÃ­clico">22.5.4. Directorios en grafo acÃ­clico</h4>
<div class="paragraph">
<p>La estructura de directorio en grafo acÃ­clico es una generalizaciÃ³n natural del esquema con estructura en Ã¡rbol.
A diferencia de Ã©ste Ãºltimo, <em>la estructura en grafo acÃ­clico permite que los mismo archivos y subdirectorios existan simultÃ¡neamente en distintos lugares de la estructura de directorios.</em> Esto, por ejemplo, hace que los usuarios puedan compartir archivos de forma que se puedan acceder a los mismo directamente desde el directorio propiedad de los distintos usuarios.
Indudablemente eso significa que para acceder a un archivo o directorio pueden existir diversas rutas.</p>
</div>
<div class="paragraph">
<p>Los archivos y subdirectorios compartidos pueden implementarse de diversas formas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Se pueden crear una entrada de directorio denominada <strong>enlace</strong></em>.
Un enlace es, generalmente, un archivo que contiene la ruta relativa o absoluta de otro archivo o subdirectorio.
En los sistemas UNIX a estos se los conoce como <strong>enlaces simbÃ³licos</strong>.</p>
</li>
<li>
<p><em>TambiÃ©n se pueden duplicar toda la informaciÃ³n de la entrada de directorio del archivo compartido en todos los directorios que tambiÃ©n contienen dicho archivo</em>.
AsÃ­, mientras que los <em>enlaces</em> son claramente diferentes de la entrada original de directorio, las entradas de directorio duplicadas hacen que la entrada original y la copia sean indistinguibles.
En los sistemas UNIX a las entradas duplicadas se las conoce como <strong>enlaces duros</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Una estructura en grafo acÃ­clico es mÃ¡s flexible que una estructura en Ã¡rbol, pero no por eso estÃ¡ exenta de inconvenientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Si estamos intentando recorrer el sistema de archivos completo</em> âpor ejemplo, para buscar un archivo o para copiarlos en un dispositivo de copias de seguridadâ <em>debemos evitar acceder mÃ¡s de una vez a los archivos y subdirectorios compartidos</em>.
No olvidemos que en los sistemas con estructura en grafo acÃ­clico cada archivo puede tener mÃºltiples nombres de ruta absoluta.
Esto es mÃ¡s sencillo de resolver en el caso de los enlaces, puesto que podemos evitar recorrerlos al ser claramente distinguibles del archivo original.</p>
</li>
<li>
<p>Â¿CuÃ¡ndo puede liberarse el espacio asignado a un archivo compartido? Si lo hacemos cuando un usuario lo borra podrÃ­amos dejar punteros que referencian a archivos que no existen.</p>
</li>
<li>
<p>El caso mÃ¡s sencillo de resolver es el de los <em>enlaces</em> ya que pueden ser borrados sin que el archivo original se vea afectado, puesto que lo que se elimina es el enlace y no el archivo original.</p>
<div class="ulist">
<ul>
<li>
<p>Si lo que se pretende borrar es la entrada de un archivo original que es apuntado desde un <em>enlace</em>, entonces no hay problema en hacerlo y liberar el espacio asignado al mismo, dejando que el enlace apunte a un archivo que no existe.
Ciertamente podrÃ­amos plantearnos la posibilidad de buscar esos enlaces y eliminarlos pero, a menos que el FCB de cada archivo guarde las rutas a los enlaces que le seÃ±alan, esta bÃºsqueda puede ser muy costosa.
Por eso lo mÃ¡s comÃºn es conservar los enlaces hasta que se produzca un intento de utilizarlos, en cuyo caso determinaremos que el archivo referenciado fue borrado y trataremos el acceso al enlace de forma similar a cualquier otro acceso ilegal a un archivo que no existe.</p>
</li>
<li>
<p>Otra opciÃ³n es almacenar en la entrada del archivo original un contador con el nÃºmero de referencias al archivo.
AsÃ­, cuando el contador sea 0, sabremos que a llegado el momento de liberar el espacio asignado.
En los sistemas UNIX se utiliza esta tÃ©cnica para los <em>enlaces duros</em>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por Ãºltimo <em>no debemos olvidar que la estructura de directorios en grafo se conserva acÃ­clica si se prohÃ­be que hayan mÃºltiples referencias a un mismo directorio</em>.
Ese es el motivo por el que en los sistemas UNIX no se permite que los <em>enlaces duros</em> hagan referencia a directorios.
Sin embargo si se pueden utilizar <em>enlaces simbÃ³licos</em> para este fin, puesto que al ser distinguibles del directorio original podemos evitar los ciclos si mientras se explora se ignorar dichos enlaces.</p>
</div>
</div>
<div class="sect3">
<h4 id="_directorios_en_forma_de_grafo_general">22.5.5. Directorios en forma de grafo general</h4>
<div class="paragraph">
<p>Uno de los principales problemas de la estructura de directorios en grafo acÃ­clico es garantizar que no exista ningÃºn ciclo.
Esto es interesante puesto que mientras sea asÃ­ los algoritmos diseÃ±ados para recorrer el grafo y para determinar cuando no existen mÃ¡s referencias a un archivo son relativamente simples.
No olvidemos que:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Es importante evitar encontrar cualquier archivo dos o mÃ¡s veces</em>, tanto por razones de correcciÃ³n como de rendimiento.</p>
</li>
<li>
<p><em>En una estructura de directorios en forma de grafo general donde existan ciclos puede que el contador de referencias no sea 0, aunque no hayan mÃ¡s referencias al archivo</em>.
Esto significa que generalmente se necesita algÃºn mecanismo de recolecciÃ³n de basura<sup class="footnote">[<a id="_footnoteref_26" class="footnote" href="#_footnotedef_26" title="View footnote.">26</a>]</sup> para determinar con seguridad cuando se ha borrado la Ãºltima referencia.
Sin embargo la recolecciÃ³n de basura para un sistema de archivos basado en disco consume mucho tiempo, por lo que en pocas ocasiones se utiliza.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por tanto, es mucho mÃ¡s sencillo trabajar con estructuras de directorio en grafo acÃ­clico.
Para evitar que en un grafo aparezca un ciclo al aÃ±adir un nuevo enlace, se pueden utilizar diversos algoritmos.
Sin embargo, puesto que suelen ser muy costosos, lo mÃ¡s simple es ignorar todos los enlaces en los casos en los que se recorre el Ã¡rbol de directorios para realizar una tarea en la que es importante no entrar en un bucle âpor ejemplo, al hacer una bÃºsquedaâ En el caso de la duplicaciÃ³n de entradas de directorio âdonde las entradas duplicadas no se pueden distinguir de la original y, por tanto, no se pueden ignorarâ lo mÃ¡s sencillo es que el sistema operativo no permita crear mÃºltiples referencias a un mismo directorio.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comparticiÃ³n_de_archivos">23. ComparticiÃ³n de archivos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Como ya hemos comentado, el que los usuarios puedan compartir archivos es algo muy deseable pues permite que Ã©stos puedan colaborar en la realizaciÃ³n de una tarea determinada.
Sin embargo al aÃ±adir esta caracterÃ­stica hay que tener en cuenta algunos aspectos que deben ser resueltos en el diseÃ±o del sistema operativo.</p>
</div>
<div class="sect2">
<h3 id="_mÃºltiples_usuarios_y_protecciÃ³n">23.1. MÃºltiples usuarios y protecciÃ³n</h3>
<div class="paragraph">
<p>Cuando un sistema operativo admite mÃºltiples usuarios y utiliza una estructura de directorio que permite que Ã©stos compartan archivos, cobra gran importancia la protecciÃ³n de los datos.
En este sentido el sistema operativo debe adoptar un papel de mediador en lo que respecta a la comparticiÃ³n de los archivos.</p>
</div>
<div class="paragraph">
<p>Para implementar la comparticiÃ³n y los mecanismos de protecciÃ³n el sistema debe soportar mÃ¡s atributos para cada archivo y directorio que los que necesita en un sistema monousuario.
Aunque a lo largo de la historia se han adoptado diversos enfoques, la mayorÃ­a han evolucionado hasta utilizar los conceptos de <em>propietario</em> (o <em>usuario</em>) y <em>grupo</em> de un archivo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>El propietario de un archivo es el usuario que puede cambiar los atributos y conceder el acceso</em>.
Se trata del usuario que dispone del mayor grado de control sobre el archivo.</p>
</li>
<li>
<p><em>El grupo es un conjunto de usuarios que pueden compartir el acceso al archivo</em>.
El propietario del archivo es quien define que operaciones pueden ser ejecutadas por los miembros del grupo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los identificadores del propietario y el grupo de un archivo se almacenan junto con los otros atributos en el FCB.
Cuando un usuarios solicita realiza una operaciÃ³n sobre un archivo, se compara el identificador del usuario con el atributo del propietario para determinar si el solicitante es el propietario.
Exactamente de la misma manera se puede proceder con los identificadores de grupo.
El resultado de la comparaciÃ³n indicarÃ¡ que permisos son aplicables.
A continuaciÃ³n el sistema aplicarÃ¡ dichos permisos a la operaciÃ³n solicitada y la autorizarÃ¡ o denegarÃ¡ segÃºn sea el caso.</p>
</div>
<div class="paragraph">
<p>Existen diversas implementaciones del esquema utilizado para determinar los permisos aplicables aun usuario que pretende operar sobre un archivo concreto:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El esquema mÃ¡s general consiste en <em>asociar a cada archivo o directorio una <strong>lista de control de acceso</strong> o <strong>ACL</strong> (Access-control list) que especifique los nombres de usuario o grupos y los tipos de acceso para cada uno</em>.
Cuando un usuario solicita acceder a un archivo concreto, el sistema operativo comprueba la ACL asociada a dicho archivo.
Si dicho usuario, o alguno de sus grupos, estÃ¡ incluido en la lista para el tipo de acceso solicitado, se permite el acceso.
Esta tÃ©cnica presenta diversas ventajas e inconvenientes:</p>
<div class="ulist">
<ul>
<li>
<p><em>Se trata de la tÃ©cnica mÃ¡s general</em>, permitiendo la implementaciÃ³n de polÃ­ticas de acceso muy complejas.</p>
</li>
<li>
<p>Sin embargo, <em>construir la lista puede ser una tarea tediosa</em>.
Por ejemplo, si queremos que varios usuarios puedan leer unos archivos determinados, es necesario enumerar todos los usuarios que disponen de ese acceso en las ACL de dichos archivos.</p>
</li>
<li>
<p><em>El FCB, que hasta el momento tenÃ­a un tamaÃ±o fijo, ahora tendrÃ¡ que ser de tamaÃ±o variable para almacenar la ACL</em>, lo que requiere mecanismos mÃ¡s complejos de gestiÃ³n del espacio.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Para solucionar algunos de los problemas de las ACL <em>muchos sistemas utilizan listas de control de acceso condensadas</em>.
Para condensar la longitud de la lista de control de acceso, muchos sistemas clasifican a los usuarios en tres grupos: <em>propietario</em>, <em>grupo</em> y <em>otros</em>.
AsÃ­ sÃ³lo es necesario un campo para cada clase de usuario, siendo cada campo una colecciÃ³n de bits, donde cada uno permite o deniega el tipo de acceso asociado al mismo.
Por ejemplo, en los sistemas UNIX se definen 3 campos (<em>propietario</em>, <em>grupo</em> y <em>otros</em>) de 3 bits cada uno: <code>rwx</code>, donde <code>r</code> controla el acceso de lectura, <code>w</code> controla el acceso de escritura y <code>x</code> controla la ejecuciÃ³n.
Las ACL condensadas son mÃ¡s sencillas de construir, al mismo tiempo que por tener una longitud fija es mucho mÃ¡s simple gestionar el espacio para el FCB donde se almacena.</p>
</li>
<li>
<p><em>La tÃ©cnica mÃ¡s comÃºn en los sistemas operativos modernos consiste en combinar ambos tipos de listas de control de acceso</em>.
Sin embargo esta soluciÃ³n no estÃ¡ exenta de dificultades:</p>
<div class="ulist">
<ul>
<li>
<p><em>Uno de los problemas es que los usuarios deben poder determinar cuando estÃ¡n activados los permisos ACL mÃ¡s generales</em>.
En Linux, por ejemplo, se utiliza el sÃ­mbolo <code>+</code> a listar los permisos de la ACL condensada para indicar dicha circunstancia.
Esos permisos pueden ser gestionados utilizando los comandos <code>setfacl</code> y <code>getfacl</code>.</p>
</li>
<li>
<p><em>Otra dificultad es la relativa a la asignaciÃ³n de precedencias cuando ambas ACL entran en conflicto</em>.
En general se suele asignar a la ACL mÃ¡s prioridad que a la ACL condensada, pues la primera tiene una granularidad mÃ¡s fina y no se crea de forma predeterminada.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>La familia de sistemas operativos Microsoft Windows utiliza las ACL mÃ¡s generales, mientras que en los sistemas operativos Linux y Solaris se implementan ambos tipos de ACL.</p>
</div>
<div class="paragraph">
<p><em>Otra tÃ©cnica para resolver el problema de la protecciÃ³n consiste en asociar una contraseÃ±a con cada archivo o directorio</em>.
Sin embargo esto tiene el inconveniente de que el nÃºmero de contraseÃ±as que un usuario puede tener que recordar puede ser muy grande.
No olvidemos que si se utiliza la misma contraseÃ±a para todos los archivo, desde el momento en que esa contraseÃ±a sea descubierta todos los archivos serÃ¡n accesibles.</p>
</div>
</div>
<div class="sect2">
<h3 id="_semÃ¡ntica_de_coherencia">23.2. SemÃ¡ntica de coherencia</h3>
<div class="paragraph">
<p><em>La <strong>semÃ¡ntica de coherencia</strong> especifica cuando las modificaciones que un usuario realice en los archivos serÃ¡n observables por los otros usuarios</em>.
La semÃ¡ntica de coherencia estÃ¡ directamente relacionada con los algoritmos de sincronizaciÃ³n de procesos (vÃ©ase tema <a href="#_sincronizaciÃ³n">CapÃ­tulo 13</a>).
Sin embargo es normal que esos complejos algoritmos no se implementen en el caso de la E/S de archivo, debido a la alta latencia y las bajas velocidades de la transferencia de los discos y de las redes.</p>
</div>
<div class="paragraph">
<p>A continuaciÃ³n vamos comentar algunos ejemplos de semÃ¡ntica de coherencia:</p>
</div>
<div class="sect3">
<h4 id="_semÃ¡ntica_de_unix">23.2.1. SemÃ¡ntica de UNIX</h4>
<div class="paragraph">
<p>Los sistemas de archivos de los sistemas operativos UNIX utilizan la siguiente semÃ¡ntica de coherencia:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Las escrituras en un archivo abierto por parte de un proceso son visibles inmediatamente para los procesos que tengan abierto el mismo archivo</em>.</p>
</li>
<li>
<p><em>Existe un modo de comparticiÃ³n que permite a los procesos compartir el puntero de ubicaciÃ³n actual dentro del archivo</em>.
AsÃ­, el incremento de ese puntero por parte de un proceso afecta a todos los procesos que estÃ©n compartiendo el archivo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En la semÃ¡ntica de UNIX cada archivo estÃ¡ asociado con una Ãºnica imagen fÃ­sica a la que se accede en forma de recurso de acceso exclusivo âpor ejemplo, un proceso que haga un <code>read()</code> sobre un archivo podrÃ¡ quedar en espera si al mismo tiempo otro proceso estÃ¡ ejecutando un <code>write()</code>, hasta que este Ãºltimo termineâ.
La contienda por acceder a esta imagen Ãºnica provoca retardos en los procesos debido a estos bloqueos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_semÃ¡ntica_de_sesiÃ³n">23.2.2. SemÃ¡ntica de sesiÃ³n</h4>
<div class="paragraph">
<p>Suponiendo que <em>una <strong>sesiÃ³n de archivo</strong> es el conjunto de operaciones entre las llamadas `open()`y `close()`</em>, el sistema de archivos Andrew âo AFSâ utiliza la siguiente semÃ¡ntica de coherencia:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Las escrituras en un archivo abierto por parte de un proceso no son visibles inmediatamente para los otros usuarios que hayan abierto ese mismo archivo</em>.</p>
</li>
<li>
<p><em>Una vez que se cierra un archivo, los cambios realizados en Ã©l son visibles Ãºnicamente en las sesiones que comiencen posteriormente</em>.
Las sesiones ya abiertas sobre el archivo no reflejarÃ¡n dichos cambios.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Esto significa que un archivo puede permanecer temporalmente asociado a varias imÃ¡genes fÃ­sicas al mismo tiempo.
AsÃ­ se permite que mÃºltiples usuarios realicen accesos concurrentes, tanto de lectura como de escritura, en sus propias imÃ¡genes del archivo, evitando los retardos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_semÃ¡ntica_de_archivos_compartidos_inmutables">23.2.3. SemÃ¡ntica de archivos compartidos inmutables</h4>
<div class="paragraph">
<p>En esta semÃ¡ntica, <em>cuando un archivo es declarado como compartido por su creador ya no puede ser ser modificado</em>.
Estos archivos inmutables cumplen dos propiedades clave: su nombre no puede reutilizarse y su contenido no puede ser modificado.
AsÃ­ podemos estar seguros de que el contenido de un archivo inmutable es fijo.
La implementaciÃ³n de esta semÃ¡ntica en un sistema distribuido es muy simple.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bloqueos_de_archivo">23.3. Bloqueos de archivo</h3>
<div class="paragraph">
<p>Algunos sistemas operativos proporcionan funciones para bloquear un archivo âo determinadas porciones de un archivoâ abierto.
Esto permite que un proceso <em>impida que otros procesos puedan acceder al archivo bloqueado</em>.
Los bloqueos de archivo resultan Ãºtiles para encadenar varias operaciones de E/S sobre un archivo teniendo la seguridad de que otros procesos no podrÃ¡n hacer modificaciones en el mismo mientras tanto.</p>
</div>
<div class="paragraph">
<p>Los sistemas operativos pueden proporcionar diferentes tipos de bloqueos de archivo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Un <strong>bloqueo compartido</strong> es un tipo de bloqueo que puede ser adquirido âbloquear el archivoâ al mismo tiempo por varios procesos.</em></p>
</li>
<li>
<p><em>Un <strong>bloqueo exclusivo</strong> sÃ³lo puede ser adquirido por un proceso cada vez</em>.
Si otro proceso intenta adquirir bloqueo exclusivo sobre un archivo ya bloqueado, se suspende a la espera.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Algunos sistemas operativos sÃ³lo proporcionan el <em>bloqueo exclusivo</em>.
Sin embargo en los que implementan ambos tipos de bloqueo, lo normal es que los procesos que pretenden acceder a un archivo compartido para sÃ³lo lectura utilicen el <em>bloqueo compartido</em>, mientras que los que acceden para modificar el contenido utilicen el <em>bloqueo exclusivo</em>.
AsÃ­ varios procesos puedan leer el archivo al mismo tiempo, pero si un proceso accede para escribir ningÃºn otro podrÃ¡ acceder ni para leer ni para escribir.</p>
</div>
<div class="paragraph">
<p>AdemÃ¡s los sistemas operativos pueden proporcionar mecanismos de bloqueo de archivos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Obligatorios</strong>.
Si un bloqueo es obligatorio, despuÃ©s de que un proceso adquiera un bloqueo exclusivo, <em>el sistema operativo impedirÃ¡ a todos los demÃ¡s procesos que hagan cualquier operaciÃ³n sobre el archivo bloqueado</em>.
Esto ocurrirÃ¡ incluso si los otros procesos no han sido programados para intentar adquirir el bloqueo.
Por tanto, el sistema operativo es el encargado de garantizar que los bloqueos se cumplen, haciendo las comprobaciones pertinentes en las llamadas al sistema.</p>
</li>
<li>
<p><strong>Sugeridos</strong>.
Si un bloqueo es sugerido, <em>el sistema operativo sÃ³lo impedirÃ¡ que accedan al archivo bloqueado aquellos procesos programados para adquirir el bloqueo explÃ­citamente</em> âusando la llamada al sistema correspondienteâ.
El sistema operativo no impedirÃ¡ el acceso al archivo a un proceso que lo abre, lee o escribe sin mÃ¡s.
Son los desarrolladores del software los encargados de intentar adquirir el bloqueo y de liberarlo cuando ya no es necesario.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Como regla general los sistemas operativos Microsoft Windows implementan un mecanismo de bloqueo obligatorio, mientras que los sistemas UNIX emplean bloqueos sugeridos.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_coherencia">24. Coherencia</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Como hemos comentado anteriormente, parte de los metadatos se almacena en la memoria principal para acelerar el acceso.
Dicha informaciÃ³n generalmente estÃ¡ mÃ¡s actualizada que la correspondiente en el disco, puesto que la informaciÃ³n almacenada en la memoria no tiene porque ser escrita inmediatamente despuÃ©s de una actualizaciÃ³n.</p>
</div>
<div class="paragraph">
<p>Â¿QuÃ© ocurrirÃ­a entonces si fallase el sistema? Pues que el contenido de la cachÃ© y de los bÃºferes se perderÃ­a y con ellos tambiÃ©n los cambios realizados en los directorios y archivos abiertos.
Esto puede dejar el sistema de archivos en un estado incoherente, pues el estado real de algunos archivos no serÃ­a el que se describe en la estructura de metadatos.</p>
</div>
<div class="sect2">
<h3 id="_comprobaciÃ³n_de_coherencia">24.1. ComprobaciÃ³n de coherencia</h3>
<div class="paragraph">
<p><em>El <strong>comprobador de coherencia</strong> comprueba la estructura de metadatos y tratar de corregir todas las incoherencias que detecte</em>.</p>
</div>
<div class="paragraph">
<p>Los algoritmos de asignaciÃ³n y de gestiÃ³n del espacio de almacenamiento dictan los tipos de problemas que el comprobador puede tratar de detectar y tambiÃ©n el grado de Ã©xito que el comprobador puede tener en esa tarea.
Por ejemplo la pÃ©rdida de un FCB, cuando es este el que almacena la lista de bloques que contienen los datos del archivo, es desastrosa porque no hay forma de saber en todo el disco que datos le pertenecen.
Por esta razÃ³n UNIX almacena en cachÃ© las entradas de directorio para acelerar las lecturas, pero todas las escrituras de datos que provoquen algÃºn cambio en la asignaciÃ³n de espacio o en algÃºn otro tipo de metadato se realizan sÃ­ncronamente âantes de volver al proceso desde la llamada al sistemaâ.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si se hace un escritura de datos que extiende el tamaÃ±o de un archivo; el cambio del FCB correspondiente, con el nuevo tamaÃ±o de archivo y la lista actualizada de las direcciones de los bloques que contienen o van a contener los datos del archivo, se escribe en disco antes de terminar la llamada al sistema y devolver el control al proceso que la invocÃ³.
Sin embargo, no ocurre lo mismo con los datos que el proceso querÃ­a escribir en el archivo.
El sistema operativo puede copiarlos a bÃºferes internos en la memoria para escribirlos en disco mÃ¡s adelante, evitando interrumpir el proceso durante mÃ¡s tiempo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_soft_updates">24.2. Soft Updates</h3>
<div class="paragraph">
<p>Para mejorar la eficiencia del sistema de archivos, sin comprometer la coherencia en caso de fallo, los distintos sabores de los sistemas UNIX BSD utilizan una tÃ©cnica denominada <em>soft updates</em>.
<em>Cuando se monta un sistema de archivos con la opciÃ³n <strong>soft updates</strong> el sistema operativo desactiva la escritura sÃ­ncrona de los metadatos, permitiendo que estos sean escritos cuando los algoritmos de gestiÃ³n de la cachÃ© lo consideren necesario, pero se impone cierto orden en el que dichas operaciones de escritura deben ser realizadas</em>.
Por ejemplo, cuando se van a escribir en el disco las modificaciones debidas a la creaciÃ³n de un nuevo archivo, el sistema se asegura de que primero se escribe el nuevo FCB âun <em>inodo</em>, en los sistemas UNIX BSDâ y posteriormente escribe el directorio con la nueva entrada de archivo con el identificador a dicho FCB.
Es sencillo darse cuenta de que haciÃ©ndolo al revÃ©s, si el sistema fallase antes de crear el FCB, acabarÃ­amos con una entrada de directorio que apuntarÃ­a a un FCB invÃ¡lido.
Mientras que de esta manera el sistema de archivos permanecerÃ¡ consistente aunque el sistema falle entre ambas operaciones.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_archivos_basados_en_registro">24.3. Sistemas de archivos basados en registro</h3>
<div class="paragraph">
<p>Otra soluciÃ³n al problema de la coherencia consiste en aplicar tÃ©cnicas de recuperaciÃ³n basadas en registro durante las actualizaciones de los metadatos del sistema de archivos.</p>
</div>
<div class="paragraph">
<p>Fundamentalmente <em>en los <strong>sistemas de archivos basados en registro</strong> âo con <strong>journaling</strong>â todos los cambios en los metadatos se escriben secuencialmente en un registro</em><sup class="footnote">[<a id="_footnoteref_27" class="footnote" href="#_footnotedef_27" title="View footnote.">27</a>]</sup>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Cada conjunto de operaciones necesario para realizar una tarea especÃ­fica sobre el sistema de archivos es una <strong>transacciÃ³n</strong></em>.
Por ejemplo, es una transacciÃ³n el conjunto de operaciones necesarias para crear un nuevo archivo.</p>
</li>
<li>
<p><em>La lista de operaciones necesarias para completar una transacciÃ³n se escribe secuencialmente y sÃ­ncronamente âantes de terminar la llamada al sistemaâ en el registro</em>.
Cuando la lista de operaciones pendientes termina de ser escrita en el registro, se considera que las operaciones ha sido <em>confirmadas</em> y la llamada al sistema puede volver al proceso de usuario, permitiendo que continÃºe con su ejecuciÃ³n.</p>
</li>
<li>
<p>Mientras tanto, el sistema operativo va ejecutando las operaciones indicadas en el registro sobre las estructuras reales del sistema de archivos.
<em>A medida que se realizan los cambios se actualiza el registro para indicar las operaciones completadas</em>.</p>
</li>
<li>
<p><em>Cuando todas las operaciones de una transacciÃ³n se han ejecutado con Ã©xito, dicha transacciÃ³n se considera completada y se elimina del registro</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En el supuesto de que el sistema falle:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Se comprueba el registro durante el montaje del sistema de archivos, antes de que pueda ser utilizado de nuevo.</em></p>
</li>
<li>
<p><em>Todas las transacciones confirmadas que contenga el registro estarÃ¡n a medias</em>, por lo que serÃ¡ necesario terminar de aplicar las <em>operaciones pendientes</em> antes de finalizar el proceso de montaje.</p>
</li>
<li>
<p>Es posible que existan transacciones no confirmadas, es decir, transacciones que no terminaron de ser escritas en el registro antes del fallo y, por tanto, cuya lista de operaciones no estÃ¡ completa.
En ese caso, <em>todos los cambios correspondientes a las transacciones no confirmadas que hubieran sido aplicados al sistema de archivos, deberÃ¡n deshacerse</em> para preservar la coherencia.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Esta tÃ©cnica estÃ¡ empezando a resultar comÃºn en muchos sistemas operativos.
Hasta el punto de que es utilizada en sistemas tales como: ext3, ext4, NTFS, XFS, JFS, ReiserFS, etc.</p>
</div>
<div class="paragraph">
<p><em>Un efecto colateral de la utilizaciÃ³n de un registro es la mejora del rendimiento en el acceso al sistema de archivo</em>.
La razÃ³n de esta mejora es que las costosas escrituras sÃ­ncronas âes decir, antes de devolver el control al procesoâ de los metadatos en lugares aleatorios del volumen se transforman en escrituras sÃ­ncronas secuenciales âque son mucho mÃ¡s eficientesâ en el registro.
Mientras que todas las operaciones indicadas en el registro se aplican asÃ­ncronamente mediante escrituras aleatorias en las estructuras apropiadas, por lo que pueden ser reordenadas a conveniencia para maximizar el rendimiento.
Recordemos que en el registro pueden haber operaciones de distintos procesos que afecten a regiones prÃ³ximas del disco.
El resultado global es una significativa ganancia en la velocidad de las operaciones relativas a los metadatos, como por ejemplo la creaciÃ³n y borrado de archivos.</p>
</div>
<div class="paragraph">
<p>El sistema de archivos XFS modifica ligeramente esta tÃ©cnica, sustituyendo las escrituras sÃ­ncronas necesarias para actualizar el registro por escrituras asÃ­ncronas âes decir, el control se devuelve al proceso antes de terminar de escribir las operaciones en el registro y confirmar la transacciÃ³nâ.
El resultado es:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cierta mejora del rendimiento, porque el registro deja de ser el cuello de botella para las operaciones sobre los metadatos.
El registro es un recurso de acceso exclusivo.
Las operaciones de una transacciÃ³n se deben escribir antes de devolver el control al proceso y de permitir que otro proceso a la espera escriba las operaciones de su transacciÃ³n.</p>
</li>
<li>
<p>En el caso de que el sistema fallase, el uso de escrituras asÃ­ncronas podrÃ­a provocar la corrupciÃ³n del registro porque pueden ocurrir en cualquier orden.
Para evitarlo, XFS impone cierto orden en las operaciones de escritura sobre el registro, de forma similar a como se hace con los <em>soft updates</em>, de tal forma que asegura la coherencia del registro.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_archivos_basados_en_copia_durante_la_escritura">24.4. Sistemas de archivos basados en copia durante la escritura</h3>
<div class="paragraph">
<p><em>Las tÃ©cnicas anteriores son necesarias para preservar la coherencia porque la modificaciÃ³n de los metadatos se hace sobrescribiendo los datos que ya existen</em>.
Es decir, cuando se crea un nuevo archivo el sistema busca un FCB libre, sobrescribe el bloque del dispositivo donde lo encuentra para almacenar el nuevo FCB, busca una entrada libre en el directorio y, nuevamente, sobrescribe el bloque del disco donde se almacena el directorio para incorporar la nueva entrada.
Si algunos de estos cambios tienen lugar pero otros no, el disco puede quedar inconsistente.</p>
</div>
<div class="paragraph">
<p><em>Los <strong>sistemas de archivos basados en copia durante la escritura</strong></em> âo <em>copy-on-write</em>â <em>evitan cambiar los metadatos sobrescribiendo en el sitio</em>.
En su lugar buscan un hueco libre, hacen en Ã©l una copia del bloque completo con los cambios y despuÃ©s modifican los metadatos del sistema de archivos que sirven para localizar el bloque modificado en su nueva ubicaciÃ³n.
Estos cambios, a su vez, tampoco se hacen sobrescribiendo, sino que disparan la creaciÃ³n de copias modificadas de los bloques afectados, lo que nuevamente va seguido de cambios en los metadatos que ayudan a localizarlos.
El proceso se repite hasta que se alcanza el <em>bloque de control de volumen</em> y se cambia, momento en el que toda la secuencia de cambios se consolida.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivos basados en copy-on-write suele hacer hacer uso intensivo de estructuras de datos basadas en Ã¡rbol porque es muy sencillo mover un nodo de bloque, con un efecto mÃ­nimo en el resto de la estructura.
Por ejemplo, al crear un archivo:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Se busca un FCB libre, se lee el bloque que lo contiene en la memoria principal, se modifica y se escribe en un bloque libre</em>.
El sistema de archivos debe tener alguna estructura de datos que permita encontrar el bloque que contiene un FCB a partir de su identificador.
Por lo general esta estructura es algÃºn tipo de Ã¡rbol.
AsÃ­ que se modifica el nodo del Ã¡rbol que seÃ±ala al bloque con el nuevo FCB para que conozca la nueva ubicaciÃ³n.
Este cambio implica crear un copia del bloque de dicho nodo con el cambio, lo que a su vez significa modificar el nodo que seÃ±ala a este.
Y asÃ­ sucesivamente hasta llegar a la raÃ­z del Ã¡rbol de FCB.</p>
</li>
<li>
<p><em>Se busca una entrada libre en el directorio que va a contener al archivo y se modifica para aÃ±adir el nombre del archivo, el identificador de su FCB y otras propiedades</em>.
Nuevamente, este cambio significa crear una copia, con los cambios descritos, del bloque que contiene la entrada y modificar el FCB del directorio para que contenga la nueva ubicaciÃ³n del bloque con el contenido del directorio.
Como antes, este cambio en el FCB dispara copias y modificaciones por todo el Ã¡rbol de FCB, hasta la raÃ­z</p>
</li>
<li>
<p>Una vez la raÃ­z del Ã¡rbol ha sido copiada a una nueva ubicaciÃ³n con los cambios, se actualiza su nueva posiciÃ³n en el <em>bloque de control de volumen.</em></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Si el sistema falla antes de la modificaciÃ³n del <em>bloque de control de volumen</em>, durante el montaje del sistema de archivos no quedarÃ¡ ni rastro de ninguno de los cambios porque dicho bloque aun hace referencia a la antigua raÃ­z del Ã¡rbol de FCB y, a partir de ellas, a todos los nodos, bloques y FCB originales.
Obviamente los sistemas que implementan este tipo de sistemas de archivo usan la memoria principal como cachÃ© con el objeto de combinar varias modificaciones sobre un mismo bloque antes de proceder a su escritura en disco, evitando desencadenar mÃºltiples veces los cambios posteriores.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivos ZFS y Btrfs son los principales ejemplos de sistemas de archivos basados en <em>copy-on-write</em>.
Esta soluciÃ³n no sÃ³lo les permite tener las mismas propiedades que el uso de registro en cuanto a la preservaciÃ³n de la coherencia âcon la ventaja de evitar dos escrituras en disco, una en el registro y otra para el cambio propiamente dichoâ sino que ademÃ¡s facilita que puedan ofrecer caracterÃ­sticas adicionales, como la creaciÃ³n de copias instantÃ¡neas del volumen.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementaciÃ³n_de_sistemas_de_archivos">25. ImplementaciÃ³n de sistemas de archivos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Como ya se ha comentado, un sistema de archivos suele estar compuesto de varios niveles diferentes.
En la se muestra un ejemplo de la estructura de un sistema de archivos diseÃ±ado en niveles.
Cada nivel utiliza las funciones de los niveles inferiores y proporciona nuevas funciones a los niveles superiores.
Estos niveles han sido descritos en el apartado <a href="#_estructura_de_un_sistema_de_archivos">Apartado 22.1</a>, mientras que las estructuras de metadatos utilizadas tanto en la memoria como en disco fueron tratadas brevemente en el <a href="#_estructuras_de_metadatos">Apartado 22.2</a>.</p>
</div>
<div class="paragraph">
<p>A continuaciÃ³n vamos a profundizar aun mÃ¡s en las estructuras y operaciones utilizadas para implementar los sistemas de archivos</p>
</div>
<div class="sect2">
<h3 id="_implementaciÃ³n_de_directorios">25.1. ImplementaciÃ³n de directorios</h3>
<div class="paragraph">
<p>Cada directorio suele contener una estructura de datos que relaciona el nombre de cada archivo que contiene con el identificador de su FCB.
Dicho identificador permite localizar el FCB en la tabla de contenidos del volumen, que contiene el resto de los atributos del archivo.</p>
</div>
<div class="paragraph">
<p>En esta secciÃ³n vamos a estudiar las formas mÃ¡s comunes de implementar la estructura de datos de un directorio.</p>
</div>
<div class="sect3">
<h4 id="_lista_lineal">25.1.1. Lista lineal</h4>
<div class="paragraph">
<p>El mÃ©todo mas simple para implementar un directorio <em>consiste en utilizar una lista lineal o vector de nombres de archivos junto al identificador al FCB de cada uno</em>.</p>
</div>
<div class="paragraph">
<p>Las acciones a realizar, para implementar cada una de las posibles operaciones sobre el directorio, serÃ­an:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Crear un archivo</strong>.
Primero se explora el directorio para estar seguros de que no haya ningÃºn archivo con el mismo nombre.
DespuÃ©s se aÃ±ade una nueva entrada al final del directorio.</p>
</li>
<li>
<p><strong>Borrar un archivo</strong>.
Primero se explora la lista en busca del archivo especificado y una vez localizada se libera la entrada correspondiente.
Para reutilizar la entrada del directorio tenemos diversas alternativas:</p>
<div class="ulist">
<ul>
<li>
<p><em>Se puede marcar la entrada como no utilizada</em>.
Para eso se puede emplear un nombre especial o utilizar algÃºn campo adicional âa parte de nombre de archivo e identificador del FSBâ que se ha aÃ±adido a la entrada con ese propÃ³sito.</p>
</li>
<li>
<p><em>Insertar un puntero a la entrada en una lista de entradas libres</em>, que se guarda dentro del mismo directorio.</p>
</li>
<li>
<p><em>Copiar la Ãºltima entrada del directorio en la ubicaciÃ³n que ha quedado libre</em> y reducir la longitud del directorio.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>La principal desventaja de un directorio implementado como una lista lineal de entrada es que <em>para localizar un archivo es necesario realizar una bÃºsqueda lineal</em>, lo cual puede resultar muy costoso en directorios con un nÃºmero muy grande de archivos.
Utilizando una lista ordenada se puede reducir el tiempo medio de bÃºsqueda, pero eso complica los procesos de creaciÃ³n y borrado, pues puede que sea necesario mover cantidades importantes de informaciÃ³n para mantener la lista ordenada.
TambiÃ©n se <em>puede utilizar una lista enlazada tanto para reducir el tiempo necesario para borrar un archivo como para facilitar la tarea de mantener ordenada la lista</em>.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivos FAT y FAT32 implementan los directorios utilizando una lista lineal, donde en cada entrada no sÃ³lo se almacena el nombre del archivo sino tambiÃ©n el FCB del mismo.
Los sistemas de archivos ext2 y UFS tambiÃ©n utilizan una lista lineal no ordenada, donde sÃ³lo se almacena el nombre del archivo o subdirectorio y el identificador del <em>inodo</em> âel FCB, esos sistemas de archivoâ correspondiente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tabla_de_dispersiÃ³n">25.1.2. Tabla de dispersiÃ³n</h4>
<div class="paragraph">
<p>En los directorios implementados con una tabla de dispersiÃ³n tambiÃ©n <em>se almacenan las entradas de directorio en una lista lineal, pero al mismo tiempo se utiliza una tabla de dispersiÃ³n para reducir enormemente el tiempo de bÃºsqueda en el directorio</em>.
La tabla de dispersiÃ³n se indexa con un valor calculado por cierta funciÃ³n de dispersiÃ³n a partir del nombre del archivo para obtener la ubicaciÃ³n de dicho archivo dentro de la lista lineal.</p>
</div>
<div class="paragraph">
<p><em>El Ãºnico inconveniente es que debemos tratar la posible apariciÃ³n de colisiones</em>, que son aquellas situaciones en las que dos nombres de archivo proporcionan, al aplicar la funciÃ³n de dispersiÃ³n, la misma ubicaciÃ³n en la tabla.
Esto se puede resolver utilizando una lista enlazada en cada entrada de la lista âcada entrada en al lista seÃ±alarÃ­a la ubicaciÃ³n de la siguiente entrada de la lista que tiene el mismo valor para la funciÃ³n de dispersiÃ³nâ a cambio de que las bÃºsquedas sean un poco mÃ¡s lentas.
En cualquier caso, Ã©ste mÃ©todo serÃ¡ normalmente mÃ¡s rÃ¡pido que una bÃºsqueda lineal por todo el directorio.</p>
</div>
</div>
<div class="sect3">
<h4 id="_Ã¡rbol_b">25.1.3. Ãrbol B</h4>
<div class="paragraph">
<p>Para mantener el directorio ordenado, algunos sistemas de archivos modernos utilizan estructuras de datos en Ã¡rbol mÃ¡s sofisticadas, como por ejemplo Ã¡rboles B.</p>
</div>
<div class="paragraph">
<p>Un caso concreto es el sistema de archivos NTFS, utilizado por Microsoft Windows.
NTFS utiliza una estructura de datos denominada Ã¡rbol B+ para almacenar el Ã­ndice de los nombres de archivo contenidos en un directorio.
En la entrada en la MFT de cada directorio se almacena un atributo, denominado <em>raÃ­z del Ã­ndice</em> que, si el directorio es de pequeÃ±o tamaÃ±o, contiene todas las entradas de archivos del directorio.
Pero para un directorio de gran tamaÃ±o, la <em>raÃ­z del Ã­ndice</em> sÃ³lo puede almacenar unas pocas entradas de archivos del directorio.
En ese caso la <em>raÃ­z del Ã­ndice</em> contiene el nivel superior del Ã¡rbol B+.
Es decir, cada una de esas entradas de archivos en la <em>raÃ­z del Ã­ndice</em> incluye tambiÃ©n un puntero al bloque del disco que contiene un nodo del Ã¡rbol con las entradas con nombres alfabÃ©ticamente anteriores a ese.
Si en dicho nodo tampoco caben todas las entradas, sÃ³lo podrÃ¡ contener algunas de ellas, por lo que cada una tendrÃ¡ a su vez un puntero a un nuevo nodo del Ã¡rbol; y asÃ­ sucesivamente</p>
</div>
<div class="paragraph">
<p>Las <em>ventajas</em> de los Ã¡rboles B+ son:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Eliminan el coste de reordenar las entradas del directorio.</em></p>
</li>
<li>
<p><em>La longitud desde la raÃ­z del Ã¡rbol hasta un nodo hoja es la misma para todas los caminos por el Ã¡rbol</em>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El sistema de archivos XFS tambiÃ©n utiliza un Ã¡rbol B+, pero en Ã©ste
caso la implementaciÃ³n es un poco mÃ¡s compleja:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Un directorio de pequeÃ±o tamaÃ±o almacena sus entradas como una lista lineal no ordenada dentro de su mismo <em>inodo</em> o FCB.</p>
</li>
<li>
<p>Cuando el directorio no cabe en el <em>inodo</em> se le asigna un bloque propio, donde el directorio es implementado con una tabla de dispersiÃ³n, tal y como hemos visto anteriormente.</p>
</li>
<li>
<p>Cuando el tamaÃ±o del directorio excede el tamaÃ±o del bloque, la tabla de dispersiÃ³n se extrae y se almacena en un bloque diferente. La lista lineal tambiÃ©n se extrae, pero no tiene que ser almacenada en un Ãºnico bloque, sino que puede estar repartida por distintos bloques a lo largo del disco.</p>
</li>
<li>
<p>Finalmente, cuando la tabla de dispersiÃ³n excede el tamaÃ±o de un bloque, dicha tabla se convierte en un Ã¡rbol B+.</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mÃ©todos_de_asignaciÃ³n">25.2. MÃ©todos de asignaciÃ³n</h3>
<div class="paragraph">
<p>El siguiente problema es <em>cÃ³mo</em> asignar el espacio disponible en el disco a los archivos almacenados, de forma que el espacio sea utilizado de la forma mÃ¡s eficiente y que se pueda acceder a los archivos de la forma mÃ¡s rÃ¡pida posible.</p>
</div>
<div class="paragraph">
<p>Como la unidad mÃ­nima de asignaciÃ³n de espacio a un archivo es el bloque, la fragmentaciÃ³n interna suele ser un problema comÃºn a todos los mÃ©todos que veremos a continuaciÃ³n.</p>
</div>
<div class="sect3">
<h4 id="_asignaciÃ³n_contigua">25.2.1. AsignaciÃ³n contigua</h4>
<div class="paragraph">
<p><em>La <strong>asignaciÃ³n contigua</strong> requiere que cada archivo ocupe un conjunto contiguo de bloques en el disco</em>.
Esto es muy eficiente, puesto que el acceso a todos los datos de un archivo requiere un movimiento mÃ­nimo del cabezal del disco.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>El problema de la asignaciÃ³n contigua puede verse como un caso concreto del problema de la asignaciÃ³n dinÃ¡mica del almacenamiento</em> (vÃ©ase el <a href="#_hiperpaginaciÃ³n">Apartado 17.9</a>).
Es decir, que en un momento dado tendremos una peticiÃ³n de tamaÃ±o <em>n</em> que deberemos satisfacer con una lista de huecos libres de tamaÃ±o variable.
Como ya estudiamos anteriormente, las estrategias mÃ¡s comunes son las de el <em>primer ajuste</em> y el <em>mejor ajuste</em>.</p>
</li>
<li>
<p><em>La asignaciÃ³n contigua sufre el problema de la <strong>fragmentaciÃ³n externa</strong></em>.
La soluciÃ³n serÃ­a utilizar alguna forma de <strong>compactaciÃ³n</strong>, pero esto puede llevar mucho tiempo en discos duros de gran tamaÃ±o y en algunos sistemas esta tarea tiene que realizarse con el dispositivo desmontado.
Por eso es conveniente evitar utilizar tÃ©cnicas de compactaciÃ³n en los sistemas en producciÃ³n.
Afortunadamente, la mayor parte de los sistemas operativos modernos que necesitan mecanismos de <em>desfragmentaciÃ³n</em> pueden realizar esta tarea sin detener el sistema, aunque la perdida de rendimiento puede ser significativa.</p>
</li>
<li>
<p><em>En la asignaciÃ³n contigua es necesario determinar cuanto espacio necesita un archivo antes de asignÃ¡rselo, pero esto no siempre es posible</em>.
Por ejemplo, si vamos a copiar un archivo, es indudable que conocemos de antemano cuanto espacio necesita la copia.
Â¿Pero quÃ© pasa cuando, por ejemplo, vamos a crear uno nuevo? Entonces cuando se cree el archivo es necesario que el usuario indique una estimaciÃ³n del espacio que va necesitar.
Â¿Y si posteriormente que queremos aÃ±adir nuevos datos? Entonces, si hemos utilizado la estrategia del <em>mejor ajuste</em>, lo mÃ¡s probable es que el espacio situado a ambos lados del archivo ya estÃ© ocupado.
Para resolver esto existen dos posibilidades:</p>
<div class="ulist">
<ul>
<li>
<p><em>La primera es terminar el programa de usuario</em>, emitiendo un error.
Entonces, el usuario deberÃ¡ volver a crear el archivo indicando mÃ¡s espacio y volver a ejecutar el programa.
Puesto que las ejecuciones repetidas pueden ser muy costosas, lo mÃ¡s comÃºn es que el usuario acabe sobrestimando el espacio, lo que darÃ¡ como resultado un desperdicio de espacio considerable.</p>
</li>
<li>
<p><em>La segunda es buscar un hueco libre de mayor tamaÃ±o y copiar el contenido del archivo al nuevo espacio</em>.
Esto puede hacerse siempre que exista suficiente espacio, aunque puede consumir bastante tiempo.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para minimizar estos problemas, se puede implementar un esquema de asignaciÃ³n contigua modificado, donde <em>se asigna inicialmente un bloque contiguo de espacio al archivo y, posteriormente, si dicho espacio resulta no ser lo suficientemente grande, se aÃ±ade otra Ã¡rea de espacio contiguo, denominado *extensiÃ³n*</em>.
La ubicaciÃ³n de los bloques de un archivo se registra incluyendo en el FCB la direcciÃ³n del primer bloque de cada extensiÃ³n que compone el archivo, asÃ­ como el nÃºmero de bloques que ocupa cada una.</p>
</div>
<div class="paragraph">
<p>Los sistemas de archivo XFS y ext4 utilizan extensiones para optimizar su funcionamiento, pues cuantos mÃ¡s bloques contiguos sean asignados a un archivo, menos reposicionamientos del cabezal del disco son necesarios para leerlos.
Por ejemplo, en ext4 el espacio se asigna a los archivos en extensiones de hasta 128MB en bloques, generalmente, de 4KB.</p>
</div>
</div>
<div class="sect3">
<h4 id="_asignaciÃ³n_enlazada">25.2.2. AsignaciÃ³n enlazada</h4>
<div class="paragraph">
<p><em>En la <strong>asignaciÃ³n enlazada</strong> cada archivo es una lista enlazada de bloques de disco</em>, pudiendo estos bloques estar dispersos por todo el disco:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Cada entrada de directorio contiene un puntero al primer</em> bloque y, en ocasiones, al Ãºltimo para facilitar que se puedan aÃ±adir nuevos datos al final</p>
</li>
<li>
<p><em>Cada bloque contiene un puntero al bloque siguiente</em>.
Por ejemplo, si cada bloque tiene 512 bytes de tamaÃ±o y un puntero requiere 4 bytes, los bloques de disco tendrÃ¡n un tamaÃ±o efectivo de 508 bytes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este mecanismo resuelve todos los problemas de la asignaciÃ³n contigua.
AdemÃ¡s:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>No hay fragmentaciÃ³n externa</em>, puesto que pueden utilizarse cualquier bloque libre para satisfacer una solicitud de espacio.</p>
</li>
<li>
<p><em>No es necesario declarar el espacio del archivo en el momento de crearlo</em>, pues siempre podrÃ¡ seguir creciendo mientras hayan bloques libres.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sin embargo, la asignaciÃ³n enlazada tambiÃ©n tiene sus desventajas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>SÃ³lo resulta eficaz para archivos de acceso secuencial</em>.
Si queremos ir directamente al bloque i-esimo de un archivo, tendremos que comenzar desde el principio e ir leyendo cada bloque para obtener el puntero que nos indica el siguiente bloque.
Es muy posible que en ocasiones esas lecturas deban ir precedidas de un reposicionamiento de los cabezales del disco.</p>
</li>
<li>
<p><em>Se pierde cierta cantidad de espacio con los punteros</em>.
Si, por ejemplo, un puntero ocupa 4 bytes y un bloque tienen un tamaÃ±o de 512 bytes, el 0,758% del espacio en disco serÃ¡ utilizado para los punteros, en lugar de para almacenar informaciÃ³n Ãºtil.
La soluciÃ³n para este problema consiste en asignar los bloques en grupos, denominados <strong>clusters</strong>.
AsÃ­, el primer bloque de cada <em>cluster</em> sÃ³lo tendrÃ­a que almacenar un puntero al siguiente <em>clÃºster</em>, lo que reducirÃ­a la cantidad de espacio desperdiciada en los punteros y mejorarÃ­a la eficiencia al reducir el nÃºmero de reposicionamiento del cabezal del disco.
Sin embargo, tambiÃ©n incrementarÃ­a el grado de fragmentaciÃ³n interna pues se pierde mÃ¡s espacio cuando un <em>cluster</em> estÃ¡ parcialmente lleno.</p>
</li>
<li>
<p><em>Otro problema es la fiabilidad</em>.
Teniendo en cuenta que los archivos estÃ¡n enlazados mediante punteros, Â¿quÃ© sucederÃ­a si uno de esos punteros se pierde o resulta daÃ±ado?</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>El sistema de archivos FAT utiliza una variante del mecanismo de
asignaciÃ³n enlazada en la que se utiliza una <strong>tabla de asignaciÃ³n de
archivo</strong> o <strong>FAT</strong> (<em>File-Allocation Table</em>). Ãste mÃ©todo consiste
en lo siguiente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La FAT es una tabla que contiene una entrada por cada bloque del disco y que se indexa segÃºn el nÃºmero de bloque. Es decir, la entrada 10 de la FAT contiene informaciÃ³n del bloque 10 del disco. La FAT se almacena en una secciÃ³n al principio del volumen.</p>
</li>
<li>
<p>Cada entrada de directorio de un archivo contiene, a parte del nombre de dicho archivo y otras atributos, el nÃºmero de bloque del primer bloque del disco con datos del archivo.</p>
</li>
<li>
<p>La entrada de la FAT indexada segÃºn ese nÃºmero de bloque del primer bloque del archivo contiene el nÃºmero de bloque del siguiente bloque del archivo. Iterando de esa manera se puede conocer los nÃºmeros de bloque de todos los bloques de un archivo.</p>
</li>
<li>
<p>El Ãºltimo bloque del archivo se indicar con un valor especial en su entrada en la FAT.</p>
</li>
<li>
<p>Los bloques no utilizados se indican con un valor igual a 0 en su entrada en la FAT.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El uso de la FAT puede provocar un nÃºmero importante de
reposicionamientos del cabezal de disco debido a que siempre es
necesario volver al principio del volumen para leer la FAT. Por eso, es
muy habitual que el sistema operativo intente mantener una copia de la
FAT en la memoria a modo de cache.</p>
</div>
<div class="paragraph">
<p>Una de las ventajas de este esquema es que mejora el tiempo de acceso
aleatorio, respecto a la asignaciÃ³n enlazada convencional, porque el
cabezal del disco puede encontrar la ubicaciÃ³n de cualquier bloque a
partir de la informaciÃ³n en la FAT.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_asignaciÃ³n_indexada">25.2.3. AsignaciÃ³n indexada</h4>
<div class="paragraph">
<p><em>El mecanismo de <strong>asignaciÃ³n indexada</strong> agrupa todos los punteros de la asignaciÃ³n enlazada en una Ãºnica ubicaciÃ³n</em>: el <strong>bloque de Ã­ndices</strong>.
AsÃ­ se resuelve la falta de eficiencia de la asignaciÃ³n enlazada âconvencional, en ausencia de FATâ cuando se realizan accesos aleatorios:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Cada archivo tiene su propio bloque de Ã­ndices</em>, que es un vector de direcciones de bloques de disco.</p>
</li>
<li>
<p><em>La entrada i-Ã©sima del bloque de Ã­ndice contiene la direcciÃ³n del bloque i-Ã©simo del archivo</em>.</p>
</li>
<li>
<p><em>Cada entrada de directorio contiene la direcciÃ³n del bloque de Ã­ndices del archivo correspondiente</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este mecanismo soporta el acceso aleatorio eficiente, ademÃ¡s de no sufrir el problema de la fragmentaciÃ³n externa.
Sin embargo, tambiÃ©n tiene sus desventajas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Se pierde mÃ¡s espacio en los punteros que con el mecanismo de asignaciÃ³n enlazada</em>.
No olvidemos que siempre hay que reservar un bloque de Ã­ndices completo para cada archivo, mientras que con la asignaciÃ³n enlazada sÃ³lo se pierde el espacio de los punteros que realmente es necesario utilizar.</p>
</li>
<li>
<p><em>Debemos determinar el tamaÃ±o del bloque de Ã­ndices</em>.
Por lo anterior y puesto que cada archivo debe tener un bloque de Ã­ndices, ese bloque debe ser lo mÃ¡s pequeÃ±o posible para no perder espacio.
Pero si es demasiado pequeÃ±o, no podrÃ¡ almacenar suficientes punteros para un archivo de gran tamaÃ±o.
Entre los mecanismos que pueden utilizarse para resolver este problema estÃ¡n los siguientes:</p>
<div class="ulist">
<ul>
<li>
<p><em>En el <strong>esquema enlazado</strong> se enlazan los bloques de Ã­ndices</em>.
Por ejemplo, se puede utilizar el Ãºltimo puntero del bloque de Ã­ndices para apuntar al siguiente bloque de Ã­ndices.
Si dicho puntero tiene el valor nulo, entonces estamos en el Ãºltimo bloque de Ã­ndices.</p>
</li>
<li>
<p><em>En el <strong>Ã­ndice multinivel</strong> los punteros del bloque de Ã­ndices no seÃ±alan a los bloques del archivo, sino a conjunto de bloques de Ã­ndices de segundo nivel</em>.
Estos a su vez seÃ±alan a los bloques del archivo.
Esta tÃ©cnica puede puede ampliarse utilizando un tercer o cuarto nivel, dependiendo del tamaÃ±o mÃ¡ximo de archivo que se desee.</p>
</li>
<li>
<p><em>En el *esquema combinado*</em> las primeras entradas del bloque de Ã­ndices apuntan directamente a los primeros bloques del archivo.
Mientras que las siguientes entradas contiene punteros indirectos, que apunta a un conjunto de bloques de Ã­ndices de segundo nivel, seguidos por entradas que contienen punteros doblemente indirectos, e incluso triplemente indirectos.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para mejorar el rendimiento de los mecanismos de asignaciÃ³n indexados, es muy comÃºn que el sistema operativo intente mantener los bloques de Ã­ndices en la memoria cachÃ©.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Nota"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Los sistemas de archivos ext2 y ext3 utilizan el mecanismo de
asignaciÃ³n indexada con esquema combinado. Concretamente el mecanismo en
ext2 se implementa de la siguiente manera:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El disco se divide en mÃºltiples grupos de bloques.</p>
</li>
<li>
<p>En cada grupo, los primeros bloques se utilizan para almacenar una tabla de <em>inodos</em> âlos FCB de los archivos en el grupoâ. El resto de los bloques se intentan utilizar para almacenar los datos de los archivos representados por los <em>inodos</em> del grupo.</p>
</li>
<li>
<p>Entre otra informaciÃ³n, dentro de cada <em>inodo</em> se almacenan los punteros a los bloques del archivo, en lugar de utilizar un bloque de Ã­ndices.</p>
</li>
<li>
<p>Los primeros 12 punteros en el <em>inodo</em> son directos, seguidos de un puntero indirecto y un puntero doblemente indirecto. Esto permite que el puntero de archivo sea de 64 bits y, por tanto, que se puedan almacenar 264 bytes de informaciÃ³n en cada archivo.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestiÃ³n_del_espacio_libre">25.3. GestiÃ³n del espacio libre</h3>
<div class="paragraph">
<p>Puesto que el espacio en disco es limitado, necesitamos poder reutilizar el espacio de los archivos borrados.
Para controlar el espacio libre en el disco, <em>el sistema mantiene una <strong>lista de espacio libre</strong> que contiene todos los bloques de disco libres</em>.
Para crear un archivo, se explora la lista de espacio libre hasta obtener la cantidad de espacio requerida y asignamos ese espacio al nuevo archivo.
A continuaciÃ³n estudiaremos como puede ser implementada esa lista.</p>
</div>
<div class="sect3">
<h4 id="_vector_de_bits">25.3.1. Vector de bits</h4>
<div class="paragraph">
<p><em>La lista de espacio libre puede ser implementada como un <strong>vector de bits</strong> o <strong>mapa de bits</strong>, donde cada bloque es representado por un bit</em>.
Si el bloque estÃ¡ libre, el bit estÃ¡ a 1; mientras que si el bloque estÃ¡ asignado, el bit estÃ¡ a 0.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Este enfoque es relativamente sencillo y eficiente</em>, puesto que muchos procesadores disponen de instrucciones para manipulaciÃ³n de bits que pueden utilizarse para obtener el primer bloque libre.
Por ejemplo, la familia de procesadores x86, a partir del 80386, tiene instrucciones que devuelven la posiciÃ³n del primer bit a 1 en el valor de un registro.</p>
</li>
<li>
<p>Sin embargo, <em>los vectores de bits son ineficientes a menos que se mantenga el vector completo en la memoria principal</em>, escribiÃ©ndose ocasionalmente en el disco.
Esto puede ser imposible para los discos de gran tamaÃ±o, en funciÃ³n de la cantidad de memoria principal.
Por ejemplo, un disco de 40 GB con bloques de 1 KB necesitarÃ¡ un mapa de bits de mÃ¡s de 5 MB, lo que no es un gran requisito para un sistema moderno pero si lo era hace dos dÃ©cadas.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El sistema de archivo NTFS y la familia <em>extended filesystem</em> âes decir, ext, ext2, ext3, etc.â utilizan mapas de bits tanto para gestionar los bloques de datos libres como las entradas disponibles en la tabla de <em>inodos</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_lista_enlazada">25.3.2. Lista enlazada</h4>
<div class="paragraph">
<p>Otra tÃ©cnica <em>consiste en enlazar todos los bloques de disco libres</em>.
Para eso se puede mantener un puntero al primer bloque libre en una ubicaciÃ³n especial del disco y que ese bloque contenga un puntero al siguiente bloque libre del disco.
El segundo bloque contendrÃ­a un puntero al tercer bloque libre y asÃ­ sucesivamente.</p>
</div>
<div class="paragraph">
<p><em>El inconveniente es que recorrer la lista no resulta eficiente</em>, pues tenemos que leer cada bloque para conocer la direcciÃ³n del siguiente bloque libre en disco.
Sin embargo, debemos tener en cuenta que no es frecuente tener que recorrer la lista de espacio libre completa porque, por lo general, basta con encontrar el primer bloque libre para asignar el espacio.</p>
</div>
<div class="paragraph">
<p>El mÃ©todo FAT incorpora el control de bloques libres dentro de la <em>tabla de asignaciÃ³n de archivos</em>, por lo que no se necesita ningÃºn mÃ©todo adicional</p>
</div>
</div>
<div class="sect3">
<h4 id="_agrupamiento">25.3.3. Agrupamiento</h4>
<div class="paragraph">
<p><em>Una modificaciÃ³n de la tÃ©cnica basada en la lista enlazada consiste en almacenar las direcciones de n bloques libres en el primer bloque libre</em>.
Los primeros <em>n â 1</em> de esos bloques estarÃ­an realmente libres, pero el Ãºltimo de esos bloques apuntarÃ­a a otro bloque con <em>n</em> bloques libres.
AsÃ­, podrÃ­an localizarse rÃ¡pidamente las direcciones de un gran nÃºmero de bloques libres, lo cual mejora la eficiencia respecto a la tÃ©cnica de lista enlazada.</p>
</div>
</div>
<div class="sect3">
<h4 id="_recuento">25.3.4. Recuento</h4>
<div class="paragraph">
<p>Generalmente los bloques son asignados o liberados en bloques contiguos, especialmente si el espacio es asignado mediante asignaciÃ³n contigua o en <em>extensiones</em> o <em>clusters</em>.
Esto puede ser aprovechado para <em>mantener una lista donde cada entrada almacena la direcciÃ³n del primer bloque de un conjunto de bloques libres contiguo, asÃ­ como el nÃºmero de bloques del conjunto</em>.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, el sistema de archivos XFS utiliza un Ã¡rbol B+ para almacenar las direcciones de las extensiones de bloques libres y mantenerlas ordenadas por el tamaÃ±o de la extensiÃ³n a la que apuntan.
AsÃ­ el sistema operativo puede localizar rÃ¡pidamente el espacio libre necesario para satisfacer una necesidad de espacio concreta.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_de_archivos_virtuales">25.4. Sistemas de archivos virtuales</h3>
<div class="paragraph">
<p>En el <a href="#_montaje_de_sistemas_de_archivos">Apartado 22.3</a> vimos cÃ³mo el sistema operativo <em>monta</em> sistemas de archivos de tal forma que aparenten estar integrados en una Ãºnica estructura de directorios, permitiendo a los usuarios moverse de forma transparente entre distintos dispositivos y tipos de sistemas de archivos.
Para hacerlo, un sistema operativo moderno debe ser capaz de soportar de manera eficiente distintos tipos de sistemas de archivos, ocultando sus diferencias de cara a los usuarios.</p>
</div>
<div class="paragraph">
<p>Un mÃ©todo para implementar mÃºltiples tipos de sistemas de archivos consiste en escribir diferentes rutinas de acceso, manipulaciÃ³n y gestiÃ³n, a los directorios y a los archivos, para cada uno de los tipos de sistema de archivo existentes.
Sin embargo, en lugar de esta soluciÃ³n, la mayorÃ­a de los sistemas operativos utilizan tÃ©cnicas de orientaciÃ³n a objetos para implementar diferentes tipos de sistemas de archivos detrÃ¡s de una misma interfaz de programaciÃ³n.
Es decir, <em>se utilizan estructuras de datos y procedimientos comunes para separar las llamadas al sistema de los detalles de su implementaciÃ³n real para cada uno de los sistemas de archivos</em>.</p>
</div>
<div class="paragraph">
<p>La implementaciÃ³n de un sistema de archivos estÃ¡ compuesta de tres niveles fundamentales:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El primer nivel es la <em>interfaz del sistema de archivos</em>, a la que acceden los desarrolladores a travÃ©s de las llamadas al sistema.
Estamos hablando de las llamadas <code>open()</code>, <code>read()</code>, <code>write()</code> y <code>close()</code>, entre otras, y de los descriptores de archivos.
Esta interfaz es la misma sea cual sea el sistema de archivos al que se estÃ© intentando acceder.</p>
</li>
<li>
<p>El segundo nivel es <em>la interfaz del <strong>sistema de archivos virtual</strong> o <strong>VFS</strong> (Virtual File System)</em>.
Este nivel es utilizado por el anterior para atender las peticiones realizadas.
Describe operaciones genÃ©ricas sobre cualquier sistema de archivos y estructuras genÃ©ricas como, por ejemplo, un FCB virtual âque en algunos sistemas operativos se denomina <em>vnodo</em>â <em>que identifica de forma unÃ­voca a cada archivo o directorio en uso en el sistema</em> âun <em>inodo</em> en los sistemas de archivos de Linux solo identifica a un archivo de forma unÃ­voca dentro del mismo sistema de archivosâ y que da acceso a sus metadatos.
Este nivel cumple con dos importantes funciones:</p>
<div class="ulist">
<ul>
<li>
<p><em>Separa las operaciones genÃ©ricas sobre el sistema de archivos con respecto a su implementaciÃ³n</em>.
VFS define una interfaz muy clara comÃºn para todos los sistemas de archivos.
Pero en el mismo sistema existirÃ¡n diversas implementaciones de la interfaz VFS, una para cada sistema de archivos diferente.</p>
</li>
<li>
<p><em>Proporcionar un mecanismo para acceder de forma coherente a los archivos a travÃ©s de la red</em>.
Una implementaciÃ³n de VFS no tiene que estar limitada exclusivamente a ofrecer acceso a archivos en dispositivos conectados fÃ­sicamente al sistema.
Las operaciones de la interfaz VFS pueden resolverse utilizando un protocolo de acceso a algÃºn servidor de archivos conectado a la red.</p>
</li>
</ul>
</div>
</li>
<li>
<p>El tercer nivel es donde <em>se implementa cada tipo de sistema de archivos o los distintos protocolos de los servidores de archivos en la red</em>.
La interfaz VFS recurre a la implementaciÃ³n correspondiente para cada tipo de sistema de archivos para satisfacer las solicitudes de los niveles superiores.
AsÃ­, por ejemplo, un <code>read()</code> puede implicar que se tenga que recuperar el <em>vnodo</em> del archivo involucrado desde la tabla del archivos abiertos, usando el descriptor indicado en la llamada al sistema.
DespuÃ©s se <em>invocarÃ­a la operaciÃ³n _VFS</em> <code>read()</code>, sobre el <em>vnodo</em>, en la implementaciÃ³n concreta de VFS segÃºn el tipo de sistema de archivos involucrado.
SerÃ¡ esa implementaciÃ³n quien extraiga del <em>vnodo</em> la informaciÃ³n necesaria âpor ejemplo, el <em>inodo</em> real del archivo en el sistema de archivosâ para llevar acabo la operaciÃ³n indicada, segÃºn las especificidades del sistema de archivos.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_planificaciÃ³n_de_disco">26. PlanificaciÃ³n de disco</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Como ya hemos comentado, es responsabilidad del sistema operativo usar los recursos del hardware de forma eficiente.
Eso incluye planificar los procesos en la CPU para conseguir el mÃ­nimo tiempo de espera que sea posible o aprovechar de la mejor forma la memoria principal disponible para atender la demanda de los distintos procesos al mismo tiempo; pero tambiÃ©n, intentar obtener el menor tiempo de acceso y el mayor ancho de banda posible en el acceso a los discos.</p>
</div>
<div class="sect2">
<h3 id="_rendimiento_del_acceso_a_disco">26.1. Rendimiento del acceso a disco</h3>
<div class="paragraph">
<p>En un disco duro magnÃ©tico el <strong>tiempo de acceso al disco</strong> \$T^d\$ viene determinado por el <strong>tiempo de bÃºsqueda</strong> \$T^b\$ y la <strong>latencia rotacional</strong> \$T^r\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$T_d=T_b+T_r\$
</div>
</div>
<div class="paragraph">
<p><em>El tiempo de bÃºsqueda \$T^b\$ es el tiempo que se tarda en mover el brazo del disco hasta el cilindro deseado.
Mientras que la latencia rotacional \$T^r\$ es el tiempo que hay que esperar para que el disco gire _asta que la cabeza llegue al sector deseado</em> del cilindro.
Por lo tanto, el <em>tiempo de acceso al disco</em> es menor cuando se realizan accesos consecutivos a sectores fÃ­sicamente prÃ³ximos que cuando estÃ¡n dispersos por todo el disco.</p>
</div>
<div class="paragraph">
<p><em>El <strong>ancho de banda</strong> o <strong>tasa de transferencia</strong> del disco es el nÃºmero total de bytes transferidos dividido por el tiempo total que transcurre desde la primera solicitud de servicio a la terminaciÃ³n de la Ãºltima transferencia</em> con la que se atiende la peticiÃ³n.
Al considerar todo el tiempo necesario para atender la peticiÃ³n, a mÃ¡s <em>tiempo de acceso al disco</em> menor es el <em>ancho de banda</em>.</p>
</div>
<div class="paragraph">
<p>En los dispositivos de almacenamiento basados en memorias de estado sÃ³lido (vÃ©ase el <a href="#_memorias_de_estado_sÃ³lido">Apartado 19.3</a>) el tiempo de acceso viene determinado por las caracterÃ­sticas de la memoria, entre otros factores, lo que hace que las diferencias entre accesos secuenciales y accesos aleatorios sean mucho menos significativas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cola_de_es_al_disco">26.2. Cola de E/S al disco</h3>
<div class="paragraph">
<p>Cuando se solicita una operaciÃ³n de E/S sobre el almacenamiento el sistema operativo puede atender la peticiÃ³n sobre la marcha si la controladora y la unidad de disco estÃ¡n disponibles.
Pero si estÃ¡n ocupadas, la solicitud se almacena en una cola de peticiones pendientes.
Cuando se resuelve una solicitud, el sistema operativo escoge otra de la cola y se comunica con el hardware para programar la siguiente peticiÃ³n.
La cuestiÃ³n es Â¿cuÃ¡l es el orden adecuado para escoger la peticiones de E/S de la cola si se quiere acceder al disco de la forma mÃ¡s eficaz posible?</p>
</div>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n_fcfs">26.3. PlanificaciÃ³n FCFS</h3>
<div class="paragraph">
<p>En la planificaciÃ³n <strong>FCFS</strong> (<em>First Come, First Served</em>) o <em>primero que llega, primero servido</em> la cola es FIFO.
Es decir, <em>se atienden las solicitudes en orden de llegada</em>.
Es la planificaciÃ³n mÃ¡s simple y es equitativa âpues se atiende a todos los procesos por igualâ pero no proporciona el servicio mÃ¡s rÃ¡pido en disco duros magnÃ©ticos, donde interesa mover el brazo del disco lo menos posible.</p>
</div>
<div class="paragraph">
<p>En los sistemas operativos Linux el FCFS es denominado NOOP y se suele utilizar en los discos basados en memorias de estado sÃ³lido, donde reordenar las solicitudes no proporciona una mejora significativa del rendimiento, o cuando se utilizan controladoras de disco inteligentes que pueden reordenar las solicitudes segÃºn su propio criterio.</p>
</div>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n_sstf">26.4. PlanificaciÃ³n SSTF</h3>
<div class="paragraph">
<p>En la planificaciÃ³n <strong>SSTF</strong> (<em>Sortest</em> <em>Seek Time First</em>) o algoritmo de <em>tiempo de bÃºsqueda mÃ¡s corto</em>, de toda cola se selecciona la solicitud con el menor <em>tiempo de bÃºsqueda</em> desde la posiciÃ³n actual de la cabeza.
Como el <em>tiempo de bÃºsqueda</em> se incrementa a medida que lo hace el nÃºmero de cilindros que es necesario recorrer, este algoritmo de planificaciÃ³n primero da servicio a las solicitudes cercanas a la posiciÃ³n actual de la cabeza, antes de alejarse para dar servicio a otras solicitudes.
Aun asÃ­, la soluciÃ³n no es Ã³ptima.</p>
</div>
<div class="paragraph">
<p>El problema de SSTF es que <em>puede provocar inaniciÃ³n de algunas solicitudes</em> si van llegando constantemente nuevas solicitudes sobre regiones cercanas a donde estÃ¡ actualmente la cabeza del disco.</p>
</div>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n_scan_y_c_scan">26.5. PlanificaciÃ³n SCAN y C-SCAN</h3>
<div class="paragraph">
<p>En la planificaciÃ³n <strong>SCAN</strong> o algoritmo de <em>exploraciÃ³n</em> o del <em>ascensor</em> <em>el brazo del disco comienza en un extremo del disco y se mueve hacia el otro atendiendo solicitudes a medida que pasa por cada cilindro</em>, hasta llegar al otro extremo del disco.
En el otro extremo la direcciÃ³n de movimiento de la cabeza se invierte para recorrer el disco en sentido inverso, repitiendo el proceso.</p>
</div>
<div class="paragraph">
<p>Suponiendo que las solicitudes se distribuyen de forma uniforme a lo largo del disco, es de suponer que cuando se llega a un extremo, antes de volver, la cantidad de solicitudes en dicho extremo serÃ¡ notablemente menor que en el otro extremo del disco.
Entonces Â¿por quÃ© no empezar por el otro extremo?</p>
</div>
<div class="paragraph">
<p><em>A la variante del SCAN que cuando llega a un extremo vuelve al inicio, sin atender ninguna solicitud por el camino, para volver a empezar se la denomina <strong>C-SCAN</strong></em>.
El resultado es que el tiempo que tiene que esperar una solicitud para ser atendida es mÃ¡s uniforme que con el algoritmo SCAN.</p>
</div>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n_look_y_c_look">26.6. PlanificaciÃ³n LOOK y C-LOOK</h3>
<div class="paragraph">
<p>En teorÃ­a los algoritmos SCAN y C-SCAN hacen que el brazo recorra los cilindros del primero al Ãºltimo.
Sin embargo realmente no se suelen implementar asÃ­.
Por lo general, <em>cuando en el recorrido del brazo, tras atender una solicitud, se descubre que ya no hay mÃ¡s solicitudes siguiendo la misma direcciÃ³n, el brazo invierte la direcciÃ³n sin llegar hasta el extremo del disco</em>.
A estas variantes de SCAN y C-SCAN se las denomina <strong>LOOK</strong> y <strong>C-LOOK</strong>, respecitvamente.</p>
</div>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n_n_step_scan_n_step_look_y_fscan">26.7. PlanificaciÃ³n N-Step-SCAN, N-Step-LOOK y FSCAN</h3>
<div class="paragraph">
<p>Los algoritmos <em><strong>N-Step-SCAN</strong> y <strong>N-Step-LOOK</strong></em> son variantes de los algoritmos SCAN y LOOK, respectivamente, donde <em>se limita a N el nÃºmero de solicitudes que se atenderÃ¡n en cada barrido del brazo del disco</em>.
Estos algoritmos funcionan de la siguiente manera:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Se utiliza una cola con espacio para <em>N</em> solicitudes pendientes que se van atendiendo mientras el brazo barre el disco.</p>
</li>
<li>
<p>Mientras tanto, todas las nuevas solicitudes se incorporan a una cola diferente.</p>
</li>
<li>
<p>Cuando el brazo termina el barrido y las <em>N</em> primeras solicitudes han sido atendidas, el planificador toma otras <em>N</em> solicitudes de la segunda cola y las introduce en la primera para repetir el proceso.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Si en lugar de copiar <em>N</em> peticiones de la segunda a la primera cola se copian todas las solicitudes pendientes, el algoritmo se denomina F-SCAN.</p>
</div>
<div class="paragraph">
<p>Estos algoritmos previenen un problema denominado <em>rigidez del brazo</em> â<em>arm stickiness</em>, en inglÃ©sâ a diferencia de los algoritmos SSTF, SCAN, C-SCAN, LOOK y C-LOOK.
El termino <em>rigidez del brazo</em> hace referencia a cuando hay un flujo continuo de solicitudes para el mismo cilindro, lo que hace que con los algoritmos anteriores el brazo no avance por los cilindros hasta llegar la otro extremo.
Como FSCAN, N-Step-SCAN y N-Step-LOOK separan las solicitudes en dos colas, haciendo que las nuevas tengan que esperar, el brazo siempre continua su barrido hacia el extremo del disco.</p>
</div>
</div>
<div class="sect2">
<h3 id="_planificaciÃ³n_cfq">26.8. PlanificaciÃ³n CFQ</h3>
<div class="paragraph">
<p><em>El planificador <strong>CFQ</strong> (Completely Fair Queuing) se diseÃ±Ã³ para compartir de forma equitativa el ancho de banda entre todos los procesos que solicitan acceso al disco</em>.
Es utilizado actualmente por defecto en los sistemas Linux modernos y funciona de la siguiente manera:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>CFQ mantiene una cola de solicitudes para cada proceso y en ella inserta las solicitudes sÃ­ncronas de E/S.
Cada cola tiene una ventana de tiempo âo <em>cuanto</em>â para acceder al disco.
La longitud de la ventana de tiempo y el tamaÃ±o mÃ¡ximo de cada cola dependen de la prioridad de E/S que tenga el proceso.</p>
</li>
<li>
<p>CFQ mantiene una cola de solicitudes por cada prioridad de E/S, donde se insertan las solicitudes asÃ­ncronas de todos los procesos.
Una solicitud asÃ­ncronas se inserta en una cola u otra segÃºn la prioridad del proceso que la generÃ³.</p>
</li>
<li>
<p>Usando el algoritmo <em>round-robin</em>, el planificador CFQ recorre las colas y extrae de ellas las solicitudes durante el tiempo marcado por el cuanto de cada una.
Las solicitudes extraÃ­das se insertan en la cola de envÃ­o, donde se ordenar para minimizar el <em>tiempo de bÃºsqueda</em>, antes de ser enviadas <em>al</em> dispositivo.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bibliografÃ­a">BibliografÃ­a</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte de los contenidos de este documento estÃ¡n basados en las siguientes fuentes:</p>
</div>
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="Bavier2000"></a>[Bavier2000]
Bavier, A. Â«Creating New CPU Schedulers with Virtual TimeÂ». En 21st IEEE Real-Time Systems Symposium (RTSS 2000) WIP Proceedings, 2000.</p>
</li>
<li>
<p><a id="Friedman1999"></a>[Friedman1999]
Friedman, M. B. Â«Windows NT Page Replacement PoliciesÂ». En 25th International Computer Measurement Group Conference, December 5-10, 1999, Pag. 234-244.</p>
</li>
<li>
<p><a id="Ganger2000"></a>[Ganger2000]
Ganger, G. R., McKusick, M. K., Soules, C. A. N. y Patt, Y. N. Â«Soft Updates: A Solution to the Metadata Update Problem in File SystemsÂ». En ACM Transactions on Computer Systems, Vol. 18, No. 2, May 2000, Pag. 127â153.</p>
</li>
<li>
<p><a id="Gorman2004"></a>[Gorman2004]
Gorman, M. Â«Understanding the Linux Virtual Memory ManagerÂ». Prentice Hall, 2004.</p>
</li>
</ul>
</div>
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="Hailperin2006"></a>[Hailperin2006]
Hailperin, M. Â«Operating Systems and Middleware: Supporting Controlled InteractionÂ». Course Technology, 2006.</p>
</li>
<li>
<p><a id="Jacob1998"></a>[Jacob1998]
Jacob, B y Mudge, T. Â«Virtual Memory: Issues of ImplementationÂ». Computer, 31:33-43, 1998. ISSN 0018-9162. DOI: 10.1109/2.683005. URL <a href="http://dx.doi.org/10.1109/2.683005" class="bare">http://dx.doi.org/10.1109/2.683005</a>.</p>
</li>
</ul>
</div>
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="Microsoft2005"></a>[Microsoft2005]
Â«Kernel Enhancements for Microsoft Windows Vista and Windows Server LonghornÂ» [en lÃ­nea]. Microsoft Corporation, 2005. URL <a href="https://www.slideserve.com/iolani/kernel-enhancements-for-windows-server-longhorn" class="bare">https://www.slideserve.com/iolani/kernel-enhancements-for-windows-server-longhorn</a>.</p>
</li>
</ul>
</div>
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="Microsoft2003"></a>[Microsoft2003]
Â«Kernel Enhancements for Windows XPÂ» [en lÃ­nea]. Microsoft Corporation, 2003 [2006]. URL <a href="http://goo.gl/ugED" class="bare">http://goo.gl/ugED</a>.</p>
</li>
</ul>
</div>
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="SGI2006"></a>[SGI2006]
Â«XFS Filesystem StructureÂ» [en lÃ­nea]. Silicon Graphics Inc, 2006 [2007]. URL <a href="https://goo.gl/YF82JB" class="bare">https://goo.gl/YF82JB</a></p>
</li>
<li>
<p><a id="Silberschatz2004"></a>[Silberschatz2004]
Silberschatz, A., Galvin, P. y Gagne, G. <a href="http://absysnetweb.bbtk.ull.es/cgi-bin/abnetopac?ACC=DOSEARCH&amp;xsqf99=184173.titn./">Â«Operating System Concepts with JavaÂ»</a>. 6Âº ed. John Wiley &amp; Sons Inc., 2004.</p>
</li>
<li>
<p><a id="Silberschatz2005"></a>[Silberschatz2005]
Silberschatz, A., Galvin, P. y Gagne, G. <a href="http://absysnetweb.bbtk.ull.es/cgi-bin/abnetopac?ACC=DOSEARCH&amp;xsqf99=345629.titn./">Â«Fundamentos de Sistemas OperativosÂ»</a>. 7Âª ed. McGraw Hill, 2005.</p>
</li>
<li>
<p><a id="Wikipedia-cmalloc"></a>[Wikipedia-cmalloc]
Â«C dynamic memory allocationÂ» [en lÃ­nea]. Wikipedia (en), [2011]. URL <a href="http://goo.gl/OkFJ3" class="bare">http://goo.gl/OkFJ3</a></p>
</li>
</ul>
</div>
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="Wikipedia-RAID"></a>[Wikipedia-RAID]
Â«RAIDÂ» [en lÃ­nea]. Wikipedia (en), [2011]. URL <a href="http://goo.gl/GTQU" class="bare">http://goo.gl/GTQU</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. POSIX Threads se implementa en el nÃºcleo en los sistemas Linux y en la mayor parte de los UNIX actuales.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. MÃ¡s informaciÃ³n de Stackless Python: <a href="http://www.stackless.com/" class="bare">http://www.stackless.com/</a>
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. MÃ¡s informaciÃ³n de GNU Pthreads: <a href="http://www.gnu.org/software/pth/" class="bare">http://www.gnu.org/software/pth/</a>.
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. De ahora en adelante, cuando usemos el tÃ©rmino funciÃ³n nos estaremos refiriendo a cualquier procedimiento, funciÃ³n, mÃ©todo, subprograma, subrutina o rutina del programa.
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. Una operaciÃ³n o conjunto de operaciones es atÃ³mica o no interrumpible si de cara al resto del sistema parece que la operaciÃ³n ocurre de forma instantÃ¡nea e indivisible.
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. En la literatura sobre algoritmos de planificaciÃ³n de la CPU se indica que SJF (<em>Shortest-Job First</em>) y SRTF (<em>Shortest-Remaing-Time First</em>) son los Ã³ptimos respecto al tiempo de espera promedio precisamente porque siempre escogen al proceso con la rÃ¡faga de CPU mÃ¡s corta de entre los que esperan en la cola de preparados.
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. Los algoritmos FCFS y RR se pueden combinar de mÃºltiples maneras. En algunos sistemas todas las colas son o bien FCFS o bien RR, mientras que en otros unas colas pueden ser de un tipo y otras del otro. Por ejemplo, en el nÃºcleo Linux las prioridades mÃ¡s altas âlas etiquetadas como de tiempo realâ tienen tanto una cola FCFS como una cola RR. En cada prioridad primero se planifican los procesos de la cola FCFS y despuÃ©s lo de la cola RR.
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a>. Por ejemplo, dados tres procesos con una duraciÃ³n cada uno de ellos de 10 unidades de tiempo y cuanto igual a 1, el tiempo de ejecuciÃ³n promedio serÃ¡ de 29 unidades. Sin embargo si el cuanto de tiempo fuera 10, el tiempo de ejecuciÃ³n promedio caerÃ­a a 20 unidades de tiempo.
</div>
<div class="footnote" id="_footnotedef_9">
<a href="#_footnoteref_9">9</a>. De manera prÃ¡ctica actualmente se utilizan tiempos de cuanto de entre 10 y 100 ms. Estos tiempos son mucho mayores que los tiempos de cambios de contexto, que generalmente son inferiores a 10Âµs.
</div>
<div class="footnote" id="_footnotedef_10">
<a href="#_footnoteref_10">10</a>. Microsoft Windows, macOS, Oracle/Sun Microsystems Solaris, las versiones de Linux anteriores a la 2.6.23 y, en general, casi la totalidad de los sistemas operativos modernos de propÃ³sito general utilizan este tipo de planificaciÃ³n de prioridades dinÃ¡micas con RR como planificador en cada prioridad.
</div>
<div class="footnote" id="_footnotedef_11">
<a href="#_footnoteref_11">11</a>. Linux desde la versiÃ³n 2.6.23 utiliza un tipo de <strong>planificador equitativo ponderado</strong> denominado <strong>CFS</strong> (<em>Completely Fair Scheduler</em>) o <strong>planificador completamente justo.</strong>
</div>
<div class="footnote" id="_footnotedef_12">
<a href="#_footnoteref_12">12</a>. Linux, Microsoft Windows y la mayor parte de los sistemas operativos modernos de propÃ³sito general dividen el rango de prioridades en dos partes. El conjunto de prioridades mÃ¡s altas son prioridades de tiempo real y por tanto son fijas. Mientras que el grupo de prioridades mÃ¡s bajas son de tiempo no real y dinÃ¡micas. AdemÃ¡s el planificador se implementa de tal manera que un proceso con prioridad dinÃ¡mica nunca puede alcanzar el rango de prioridades de tiempo real.
</div>
<div class="footnote" id="_footnotedef_13">
<a href="#_footnoteref_13">13</a>. Un ejemplo de lo contrario âde sistema heterogÃ©neoâ se puede observar en los PC modernos donde muchos disponen tanto de una CPU como de una GPU especializada en el procesamiento de grÃ¡ficos y en las operaciones de coma flotante.
</div>
<div class="footnote" id="_footnotedef_14">
<a href="#_footnoteref_14">14</a>. El <em>HyperThreading</em> disponible en algunos procesadores de Intel es una implementaciÃ³n de la tecnologÃ­a <em>Simultaneous Multithreading</em>.
</div>
<div class="footnote" id="_footnotedef_15">
<a href="#_footnoteref_15">15</a>. En los sistemas de <em>multiprocesamiento asimÃ©trico</em> hay una CPU maestra y varias esclavas a quienes la primera entrega el trabajo. En ocasiones las CPU esclavas se distinguen por haber sido diseÃ±adas para realizar algÃºn tipo de trabajo de forma eficiente âcomo es el caso las GPU, que no son sino CPU diseÃ±adas para el procesamiento de grÃ¡ficosâ o por el hardware al que estÃ¡n conectadas âcomo por ejemplo las CPU unidas a discos para gestionarlosâ.
</div>
<div class="footnote" id="_footnotedef_16">
<a href="#_footnoteref_16">16</a>. En los sistemas de <em>multiprocesamiento simÃ©trico</em> o <em>SMP</em> (<em>Symmetric Multiprocessing</em>) todos los procesadores son iguales. Todos comparten los mismos recursos, pueden acceder a los mismos dispositivos y cada uno ejecuta una copia del nÃºcleo del sistema operativo. Por lo tanto el sistema operativo debe saber compartir los recursos y repartir la carga entre las CPU. Casi todos los sistemas multiprocesador modernos son de este tipo.
</div>
<div class="footnote" id="_footnotedef_17">
<a href="#_footnoteref_17">17</a>. Desde el Intel Pentium las CPU de la familia x86 incorporan un contador de marca de tiempo (Time Stamp Counter o TSC) de 64 bits que indica el nÃºmero de ciclos transcurridos desde el Ãºltimo <em>reset</em> del procesador.
</div>
<div class="footnote" id="_footnotedef_18">
<a href="#_footnoteref_18">18</a>. La soluciÃ³n a este problema pasa porque la CPU disponga de una eficiente y pequeÃ±a âde entre 64 y 1024 entradasâ memoria cachÃ© en la que almacenar las entradas de la tabla de pÃ¡gina previamente utilizadas en la traducciÃ³n de las direcciones. A dicha cachÃ© se la denomina TLB (Translation Look-aside Buffer). Obviamente es necesario que el asignador borre la TLB durante los cambios de contexto.
</div>
<div class="footnote" id="_footnotedef_19">
<a href="#_footnoteref_19">19</a>. Se trata de una aproximaciÃ³n puesto que usando el <em>bit de referencia</em> el sistema operativo no puede conocer con exactitud la Ãºltima vez que una pÃ¡gina fue utilizada. Sin embargo, aunque existen soluciones exactas que hacen uso de un contador o de una pila que se actualiza en cada acceso a las pÃ¡ginas, se trata de soluciones muy costosas como para ser implementarlas en hardware.
</div>
<div class="footnote" id="_footnotedef_20">
<a href="#_footnoteref_20">20</a>. Es comÃºn que los nÃºcleos de los sistemas operativos utilicen pÃ¡ginas de gran tamaÃ±o para alojar su cÃ³digo y sus datos. De esta forma se minimiza el nÃºmero de entradas de la TLB que utilizan, con el fin de disponer de mÃ¡s entradas libres para los procesos en ejecuciÃ³n.
</div>
<div class="footnote" id="_footnotedef_21">
<a href="#_footnoteref_21">21</a>. En RAID se denomina divisiÃ³n o stripe a la serie de bloques consecutivos escogido cada uno de uno de los discos del conjunto.
</div>
<div class="footnote" id="_footnotedef_22">
<a href="#_footnoteref_22">22</a>. En algunos entornos se denomina a este tipo de implementaciones <em>fakeRAID</em> o <em>hostRAID</em>.
</div>
<div class="footnote" id="_footnotedef_23">
<a href="#_footnoteref_23">23</a>. Dependiendo de la unidad de disco, los sectores pueden tener tamaÃ±os de entre 32 bytes y 4096 bytes. Lo mÃ¡s comÃºn es que su tamaÃ±o sea de 512 bytes.
</div>
<div class="footnote" id="_footnotedef_24">
<a href="#_footnoteref_24">24</a>. Generalmente el sistema mantiene un puntero de lectura/escritura que hace referencia a la ubicaciÃ³n dentro del archivo en la que debe tener lugar la siguiente operaciÃ³n. Este puntero se actualiza avanzando cada vez que se realiza un nueva lectura/escritura. Para desplazarse aleatoriamente por el archivo, el sistema operativo debe ofrecer una llamada al sistema que permita reposicionar el puntero allÃ­ donde interese.
</div>
<div class="footnote" id="_footnotedef_25">
<a href="#_footnoteref_25">25</a>. En unos pocos sistemas los archivos se abren automÃ¡ticamente cuando un proceso solicita su primera operaciÃ³n sobre los mismos y se cierran cuando el proceso termina. Sin embargo lo mÃ¡s comÃºn es que los procesos tengan que abrir los archivos explÃ­citamente.
</div>
<div class="footnote" id="_footnotedef_26">
<a href="#_footnoteref_26">26</a>. La recolecciÃ³n de basura implica recorrer todo el sistema de archivos y marcar todos aquellos elementos que sean accesibles. DespuÃ©s, en una segunda pasada, se elimina todo lo que no estÃ© marcado.
</div>
<div class="footnote" id="_footnotedef_27">
<a href="#_footnoteref_27">27</a>. El registro generalmente se almacena en el mismo sistema de archivos. Sin embargo tambiÃ©n <em>suele ser</em> posible almacenarlo en otro volumen o incluso en otro disco.
</div>
</div>
<div id="footer">
<div id="footer-text">
Ãltima actualizaciÃ³n 2020-10-03 02:03:12 +0100
</div>
</div>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>